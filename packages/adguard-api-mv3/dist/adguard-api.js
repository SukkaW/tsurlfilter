(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 54:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * Compatibility types are used to configure engine for better support of different libraries
     * For example:
     *  extension doesnt support $app modifier. So if we set in configuration CompatibilityTypes.extension,
     *  engine would ignore rules with $app modifier
     */
    exports.CompatibilityTypes = void 0;
    (function (CompatibilityTypes) {
        CompatibilityTypes[CompatibilityTypes["Extension"] = 1] = "Extension";
        CompatibilityTypes[CompatibilityTypes["CoreLibs"] = 2] = "CoreLibs";
    })(exports.CompatibilityTypes || (exports.CompatibilityTypes = {}));
    /**
     * Application configuration class
     */
    var Configuration = /** @class */ (function () {
        function Configuration(inputConfig) {
            this.defaultConfig = {
                engine: null,
                version: null,
                verbose: false,
                compatibility: null,
            };
            /**
             * {'extension'|'corelibs'} engine application type
             */
            this.engine = null;
            /**
             * {string} version
             */
            this.version = null;
            /**
             * {boolean} verbose flag
             */
            this.verbose = false;
            /**
             * compatibility flag
             */
            this.compatibility = exports.CompatibilityTypes.Extension;
            var config = __assign(__assign({}, this.defaultConfig), inputConfig);
            this.engine = config.engine;
            this.version = config.version;
            this.verbose = config.verbose;
            this.compatibility = config.compatibility;
        }
        return Configuration;
    }());
    // eslint-disable-next-line import/no-mutable-exports
    exports.config = new Configuration();
    /**
     * Checks config is compatible with input level
     * @param compatibilityLevel
     * @private
     */
    function isCompatibleWith(compatibilityLevel) {
        if (exports.config.compatibility === null) {
            return false;
        }
        return (exports.config.compatibility & compatibilityLevel) === compatibilityLevel;
    }
    var setConfiguration = function (outerConfig) {
        exports.config = new Configuration(outerConfig);
    };

    /**
     * This class stores found cosmetic css rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticStylesResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticStylesResult() {
            this.generic = [];
            this.specific = [];
            this.genericExtCss = [];
            this.specificExtCss = [];
        }
        /**
         * Appends rule to the appropriate collection
         * @param rule
         */
        CosmeticStylesResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                if (rule.isExtendedCss()) {
                    this.genericExtCss.push(rule);
                }
                else {
                    this.generic.push(rule);
                }
            }
            else if (rule.isExtendedCss()) {
                this.specificExtCss.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        return CosmeticStylesResult;
    }());

    /**
     * This class stores found script rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticScriptsResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticScriptsResult() {
            this.generic = [];
            this.specific = [];
        }
        /**
         * Appends rule to appropriate collection
         * @param rule
         */
        CosmeticScriptsResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                this.generic.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        /**
         * Returns rules collected
         */
        CosmeticScriptsResult.prototype.getRules = function () {
            return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
        };
        return CosmeticScriptsResult;
    }());

    /**
     * This class stores found cosmetic html rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticHtmlResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticHtmlResult() {
            this.generic = [];
            this.specific = [];
        }
        /**
         * Appends rule to the appropriate collection
         * @param rule
         */
        CosmeticHtmlResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                this.generic.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        /**
         * Returns rules collected
         */
        CosmeticHtmlResult.prototype.getRules = function () {
            return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
        };
        return CosmeticHtmlResult;
    }());

    /**
     * Cosmetic result is the representation of rules
     * It is primarily used by the {@see CosmeticEngine}
     */
    var CosmeticResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticResult() {
            this.elementHiding = new CosmeticStylesResult();
            this.CSS = new CosmeticStylesResult();
            this.JS = new CosmeticScriptsResult();
            this.Html = new CosmeticHtmlResult();
        }
        /**
         * Script rules
         */
        CosmeticResult.prototype.getScriptRules = function () {
            return this.JS.getRules();
        };
        return CosmeticResult;
    }());

    /**
     * CosmeticOption is the enumeration of various content script options.
     * Depending on the set of enabled flags the content script will contain different set of settings.
     */
    exports.CosmeticOption = void 0;
    (function (CosmeticOption) {
        /**
         * if generic elemhide and CSS rules are enabled
         * Could be disabled by a $generichide rule and $elemhide rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionGenericCSS"] = 2] = "CosmeticOptionGenericCSS";
        /**
         * if specific elemhide and CSS rules are enabled
         * Could be disabled by a $specifichide rule and $elemhide rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionSpecificCSS"] = 4] = "CosmeticOptionSpecificCSS";
        /**
         * if JS rules and scriptlets are enabled
         * Could be disabled by a $jsinject rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionJS"] = 8] = "CosmeticOptionJS";
        /**
         * if Html filtering rules are enabled
         * Could be disabled by a $content rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionHtml"] = 16] = "CosmeticOptionHtml";
        /**
         * TODO: Add support for these flags
         * They are useful when content script is injected into an iframe
         * In this case we can check what flags were applied to the top-level frame
         */
        CosmeticOption[CosmeticOption["CosmeticOptionSourceGenericCSS"] = 32] = "CosmeticOptionSourceGenericCSS";
        CosmeticOption[CosmeticOption["CosmeticOptionSourceCSS"] = 64] = "CosmeticOptionSourceCSS";
        CosmeticOption[CosmeticOption["CosmeticOptionSourceJS"] = 128] = "CosmeticOptionSourceJS";
        /**
         * everything is enabled
         */
        CosmeticOption[CosmeticOption["CosmeticOptionAll"] = 30] = "CosmeticOptionAll";
        /**
         * everything is disabled
         */
        CosmeticOption[CosmeticOption["CosmeticOptionNone"] = 0] = "CosmeticOptionNone";
    })(exports.CosmeticOption || (exports.CosmeticOption = {}));

    /**
     * Splits the string by the delimiter, ignoring escaped delimiters.
     *
     * @param str - string to split
     * @param delimiter - delimiter
     * @param escapeCharacter - escape character
     * @param preserveAllTokens - if true, preserve empty parts
     * @param unescape - if true, delete EscapeCharacter
     * @return array of string parts
     */
    function splitByDelimiterWithEscapeCharacter(str, delimiter, escapeCharacter, preserveAllTokens, unescape) {
        if (unescape === void 0) { unescape = true; }
        var parts = [];
        if (!str) {
            return parts;
        }
        if (str.startsWith(delimiter)) {
            // eslint-disable-next-line no-param-reassign
            str = str.substring(1);
        }
        if (!str.includes(escapeCharacter)) {
            parts = str.split(delimiter);
            if (!preserveAllTokens) {
                parts = parts.filter(function (x) { return !!x; });
            }
            return parts;
        }
        var sb = [];
        for (var i = 0; i < str.length; i += 1) {
            var c = str.charAt(i);
            if (c === delimiter) {
                if (i > 0 && str.charAt(i - 1) === escapeCharacter) {
                    if (unescape) {
                        sb.splice(sb.length - 1, 1);
                    }
                    sb.push(c);
                }
                else if (preserveAllTokens || sb.length > 0) {
                    var part = sb.join('');
                    parts.push(part);
                    sb = [];
                }
            }
            else {
                sb.push(c);
            }
        }
        if (preserveAllTokens || sb.length > 0) {
            parts.push(sb.join(''));
        }
        return parts;
    }
    /**
     * Checks if the specified string starts with a substr at the specified index.
     *
     * @param str - String to check
     * @param startIndex - Index to start checking from
     * @param substr - Substring to check
     * @return boolean true if it does start
     */
    function startsAtIndexWith(str, startIndex, substr) {
        if (str.length - startIndex < substr.length) {
            return false;
        }
        for (var i = 0; i < substr.length; i += 1) {
            if (str.charAt(startIndex + i) !== substr.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if str has unquoted substr
     *
     * @param str
     * @param substr
     */
    function hasUnquotedSubstring(str, substr) {
        var quotes = ['"', "'", '/'];
        if (!str.includes(substr)) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (indexOfAny(str, quotes) === -1) {
            return true;
        }
        var stack = [];
        for (var i = 0; i < str.length; i += 1) {
            var cursor = str[i];
            if (stack.length === 0) {
                if (startsAtIndexWith(str, i, substr)) {
                    return true;
                }
            }
            if (quotes.indexOf(cursor) >= 0
                && (i === 0 || str[i - 1] !== '\\')) {
                var last = stack.pop();
                if (!last) {
                    stack.push(cursor);
                }
                else if (last !== cursor) {
                    stack.push(last);
                    stack.push(cursor);
                }
            }
        }
        return false;
    }
    /**
     * djb2 hash algorithm
     *
     * @param str string to get hash
     * @param begin index from
     * @param end index to
     * @return {number} hash
     */
    function fastHashBetween(str, begin, end) {
        var hash = 5381;
        for (var idx = begin; idx < end; idx += 1) {
            hash = 33 * hash + str.charCodeAt(idx);
        }
        return hash;
    }
    /**
     * djb2 hash algorithm
     *
     * @param str string to get hash
     * @return {number} hash
     */
    function fastHash(str) {
        if (str === '') {
            return 0;
        }
        var len = str.length;
        return fastHashBetween(str, 0, len);
    }
    /**
     * Look for any symbol from "chars" array starting at "start" index or from the start of the string
     *
     * @param str   String to search
     * @param chars Chars to search for
     * @param start Start index (optional, inclusive)
     * @return int Index of the element found or -1 if not
     */
    function indexOfAny(str, chars, start) {
        if (start === void 0) { start = 0; }
        if (str.length <= start) {
            return -1;
        }
        for (var i = start; i < str.length; i += 1) {
            var c = str.charAt(i);
            if (chars.indexOf(c) > -1) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Replaces all occurences of find with replace in str
     *
     * @param str
     * @param find
     * @param replace
     */
    function replaceAll(str, find, replace) {
        if (!str) {
            return str;
        }
        return str.split(find).join(replace);
    }
    /**
     * Checks if arrays are equal
     *
     * @param left array
     * @param right array
     * @return {boolean} true on equality
     */
    function stringArraysEquals(left, right) {
        if (!left || !right) {
            return !left && !right;
        }
        if (left.length !== right.length) {
            return false;
        }
        for (var i = 0; i < left.length; i += 1) {
            if (left[i] !== right[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if arrays have an intersection
     *
     * @param left array
     * @param right array
     * @return {boolean} true on equality
     */
    function stringArraysHaveIntersection(left, right) {
        if (!left || !right) {
            return true;
        }
        for (var i = 0; i < left.length; i += 1) {
            if (right.includes(left[i])) {
                return true;
            }
        }
        return false;
    }

    /* eslint-disable prefer-regex-literals */
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
    // should be escaped . * + ? ^ $ { } ( ) | [ ] / \
    // except of * | ^
    var specialCharacters = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '/', '\\'];
    var reSpecialCharacters = new RegExp("[".concat(specialCharacters.join('\\'), "]"), 'g');
    var reSpecialCharactersFull = /[.*+?^${}()|[\]\\]/g;
    var reEscapedSpecialCharactersFull = /\\[.*+?^${}()|[\]\\]/g;
    /**
     * Class with static helper methods for working with basic filtering rules patterns.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
     */
    var SimpleRegex = /** @class */ (function () {
        function SimpleRegex() {
        }
        /**
         * Extracts the shortcut from the rule's pattern.
         * Shortcut is the longest substring of the pattern that does not contain
         * any special characters.
         *
         * Please note, that the shortcut is always lower-case!
         *
         * @param pattern - network rule's pattern.
         * @returns the shortcut or the empty string if we could not extract any.
         */
        SimpleRegex.extractShortcut = function (pattern) {
            if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
                return this.extractRegexpShortcut(pattern);
            }
            return this.extractBasicShortcut(pattern);
        };
        /**
         * Searches for the longest substring of the pattern that
         * does not contain any special characters: *,^,|.
         *
         * @param pattern - network rule's pattern.
         * @returns the shortcut or the empty string
         */
        SimpleRegex.extractBasicShortcut = function (pattern) {
            var longest = '';
            var parts = pattern.split(this.rePatternSpecialCharacters);
            for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                if (part.length > longest.length) {
                    longest = part;
                }
            }
            return (longest || '').toLowerCase();
        };
        /**
         * Searches for a shortcut inside of a regexp pattern.
         * Shortcut in this case is a longest string with no REGEX special characters.
         * Also, we discard complicated regexps right away.
         *
         * @param pattern - network rule's pattern (regexp).
         * @returns the shortcut or the empty string
         */
        SimpleRegex.extractRegexpShortcut = function (pattern) {
            var reText = pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
            if (reText.length === 0) {
                // The rule is too short, doing nothing
                return '';
            }
            if (reText.indexOf('(?') >= 0 || reText.indexOf('(!?') >= 0) {
                // Do not mess with complex expressions which use lookahead
                return '';
            }
            var specialCharacter = '$$$';
            // Prepend specialCharacter for the following replace calls to work properly
            reText = specialCharacter + reText;
            // Strip all types of brackets
            reText = reText.replace(/[^\\]\(.*[^\\]\)/, specialCharacter);
            reText = reText.replace(/[^\\]\[.*[^\\]\]/, specialCharacter);
            reText = reText.replace(/[^\\]\{.*[^\\]\}/, specialCharacter);
            // Strip some special characters
            reText = reText.replace(/[^\\]\\[a-zA-Z]/, specialCharacter);
            // Replace \. with .
            reText = reText.replace(/\\\./g, '.');
            // Split by special characters
            // `.` is one of the special characters so our `specialCharacter`
            // will be removed from the resulting array
            var parts = reText.split(/[\\^$*+?()|[\]{}]/);
            var longest = '';
            for (var i = 0; i < parts.length; i += 1) {
                var part = parts[i];
                if (part.length > longest.length) {
                    longest = part;
                }
            }
            return longest.toLowerCase();
        };
        /**
         * patternToRegexp is a helper method for creating regular expressions from the simple
         * wildcard-based syntax which is used in basic filters:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
         *
         * @param pattern - basic rule pattern
         * @returns regular expression
         */
        SimpleRegex.patternToRegexp = function (pattern) {
            if (pattern === this.MASK_START_URL
                || pattern === this.MASK_PIPE
                || pattern === this.MASK_ANY_CHARACTER
                || pattern === '') {
                return this.REGEX_ANY_CHARACTER;
            }
            if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
                // This is a regex rule, just remove the regex markers
                return pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
            }
            // Escape special characters except of * | ^
            var regex = pattern.replace(reSpecialCharacters, '\\$&');
            // Now escape "|" characters but avoid escaping them in the special places
            if (regex.startsWith(this.MASK_START_URL)) {
                regex = regex.substring(0, this.MASK_START_URL.length)
                    + replaceAll(regex.substring(this.MASK_START_URL.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                    + regex.substring(regex.length - this.MASK_PIPE.length);
            }
            else {
                regex = regex.substring(0, this.MASK_PIPE.length)
                    + replaceAll(regex.substring(this.MASK_PIPE.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                    + regex.substring(regex.length - this.MASK_PIPE.length);
            }
            // Replace special URL masks
            regex = replaceAll(regex, this.MASK_ANY_CHARACTER, this.REGEX_ANY_CHARACTER);
            regex = replaceAll(regex, this.MASK_SEPARATOR, this.REGEX_SEPARATOR);
            // Replace start URL and pipes
            if (regex.startsWith(this.MASK_START_URL)) {
                regex = this.REGEX_START_URL + regex.substring(this.MASK_START_URL.length);
            }
            else if (regex.startsWith(this.MASK_PIPE)) {
                regex = this.REGEX_START_STRING + regex.substring(this.MASK_PIPE.length);
            }
            if (regex.endsWith(this.MASK_PIPE)) {
                regex = regex.substring(0, regex.length - this.MASK_PIPE.length) + this.REGEX_END_STRING;
            }
            return regex;
        };
        /**
         * Creates RegExp object from string in '/reg_exp/gi' format
         *
         * @param str
         */
        SimpleRegex.patternFromString = function (str) {
            var parts = splitByDelimiterWithEscapeCharacter(str, '/', '\\', true);
            var modifiers = (parts[1] || '');
            if (modifiers.indexOf('g') < 0) {
                modifiers += 'g';
            }
            return new RegExp(parts[0], modifiers);
        };
        /**
         * Escapes characters with special meaning inside a regular expression.
         *
         * @param str
         * @param searchPattern - Pattern for detecting special characters. Optional.
         */
        SimpleRegex.escapeRegexSpecials = function (str, searchPattern) {
            if (searchPattern === void 0) { searchPattern = reSpecialCharactersFull; }
            return str.replace(searchPattern, '\\$&');
        };
        /**
         * Unescapes characters with special meaning inside a regular expression.
         *
         * @param str
         * @param searchPattern - Pattern for detecting special characters. Optional.
         */
        SimpleRegex.unescapeRegexSpecials = function (str, searchPattern) {
            if (searchPattern === void 0) { searchPattern = reEscapedSpecialCharactersFull; }
            return str.replace(searchPattern, function (match) { return match.substring(1); });
        };
        /**
         * Check if pattern is Regex
         */
        SimpleRegex.isRegexPattern = function (str) {
            return str.startsWith('/') && str.endsWith('/');
        };
        /**
         * Matching the beginning of an address. With this character you don't
         * have to specify a particular protocol and subdomain in address mask.
         * It means, || stands for http://*., https://*., ws://*., wss://*. at once.
         */
        SimpleRegex.MASK_START_URL = '||';
        /**
         * REGEX_START_URL corresponds to MASK_START_URL
         */
        SimpleRegex.REGEX_START_URL = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
        /**
         * A pointer to the beginning or the end of address. The value depends on the
         * character placement in the mask. For example, a rule swf| corresponds
         * to http://example.com/annoyingflash.swf , but not to http://example.com/swf/index.html.
         * |http://example.org corresponds to http://example.org,
         * but not to http://domain.com?url=http://example.org.
         */
        SimpleRegex.MASK_PIPE = '|';
        /**
         * REGEX_END_STRING corresponds to MASK_PIPE if it is in the end of a pattern.
         */
        SimpleRegex.REGEX_END_STRING = '$';
        /**
         * REGEX_START_STRING corresponds to MASK_PIPE if it is in the beginning of a pattern.
         */
        SimpleRegex.REGEX_START_STRING = '^';
        /**
         * Separator character mark. Separator character is any character,
         * but a letter, a digit, or one of the following: _ - .
         */
        SimpleRegex.MASK_SEPARATOR = '^';
        /**
         * REGEX_SEPARATOR corresponds to MASK_SEPARATOR
         */
        SimpleRegex.REGEX_SEPARATOR = '([^ a-zA-Z0-9.%_-]|$)';
        /**
         * This is a wildcard character. It is used to represent "any set of characters".
         * This can also be an empty string or a string of any length.
         */
        SimpleRegex.MASK_ANY_CHARACTER = '*';
        /**
         * Path separator
         */
        SimpleRegex.MASK_BACKSLASH = '/';
        /**
         * REGEX_ANY_CHARACTER corresponds to MASK_ANY_CHARACTER.
         */
        SimpleRegex.REGEX_ANY_CHARACTER = '.*';
        /**
         * Enclose regex in two backslashes to mark a regex rule:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regular-expressions-support
         */
        SimpleRegex.MASK_REGEX_RULE = '/';
        /**
         *  Regex for matching special characters in modifier regex pattern
         */
        SimpleRegex.reModifierPatternSpecialCharacters = /[[\],\\]/g;
        /**
          *  Regex for matching escaped special characters in modifier regex pattern
          */
        SimpleRegex.reModifierPatternEscapedSpecialCharacters = /\\[[\],\\]/g;
        /**
         * If string starts with exclamation mark "!" we consider it as comment
         */
        SimpleRegex.MASK_COMMENT = '!';
        /**
         * Min length of rule shortcut
         * This value has been picked as a result of performance experiments
         */
        SimpleRegex.MIN_SHORTCUT_LENGTH = 3;
        /**
         * Min length of generic rule shortcut
         */
        SimpleRegex.MIN_GENERIC_RULE_LENGTH = 4;
        /** Regex with basic matching pattern special characters */
        SimpleRegex.rePatternSpecialCharacters = new RegExp('[*^|]');
        return SimpleRegex;
    }());

    function shareSameDomainSuffix(hostname, vhost) {
        if (hostname.endsWith(vhost)) {
            return (hostname.length === vhost.length ||
                hostname[hostname.length - vhost.length - 1] === '.');
        }
        return false;
    }
    function extractDomainWithSuffix(hostname, publicSuffix) {
        const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
        const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
        if (lastDotBeforeSuffixIndex === -1) {
            return hostname;
        }
        return hostname.slice(lastDotBeforeSuffixIndex + 1);
    }
    function getDomain(suffix, hostname, options) {
        if (options.validHosts !== null) {
            const validHosts = options.validHosts;
            for (let i = 0; i < validHosts.length; i += 1) {
                const vhost = validHosts[i];
                if ( shareSameDomainSuffix(hostname, vhost) === true) {
                    return vhost;
                }
            }
        }
        if (suffix.length === hostname.length) {
            return null;
        }
        return  extractDomainWithSuffix(hostname, suffix);
    }

    function getDomainWithoutSuffix(domain, suffix) {
        return domain.slice(0, -suffix.length - 1);
    }

    function extractHostname(url, urlIsValidHostname) {
        let start = 0;
        let end = url.length;
        let hasUpper = false;
        if (urlIsValidHostname === false) {
            if (url.startsWith('data:') === true) {
                return null;
            }
            while (start < url.length && url.charCodeAt(start) <= 32) {
                start += 1;
            }
            while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
                end -= 1;
            }
            if (url.charCodeAt(start) === 47  &&
                url.charCodeAt(start + 1) === 47 ) {
                start += 2;
            }
            else {
                const indexOfProtocol = url.indexOf(':/', start);
                if (indexOfProtocol !== -1) {
                    const protocolSize = indexOfProtocol - start;
                    const c0 = url.charCodeAt(start);
                    const c1 = url.charCodeAt(start + 1);
                    const c2 = url.charCodeAt(start + 2);
                    const c3 = url.charCodeAt(start + 3);
                    const c4 = url.charCodeAt(start + 4);
                    if (protocolSize === 5 &&
                        c0 === 104  &&
                        c1 === 116  &&
                        c2 === 116  &&
                        c3 === 112  &&
                        c4 === 115 ) ;
                    else if (protocolSize === 4 &&
                        c0 === 104  &&
                        c1 === 116  &&
                        c2 === 116  &&
                        c3 === 112 ) ;
                    else if (protocolSize === 3 &&
                        c0 === 119  &&
                        c1 === 115  &&
                        c2 === 115 ) ;
                    else if (protocolSize === 2 &&
                        c0 === 119  &&
                        c1 === 115 ) ;
                    else {
                        for (let i = start; i < indexOfProtocol; i += 1) {
                            const lowerCaseCode = url.charCodeAt(i) | 32;
                            if (((lowerCaseCode >= 97 && lowerCaseCode <= 122) ||
                                (lowerCaseCode >= 48 && lowerCaseCode <= 57) ||
                                lowerCaseCode === 46 ||
                                lowerCaseCode === 45 ||
                                lowerCaseCode === 43) === false
                            ) {
                                return null;
                            }
                        }
                    }
                    start = indexOfProtocol + 2;
                    while (url.charCodeAt(start) === 47 ) {
                        start += 1;
                    }
                }
            }
            let indexOfIdentifier = -1;
            let indexOfClosingBracket = -1;
            let indexOfPort = -1;
            for (let i = start; i < end; i += 1) {
                const code = url.charCodeAt(i);
                if (code === 35 ||
                    code === 47 ||
                    code === 63
                ) {
                    end = i;
                    break;
                }
                else if (code === 64) {
                    indexOfIdentifier = i;
                }
                else if (code === 93) {
                    indexOfClosingBracket = i;
                }
                else if (code === 58) {
                    indexOfPort = i;
                }
                else if (code >= 65 && code <= 90) {
                    hasUpper = true;
                }
            }
            if (indexOfIdentifier !== -1 &&
                indexOfIdentifier > start &&
                indexOfIdentifier < end) {
                start = indexOfIdentifier + 1;
            }
            if (url.charCodeAt(start) === 91 ) {
                if (indexOfClosingBracket !== -1) {
                    return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
                }
                return null;
            }
            else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
                end = indexOfPort;
            }
        }
        while (end > start + 1 && url.charCodeAt(end - 1) === 46 ) {
            end -= 1;
        }
        const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
        if (hasUpper) {
            return hostname.toLowerCase();
        }
        return hostname;
    }

    function isProbablyIpv4(hostname) {
        if (hostname.length < 7) {
            return false;
        }
        if (hostname.length > 15) {
            return false;
        }
        let numberOfDots = 0;
        for (let i = 0; i < hostname.length; i += 1) {
            const code = hostname.charCodeAt(i);
            if (code === 46 ) {
                numberOfDots += 1;
            }
            else if (code < 48  || code > 57 ) {
                return false;
            }
        }
        return (numberOfDots === 3 &&
            hostname.charCodeAt(0) !== 46  &&
            hostname.charCodeAt(hostname.length - 1) !== 46 );
    }
    function isProbablyIpv6(hostname) {
        if (hostname.length < 3) {
            return false;
        }
        let start = hostname[0] === '[' ? 1 : 0;
        let end = hostname.length;
        if (hostname[end - 1] === ']') {
            end -= 1;
        }
        if (end - start > 39) {
            return false;
        }
        let hasColon = false;
        for (; start < end; start += 1) {
            const code = hostname.charCodeAt(start);
            if (code === 58 ) {
                hasColon = true;
            }
            else if (((code >= 48 && code <= 57) ||
                (code >= 97 && code <= 102) ||
                (code >= 65 && code <= 90)) ===
                false) {
                return false;
            }
        }
        return hasColon;
    }
    function isIp$1(hostname) {
        return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
    }

    function isValidAscii(code) {
        return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);
    }
    function isValidHostname (hostname) {
        if (hostname.length > 255) {
            return false;
        }
        if (hostname.length === 0) {
            return false;
        }
        if ( isValidAscii(hostname.charCodeAt(0)) === false) {
            return false;
        }
        let lastDotIndex = -1;
        let lastCharCode = -1;
        const len = hostname.length;
        for (let i = 0; i < len; i += 1) {
            const code = hostname.charCodeAt(i);
            if (code === 46 ) {
                if (
                i - lastDotIndex > 64 ||
                    lastCharCode === 46 ||
                    lastCharCode === 45 ||
                    lastCharCode === 95) {
                    return false;
                }
                lastDotIndex = i;
            }
            else if (( isValidAscii(code) || code === 45 || code === 95) ===
                false) {
                return false;
            }
            lastCharCode = code;
        }
        return (
        len - lastDotIndex - 1 <= 63 &&
            lastCharCode !== 45);
    }

    function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
        return {
            allowIcannDomains,
            allowPrivateDomains,
            detectIp,
            extractHostname,
            mixedInputs,
            validHosts,
            validateHostname,
        };
    }
    const DEFAULT_OPTIONS =  setDefaultsImpl({});
    function setDefaults(options) {
        if (options === undefined) {
            return DEFAULT_OPTIONS;
        }
        return  setDefaultsImpl(options);
    }

    function getSubdomain(hostname, domain) {
        if (domain.length === hostname.length) {
            return '';
        }
        return hostname.slice(0, -domain.length - 1);
    }

    function getEmptyResult() {
        return {
            domain: null,
            domainWithoutSuffix: null,
            hostname: null,
            isIcann: null,
            isIp: null,
            isPrivate: null,
            publicSuffix: null,
            subdomain: null,
        };
    }
    function resetResult(result) {
        result.domain = null;
        result.domainWithoutSuffix = null;
        result.hostname = null;
        result.isIcann = null;
        result.isIp = null;
        result.isPrivate = null;
        result.publicSuffix = null;
        result.subdomain = null;
    }
    function parseImpl(url, step, suffixLookup, partialOptions, result) {
        const options =  setDefaults(partialOptions);
        if (typeof url !== 'string') {
            return result;
        }
        if (options.extractHostname === false) {
            result.hostname = url;
        }
        else if (options.mixedInputs === true) {
            result.hostname = extractHostname(url, isValidHostname(url));
        }
        else {
            result.hostname = extractHostname(url, false);
        }
        if (step === 0  || result.hostname === null) {
            return result;
        }
        if (options.detectIp === true) {
            result.isIp = isIp$1(result.hostname);
            if (result.isIp === true) {
                return result;
            }
        }
        if (options.validateHostname === true &&
            options.extractHostname === true &&
            isValidHostname(result.hostname) === false) {
            result.hostname = null;
            return result;
        }
        suffixLookup(result.hostname, options, result);
        if (step === 2  || result.publicSuffix === null) {
            return result;
        }
        result.domain = getDomain(result.publicSuffix, result.hostname, options);
        if (step === 3  || result.domain === null) {
            return result;
        }
        result.subdomain = getSubdomain(result.hostname, result.domain);
        if (step === 4 ) {
            return result;
        }
        result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
        return result;
    }

    function fastPathLookup (hostname, options, out) {
        if (options.allowPrivateDomains === false && hostname.length > 3) {
            const last = hostname.length - 1;
            const c3 = hostname.charCodeAt(last);
            const c2 = hostname.charCodeAt(last - 1);
            const c1 = hostname.charCodeAt(last - 2);
            const c0 = hostname.charCodeAt(last - 3);
            if (c3 === 109  &&
                c2 === 111  &&
                c1 === 99  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'com';
                return true;
            }
            else if (c3 === 103  &&
                c2 === 114  &&
                c1 === 111  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'org';
                return true;
            }
            else if (c3 === 117  &&
                c2 === 100  &&
                c1 === 101  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'edu';
                return true;
            }
            else if (c3 === 118  &&
                c2 === 111  &&
                c1 === 103  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'gov';
                return true;
            }
            else if (c3 === 116  &&
                c2 === 101  &&
                c1 === 110  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'net';
                return true;
            }
            else if (c3 === 101  &&
                c2 === 100  &&
                c1 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'de';
                return true;
            }
        }
        return false;
    }

    const exceptions = (function () {
        const _0 = { "$": 1, "succ": {} }, _1 = { "$": 0, "succ": { "city": _0 } };
        const exceptions = { "$": 0, "succ": { "ck": { "$": 0, "succ": { "www": _0 } }, "jp": { "$": 0, "succ": { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 } } } };
        return exceptions;
    })();
    const rules = (function () {
        const _2 = { "$": 1, "succ": {} }, _3 = { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2 } }, _4 = { "$": 2, "succ": {} }, _5 = { "$": 1, "succ": { "blogspot": _4 } }, _6 = { "$": 1, "succ": { "gov": _2 } }, _7 = { "$": 0, "succ": { "*": _4 } }, _8 = { "$": 0, "succ": { "*": _2 } }, _9 = { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2 } }, _10 = { "$": 1, "succ": { "co": _4 } }, _11 = { "$": 1, "succ": { "ng": _4 } }, _12 = { "$": 0, "succ": { "s3": _4 } }, _13 = { "$": 0, "succ": { "dualstack": _12 } }, _14 = { "$": 0, "succ": { "s3": _4, "dualstack": _12, "s3-website": _4 } }, _15 = { "$": 0, "succ": { "apps": _4 } }, _16 = { "$": 0, "succ": { "app": _4 } }, _17 = { "$": 0, "succ": { "j": _4 } }, _18 = { "$": 0, "succ": { "user": _4 } }, _19 = { "$": 1, "succ": { "ybo": _4 } }, _20 = { "$": 1, "succ": { "gov": _2, "blogspot": _4, "nym": _4 } }, _21 = { "$": 0, "succ": { "cust": _4 } }, _22 = { "$": 1, "succ": { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 } }, _23 = { "$": 1, "succ": { "blogspot": _4, "nym": _4 } }, _24 = { "$": 1, "succ": { "for": _4 } }, _25 = { "$": 1, "succ": { "barsy": _4 } }, _26 = { "$": 0, "succ": { "forgot": _4 } }, _27 = { "$": 0, "succ": { "jelastic": _4 } }, _28 = { "$": 1, "succ": { "gs": _2 } }, _29 = { "$": 0, "succ": { "nes": _2 } }, _30 = { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2 } }, _31 = { "$": 1, "succ": { "cc": _2, "lib": _2 } };
        const rules = { "$": 0, "succ": { "ac": _3, "ad": { "$": 1, "succ": { "nom": _2 } }, "ae": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _4, "nom": _4 } }, "aero": { "$": 1, "succ": { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 } }, "af": { "$": 1, "succ": { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2, "nom": _4 } }, "ag": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 } }, "ai": { "$": 1, "succ": { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _4, "nom": _4 } }, "al": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _4, "nom": _4 } }, "am": { "$": 1, "succ": { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "blogspot": _4, "neko": _4, "nyaa": _4 } }, "ao": { "$": 1, "succ": { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 } }, "aq": _2, "ar": { "$": 1, "succ": { "com": _5, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "net": _2, "org": _2, "tur": _2 } }, "arpa": { "$": 1, "succ": { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 } }, "as": _6, "asia": { "$": 1, "succ": { "cloudns": _4 } }, "at": { "$": 1, "succ": { "ac": { "$": 1, "succ": { "sth": _2 } }, "co": _5, "gv": _2, "or": _2, "funkfeuer": { "$": 0, "succ": { "wien": _4 } }, "futurecms": { "$": 0, "succ": { "*": _4, "ex": _7, "in": _7 } }, "futurehosting": _4, "futuremailing": _4, "ortsinfo": { "$": 0, "succ": { "ex": _7, "kunden": _7 } }, "biz": _4, "info": _4, "priv": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 } }, "au": { "$": 1, "succ": { "com": _5, "net": _2, "org": _2, "edu": { "$": 1, "succ": { "act": _2, "catholic": _2, "nsw": { "$": 1, "succ": { "schools": _2 } }, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "gov": { "$": 1, "succ": { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "aw": { "$": 1, "succ": { "com": _2 } }, "ax": { "$": 1, "succ": { "be": _4, "cat": _4, "es": _4, "eu": _4, "gg": _4, "mc": _4, "us": _4, "xy": _4 } }, "az": { "$": 1, "succ": { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 } }, "ba": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _4 } }, "bb": { "$": 1, "succ": { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 } }, "bd": _8, "be": { "$": 1, "succ": { "ac": _2, "webhosting": _4, "blogspot": _4, "transurl": _7 } }, "bf": _6, "bg": { "$": 1, "succ": { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _4, "barsy": _4 } }, "bh": _9, "bi": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 } }, "biz": { "$": 1, "succ": { "cloudns": _4, "dyndns": _4, "for-better": _4, "for-more": _4, "for-some": _4, "for-the": _4, "selfip": _4, "webhop": _4, "bpl": _4, "orx": _4, "mmafan": _4, "myftp": _4, "no-ip": _4, "dscloud": _4 } }, "bj": { "$": 1, "succ": { "asso": _2, "barreau": _2, "gouv": _2, "blogspot": _4 } }, "bm": _9, "bn": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _4 } }, "bo": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 } }, "br": { "$": 1, "succ": { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": _5, "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": { "$": 1, "succ": { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 } }, "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": { "$": 1, "succ": { "ac": _4, "al": _4, "am": _4, "ap": _4, "ba": _4, "ce": _4, "df": _4, "es": _4, "go": _4, "ma": _4, "mg": _4, "ms": _4, "mt": _4, "pa": _4, "pb": _4, "pe": _4, "pi": _4, "pr": _4, "rj": _4, "rn": _4, "ro": _4, "rr": _4, "rs": _4, "sc": _4, "se": _4, "sp": _4, "to": _4 } }, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 } }, "bs": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _4 } }, "bt": _9, "bv": _2, "bw": { "$": 1, "succ": { "co": _2, "org": _2 } }, "by": { "$": 1, "succ": { "gov": _2, "mil": _2, "com": _5, "of": _2, "nym": _4 } }, "bz": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _4, "nom": _4, "nym": _4 } }, "ca": { "$": 1, "succ": { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _4, "awdev": _7, "co": _4, "blogspot": _4, "no-ip": _4 } }, "cat": _2, "cc": { "$": 1, "succ": { "cloudns": _4, "ftpaccess": _4, "game-server": _4, "myphotos": _4, "scrapping": _4, "twmail": _4, "csx": _4, "fantasyleague": _4 } }, "cd": _6, "cf": _5, "cg": _2, "ch": { "$": 1, "succ": { "square7": _4, "blogspot": _4, "linkyard-cloud": _4, "dnsking": _4, "gotdns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 } }, "ci": { "$": 1, "succ": { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aéroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _4, "nl": _4 } }, "ck": _8, "cl": { "$": 1, "succ": { "aprendemas": _2, "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _4, "nom": _4 } }, "cm": { "$": 1, "succ": { "co": _2, "com": _2, "gov": _2, "net": _2 } }, "cn": { "$": 1, "succ": { "ac": _2, "com": { "$": 1, "succ": { "amazonaws": { "$": 0, "succ": { "compute": _7, "eb": { "$": 0, "succ": { "cn-north-1": _4, "cn-northwest-1": _4 } }, "elb": _7, "cn-north-1": _12 } } } }, "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "公司": _2, "xn--io0a7i": _2, "网络": _2, "xn--od0alg": _2, "網絡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "instantcloud": _4 } }, "co": { "$": 1, "succ": { "arts": _2, "com": _5, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _4, "crd": _4, "otap": _7, "leadpages": _4, "lpages": _4, "mypi": _4, "n4t": _4, "nodum": _4, "repl": _4 } }, "com": { "$": 1, "succ": { "adobeaemcloud": { "$": 2, "succ": { "dev": _7 } }, "kasserver": _4, "amazonaws": { "$": 0, "succ": { "compute": _7, "compute-1": _7, "us-east-1": { "$": 2, "succ": { "dualstack": _12 } }, "elb": _7, "s3": _4, "s3-ap-northeast-1": _4, "s3-ap-northeast-2": _4, "s3-ap-south-1": _4, "s3-ap-southeast-1": _4, "s3-ap-southeast-2": _4, "s3-ca-central-1": _4, "s3-eu-central-1": _4, "s3-eu-west-1": _4, "s3-eu-west-2": _4, "s3-eu-west-3": _4, "s3-external-1": _4, "s3-fips-us-gov-west-1": _4, "s3-sa-east-1": _4, "s3-us-gov-west-1": _4, "s3-us-east-2": _4, "s3-us-west-1": _4, "s3-us-west-2": _4, "ap-northeast-2": _14, "ap-south-1": _14, "ca-central-1": _14, "eu-central-1": _14, "eu-west-2": _14, "eu-west-3": _14, "us-east-2": _14, "ap-northeast-1": _13, "ap-southeast-1": _13, "ap-southeast-2": _13, "eu-west-1": _13, "sa-east-1": _13, "s3-website-us-east-1": _4, "s3-website-us-west-1": _4, "s3-website-us-west-2": _4, "s3-website-ap-northeast-1": _4, "s3-website-ap-southeast-1": _4, "s3-website-ap-southeast-2": _4, "s3-website-eu-west-1": _4, "s3-website-sa-east-1": _4 } }, "elasticbeanstalk": { "$": 2, "succ": { "ap-northeast-1": _4, "ap-northeast-2": _4, "ap-northeast-3": _4, "ap-south-1": _4, "ap-southeast-1": _4, "ap-southeast-2": _4, "ca-central-1": _4, "eu-central-1": _4, "eu-west-1": _4, "eu-west-2": _4, "eu-west-3": _4, "sa-east-1": _4, "us-east-1": _4, "us-east-2": _4, "us-gov-west-1": _4, "us-west-1": _4, "us-west-2": _4 } }, "on-aptible": _4, "myasustor": _4, "balena-devices": _4, "betainabox": _4, "bplaced": _4, "ar": _4, "br": _4, "cn": _4, "de": _4, "eu": _4, "gb": _4, "hu": _4, "jpn": _4, "kr": _4, "mex": _4, "no": _4, "qc": _4, "ru": _4, "sa": _4, "uk": _4, "us": _4, "uy": _4, "za": _4, "africa": _4, "gr": _4, "co": _4, "xenapponazure": _4, "jdevcloud": _4, "wpdevcloud": _4, "cloudcontrolled": _4, "cloudcontrolapp": _4, "trycloudflare": _4, "customer-oci": { "$": 0, "succ": { "*": _4, "oci": _7, "ocp": _7, "ocs": _7 } }, "dattolocal": _4, "dattorelay": _4, "dattoweb": _4, "mydatto": _4, "builtwithdark": _4, "drayddns": _4, "dreamhosters": _4, "mydrobo": _4, "dyndns-at-home": _4, "dyndns-at-work": _4, "dyndns-blog": _4, "dyndns-free": _4, "dyndns-home": _4, "dyndns-ip": _4, "dyndns-mail": _4, "dyndns-office": _4, "dyndns-pics": _4, "dyndns-remote": _4, "dyndns-server": _4, "dyndns-web": _4, "dyndns-wiki": _4, "dyndns-work": _4, "blogdns": _4, "cechire": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dyn-o-saur": _4, "dynalias": _4, "est-a-la-maison": _4, "est-a-la-masion": _4, "est-le-patron": _4, "est-mon-blogueur": _4, "from-ak": _4, "from-al": _4, "from-ar": _4, "from-ca": _4, "from-ct": _4, "from-dc": _4, "from-de": _4, "from-fl": _4, "from-ga": _4, "from-hi": _4, "from-ia": _4, "from-id": _4, "from-il": _4, "from-in": _4, "from-ks": _4, "from-ky": _4, "from-ma": _4, "from-md": _4, "from-mi": _4, "from-mn": _4, "from-mo": _4, "from-ms": _4, "from-mt": _4, "from-nc": _4, "from-nd": _4, "from-ne": _4, "from-nh": _4, "from-nj": _4, "from-nm": _4, "from-nv": _4, "from-oh": _4, "from-ok": _4, "from-or": _4, "from-pa": _4, "from-pr": _4, "from-ri": _4, "from-sc": _4, "from-sd": _4, "from-tn": _4, "from-tx": _4, "from-ut": _4, "from-va": _4, "from-vt": _4, "from-wa": _4, "from-wi": _4, "from-wv": _4, "from-wy": _4, "getmyip": _4, "gotdns": _4, "hobby-site": _4, "homelinux": _4, "homeunix": _4, "iamallama": _4, "is-a-anarchist": _4, "is-a-blogger": _4, "is-a-bookkeeper": _4, "is-a-bulls-fan": _4, "is-a-caterer": _4, "is-a-chef": _4, "is-a-conservative": _4, "is-a-cpa": _4, "is-a-cubicle-slave": _4, "is-a-democrat": _4, "is-a-designer": _4, "is-a-doctor": _4, "is-a-financialadvisor": _4, "is-a-geek": _4, "is-a-green": _4, "is-a-guru": _4, "is-a-hard-worker": _4, "is-a-hunter": _4, "is-a-landscaper": _4, "is-a-lawyer": _4, "is-a-liberal": _4, "is-a-libertarian": _4, "is-a-llama": _4, "is-a-musician": _4, "is-a-nascarfan": _4, "is-a-nurse": _4, "is-a-painter": _4, "is-a-personaltrainer": _4, "is-a-photographer": _4, "is-a-player": _4, "is-a-republican": _4, "is-a-rockstar": _4, "is-a-socialist": _4, "is-a-student": _4, "is-a-teacher": _4, "is-a-techie": _4, "is-a-therapist": _4, "is-an-accountant": _4, "is-an-actor": _4, "is-an-actress": _4, "is-an-anarchist": _4, "is-an-artist": _4, "is-an-engineer": _4, "is-an-entertainer": _4, "is-certified": _4, "is-gone": _4, "is-into-anime": _4, "is-into-cars": _4, "is-into-cartoons": _4, "is-into-games": _4, "is-leet": _4, "is-not-certified": _4, "is-slick": _4, "is-uberleet": _4, "is-with-theband": _4, "isa-geek": _4, "isa-hockeynut": _4, "issmarterthanyou": _4, "likes-pie": _4, "likescandy": _4, "neat-url": _4, "saves-the-whales": _4, "selfip": _4, "sells-for-less": _4, "sells-for-u": _4, "servebbs": _4, "simple-url": _4, "space-to-rent": _4, "teaches-yoga": _4, "writesthisblog": _4, "ddnsfree": _4, "ddnsgeek": _4, "giize": _4, "gleeze": _4, "kozow": _4, "loseyourip": _4, "ooguy": _4, "theworkpc": _4, "mytuleap": _4, "evennode": { "$": 0, "succ": { "eu-1": _4, "eu-2": _4, "eu-3": _4, "eu-4": _4, "us-1": _4, "us-2": _4, "us-3": _4, "us-4": _4 } }, "onfabrica": _4, "fbsbx": _15, "fastly-terrarium": _4, "fastvps-server": _4, "mydobiss": _4, "firebaseapp": _4, "freebox-os": _4, "freeboxos": _4, "gentapps": _4, "gentlentapis": _4, "githubusercontent": _4, "0emm": _7, "appspot": { "$": 2, "succ": { "r": _7 } }, "blogspot": _4, "codespot": _4, "googleapis": _4, "googlecode": _4, "pagespeedmobilizer": _4, "publishproxy": _4, "withgoogle": _4, "withyoutube": _4, "awsmppl": _4, "herokuapp": _4, "herokussl": _4, "myravendb": _4, "pixolino": _4, "dopaas": _4, "hidora": _4, "ik-server": { "$": 0, "succ": { "jcloud": _4 } }, "jelastic": { "$": 0, "succ": { "demo": _4 } }, "joyent": { "$": 0, "succ": { "cns": _7 } }, "lpusercontent": _4, "lmpm": _16, "linode": { "$": 0, "succ": { "members": _4, "nodebalancer": _7 } }, "linodeobjects": _7, "barsycenter": _4, "barsyonline": _4, "miniserver": _4, "meteorapp": { "$": 2, "succ": { "eu": _4 } }, "4u": _4, "nfshost": _4, "001www": _4, "ddnslive": _4, "myiphost": _4, "blogsyte": _4, "ciscofreak": _4, "damnserver": _4, "ditchyourip": _4, "dnsiskinky": _4, "dynns": _4, "geekgalaxy": _4, "health-carereform": _4, "homesecuritymac": _4, "homesecuritypc": _4, "myactivedirectory": _4, "mysecuritycamera": _4, "net-freaks": _4, "onthewifi": _4, "point2this": _4, "quicksytes": _4, "securitytactics": _4, "serveexchange": _4, "servehumour": _4, "servep2p": _4, "servesarcasm": _4, "stufftoread": _4, "unusualperson": _4, "workisboring": _4, "3utilities": _4, "ddnsking": _4, "myvnc": _4, "servebeer": _4, "servecounterstrike": _4, "serveftp": _4, "servegame": _4, "servehalflife": _4, "servehttp": _4, "serveirc": _4, "servemp3": _4, "servepics": _4, "servequake": _4, "observableusercontent": { "$": 0, "succ": { "static": _4 } }, "operaunite": _4, "skygearapp": _4, "outsystemscloud": _4, "ownprovider": _4, "pgfog": _4, "pagefrontapp": _4, "pagexl": _4, "gotpantheon": _4, "platter-app": _4, "pleskns": _4, "prgmr": { "$": 0, "succ": { "xen": _4 } }, "qualifioapp": _4, "qbuser": _4, "qa2": _4, "dev-myqnapcloud": _4, "alpha-myqnapcloud": _4, "myqnapcloud": _4, "quipelements": _7, "rackmaze": _4, "rhcloud": _4, "render": _16, "onrender": _4, "logoip": _4, "scrysec": _4, "firewall-gateway": _4, "myshopblocks": _4, "shopitsite": _4, "1kapp": _4, "appchizi": _4, "applinzi": _4, "sinaapp": _4, "vipsinaapp": _4, "bounty-full": { "$": 2, "succ": { "alpha": _4, "beta": _4 } }, "stackhero-network": _4, "playstation-cloud": _4, "stdlib": { "$": 0, "succ": { "api": _4 } }, "temp-dns": _4, "dsmynas": _4, "familyds": _4, "thingdustdata": _4, "bloxcms": _4, "townnews-staging": _4, "hk": _4, "wafflecell": _4, "remotewd": _4, "wiardweb": { "$": 0, "succ": { "pages": _4 } }, "xnbay": { "$": 2, "succ": { "u2": _4, "u2-local": _4 } }, "yolasite": _4, "wpenginepowered": _4, "impertrixcdn": _4, "impertrix": _4 } }, "coop": _2, "cr": { "$": 1, "succ": { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 } }, "cu": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 } }, "cv": _5, "cw": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2 } }, "cx": { "$": 1, "succ": { "gov": _2, "ath": _4, "info": _4 } }, "cy": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": { "$": 1, "succ": { "blogspot": _4, "scaleforce": _17 } }, "ekloges": _2, "gov": _2, "ltd": _2, "name": _2, "net": _2, "org": _2, "parliament": _2, "press": _2, "pro": _2, "tm": _2 } }, "cz": { "$": 1, "succ": { "co": _4, "realm": _4, "e4": _4, "blogspot": _4, "metacentrum": { "$": 0, "succ": { "cloud": _4, "custom": _4 } }, "muni": { "$": 0, "succ": { "cloud": { "$": 0, "succ": { "flt": _4, "usr": _4 } } } } } }, "de": { "$": 1, "succ": { "bplaced": _4, "square7": _4, "com": _4, "cosidns": { "$": 0, "succ": { "dyn": _4 } }, "dynamisches-dns": _4, "dnsupdater": _4, "internet-dns": _4, "l-o-g-i-n": _4, "dnshome": _4, "fuettertdasnetz": _4, "isteingeek": _4, "istmein": _4, "lebtimnetz": _4, "leitungsen": _4, "traeumtgerade": _4, "ddnss": { "$": 2, "succ": { "dyn": _4, "dyndns": _4 } }, "dyndns1": _4, "dyn-ip24": _4, "home-webserver": { "$": 2, "succ": { "dyn": _4 } }, "myhome-server": _4, "goip": _4, "blogspot": _4, "dyn-berlin": _4, "in-berlin": _4, "in-brb": _4, "in-butter": _4, "in-dsl": _4, "in-vpn": _4, "mein-iserv": _4, "schulserver": _4, "test-iserv": _4, "keymachine": _4, "git-repos": _4, "lcube-server": _4, "svn-repos": _4, "barsy": _4, "logoip": _4, "firewall-gateway": _4, "my-gateway": _4, "my-router": _4, "spdns": _4, "speedpartner": { "$": 0, "succ": { "customer": _4 } }, "taifun-dns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4, "dd-dns": _4, "dray-dns": _4, "draydns": _4, "dyn-vpn": _4, "dynvpn": _4, "mein-vigor": _4, "my-vigor": _4, "my-wan": _4, "syno-ds": _4, "synology-diskstation": _4, "synology-ds": _4, "uberspace": _7, "virtualuser": _4, "virtual-user": _4, "community-pro": _4, "diskussionsbereich": _4 } }, "dj": _2, "dk": { "$": 1, "succ": { "biz": _4, "co": _4, "firm": _4, "reg": _4, "store": _4, "blogspot": _4 } }, "dm": _9, "do": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 } }, "dz": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "gov": _2, "edu": _2, "asso": _2, "pol": _2, "art": _2 } }, "ec": { "$": 1, "succ": { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "nym": _4 } }, "edu": { "$": 1, "succ": { "rit": { "$": 0, "succ": { "git-pages": _4 } } } }, "ee": { "$": 1, "succ": { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _5, "pri": _2, "aip": _2, "org": _2, "fie": _2 } }, "eg": { "$": 1, "succ": { "com": _5, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 } }, "er": _8, "es": { "$": 1, "succ": { "com": _5, "nom": _2, "org": _2, "gob": _2, "edu": _2 } }, "et": { "$": 1, "succ": { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 } }, "eu": { "$": 1, "succ": { "mycd": _4, "cloudns": _4, "barsy": _4, "wellbeingzone": _4, "spdns": _4, "transurl": _7, "diskstation": _4 } }, "fi": { "$": 1, "succ": { "aland": _2, "dy": _4, "blogspot": _4, "xn--hkkinen-5wa": _4, "häkkinen": _4, "iki": _4 } }, "fj": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "fk": _8, "fm": _2, "fo": _2, "fr": { "$": 1, "succ": { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "aeroport": _2, "avocat": _2, "avoues": _2, "cci": _2, "chambagri": _2, "chirurgiens-dentistes": _2, "experts-comptables": _2, "geometre-expert": _2, "greta": _2, "huissier-justice": _2, "medecin": _2, "notaires": _2, "pharmacien": _2, "port": _2, "veterinaire": _2, "en-root": _4, "fbx-os": _4, "fbxos": _4, "freebox-os": _4, "freeboxos": _4, "blogspot": _4, "on-web": _4, "chirurgiens-dentistes-en-france": _4 } }, "ga": _2, "gb": _2, "gd": { "$": 1, "succ": { "nom": _4 } }, "ge": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2, "nom": _4 } }, "gf": _2, "gg": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "kaas": _4, "cya": _4, "panel": { "$": 2, "succ": { "daemon": _4 } } } }, "gh": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 } }, "gi": { "$": 1, "succ": { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 } }, "gl": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _4, "nom": _4, "xx": _4 } }, "gm": _2, "gn": { "$": 1, "succ": { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 } }, "gov": _2, "gp": { "$": 1, "succ": { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _4 } }, "gq": _2, "gr": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _4, "nym": _4 } }, "gs": _2, "gt": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "nom": _4, "blog": _4, "de": _4, "to": _4 } }, "gu": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 } }, "gw": _2, "gy": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "nym": _4, "be": _4 } }, "hk": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "公司": _2, "xn--wcvs22d": _2, "教育": _2, "xn--lcvr32d": _2, "敎育": _2, "xn--mxtq1m": _2, "政府": _2, "xn--gmqw5a": _2, "個人": _2, "xn--ciqpn": _2, "个人": _2, "xn--gmq050i": _2, "箇人": _2, "xn--zf0avx": _2, "網络": _2, "xn--io0a7i": _2, "网络": _2, "xn--mk0axi": _2, "组織": _2, "xn--od0alg": _2, "網絡": _2, "xn--od0aq3b": _2, "网絡": _2, "xn--tn0ag": _2, "组织": _2, "xn--uc0atv": _2, "組織": _2, "xn--uc0ay4a": _2, "組织": _2, "blogspot": _4, "nym": _4, "ltd": _4, "inc": _4 } }, "hm": _2, "hn": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "nom": _4, "cc": _4 } }, "hr": { "$": 1, "succ": { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _4, "free": _4 } }, "ht": { "$": 1, "succ": { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 } }, "hu": { "$": 1, "succ": { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _4 } }, "id": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _5, "desa": _2, "go": _2, "mil": _2, "my": _2, "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2 } }, "ie": _20, "il": { "$": 1, "succ": { "ac": _2, "co": _5, "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 } }, "im": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ltd": _2, "plc": _2 } }, "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _4, "nom": _4 } }, "in": { "$": 1, "succ": { "co": _2, "firm": _2, "net": _2, "org": _2, "gen": _2, "ind": _2, "nic": _2, "ac": _2, "edu": _2, "res": _2, "gov": _2, "mil": _2, "cloudns": _4, "blogspot": _4, "barsy": _4 } }, "info": { "$": 1, "succ": { "cloudns": _4, "dynamic-dns": _4, "dyndns": _4, "barrel-of-knowledge": _4, "barrell-of-knowledge": _4, "for-our": _4, "groks-the": _4, "groks-this": _4, "here-for-more": _4, "knowsitall": _4, "selfip": _4, "webhop": _4, "barsy": _4, "mayfirst": _4, "forumz": _4, "nsupdate": _4, "dvrcam": _4, "ilovecollege": _4, "no-ip": _4, "dnsupdate": _4, "v-info": _4 } }, "int": { "$": 1, "succ": { "eu": _2 } }, "io": { "$": 1, "succ": { "2038": _4, "com": _2, "apigee": _4, "b-data": _4, "backplaneapp": _4, "banzaicloud": { "$": 0, "succ": { "app": _4, "backyards": _7 } }, "boxfuse": _4, "browsersafetymark": _4, "bigv": { "$": 0, "succ": { "uk0": _4 } }, "cleverapps": _4, "dappnode": { "$": 0, "succ": { "dyndns": _4 } }, "dedyn": _4, "drud": _4, "definima": _4, "enonic": { "$": 2, "succ": { "customer": _4 } }, "shw": _4, "github": _4, "gitlab": _4, "lolipop": _4, "hasura-app": _4, "hostyhosting": _4, "moonscale": _7, "jele": _4, "loginline": _4, "barsy": _4, "azurecontainer": _7, "ngrok": _4, "nodeart": { "$": 0, "succ": { "stage": _4 } }, "nodum": _4, "nid": _4, "pantheonsite": _4, "dyn53": _4, "protonet": _4, "qcx": { "$": 2, "succ": { "sys": _7 } }, "vaporcloud": _4, "vbrplsbx": { "$": 0, "succ": { "g": _4 } }, "on-k3s": _7, "on-rio": _7, "readthedocs": _4, "resindevice": _4, "resinstaging": { "$": 0, "succ": { "devices": _4 } }, "hzc": _4, "sandcats": _4, "shiftedit": _4, "mo-siemens": _4, "lair": _15, "stolos": _7, "spacekit": _4, "utwente": _4, "applicationcloud": _4, "scapp": _4, "s5y": _7, "telebit": _4, "thingdust": { "$": 0, "succ": { "dev": _21, "disrec": _21, "prod": _21, "testing": _21 } }, "wedeploy": _4, "basicserver": _4, "virtualserver": _4 } }, "iq": _3, "ir": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2 } }, "is": { "$": 1, "succ": { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _4, "blogspot": _4 } }, "it": { "$": 1, "succ": { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-süd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-südtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-süd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-südtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosüd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosüdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsüd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsüdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallée-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallée-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valléeaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valléedaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-südtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-südtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-südtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlì": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlì": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlì-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlìcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "südtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _4, "16-b": _4, "32-b": _4, "64-b": _4, "syncloud": _4 } }, "je": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2 } }, "jm": _8, "jo": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 } }, "jobs": _2, "jp": { "$": 1, "succ": { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": { "$": 1, "succ": { "aseinet": _18, "gehirn": _4 } }, "or": _2, "aichi": { "$": 1, "succ": { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 } }, "akita": { "$": 1, "succ": { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 } }, "aomori": { "$": 1, "succ": { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 } }, "chiba": { "$": 1, "succ": { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 } }, "ehime": { "$": 1, "succ": { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 } }, "fukui": { "$": 1, "succ": { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 } }, "fukuoka": { "$": 1, "succ": { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 } }, "fukushima": { "$": 1, "succ": { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 } }, "gifu": { "$": 1, "succ": { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 } }, "gunma": { "$": 1, "succ": { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 } }, "hiroshima": { "$": 1, "succ": { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 } }, "hokkaido": { "$": 1, "succ": { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 } }, "hyogo": { "$": 1, "succ": { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 } }, "ibaraki": { "$": 1, "succ": { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 } }, "ishikawa": { "$": 1, "succ": { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 } }, "iwate": { "$": 1, "succ": { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 } }, "kagawa": { "$": 1, "succ": { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 } }, "kagoshima": { "$": 1, "succ": { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 } }, "kanagawa": { "$": 1, "succ": { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 } }, "kochi": { "$": 1, "succ": { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 } }, "kumamoto": { "$": 1, "succ": { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 } }, "kyoto": { "$": 1, "succ": { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 } }, "mie": { "$": 1, "succ": { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 } }, "miyagi": { "$": 1, "succ": { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 } }, "miyazaki": { "$": 1, "succ": { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 } }, "nagano": { "$": 1, "succ": { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 } }, "nagasaki": { "$": 1, "succ": { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 } }, "nara": { "$": 1, "succ": { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 } }, "niigata": { "$": 1, "succ": { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 } }, "oita": { "$": 1, "succ": { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 } }, "okayama": { "$": 1, "succ": { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 } }, "okinawa": { "$": 1, "succ": { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 } }, "osaka": { "$": 1, "succ": { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 } }, "saga": { "$": 1, "succ": { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 } }, "saitama": { "$": 1, "succ": { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 } }, "shiga": { "$": 1, "succ": { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 } }, "shimane": { "$": 1, "succ": { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 } }, "shizuoka": { "$": 1, "succ": { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 } }, "tochigi": { "$": 1, "succ": { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 } }, "tokushima": { "$": 1, "succ": { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 } }, "tokyo": { "$": 1, "succ": { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 } }, "tottori": { "$": 1, "succ": { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 } }, "toyama": { "$": 1, "succ": { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 } }, "wakayama": { "$": 1, "succ": { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 } }, "yamagata": { "$": 1, "succ": { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 } }, "yamaguchi": { "$": 1, "succ": { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 } }, "yamanashi": { "$": 1, "succ": { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 } }, "xn--4pvxs": _2, "栃木": _2, "xn--vgu402c": _2, "愛知": _2, "xn--c3s14m": _2, "愛媛": _2, "xn--f6qx53a": _2, "兵庫": _2, "xn--8pvr4u": _2, "熊本": _2, "xn--uist22h": _2, "茨城": _2, "xn--djrs72d6uy": _2, "北海道": _2, "xn--mkru45i": _2, "千葉": _2, "xn--0trq7p7nn": _2, "和歌山": _2, "xn--8ltr62k": _2, "長崎": _2, "xn--2m4a15e": _2, "長野": _2, "xn--efvn9s": _2, "新潟": _2, "xn--32vp30h": _2, "青森": _2, "xn--4it797k": _2, "静岡": _2, "xn--1lqs71d": _2, "東京": _2, "xn--5rtp49c": _2, "石川": _2, "xn--5js045d": _2, "埼玉": _2, "xn--ehqz56n": _2, "三重": _2, "xn--1lqs03n": _2, "京都": _2, "xn--qqqt11m": _2, "佐賀": _2, "xn--kbrq7o": _2, "大分": _2, "xn--pssu33l": _2, "大阪": _2, "xn--ntsq17g": _2, "奈良": _2, "xn--uisz3g": _2, "宮城": _2, "xn--6btw5a": _2, "宮崎": _2, "xn--1ctwo": _2, "富山": _2, "xn--6orx2r": _2, "山口": _2, "xn--rht61e": _2, "山形": _2, "xn--rht27z": _2, "山梨": _2, "xn--djty4k": _2, "岩手": _2, "xn--nit225k": _2, "岐阜": _2, "xn--rht3d": _2, "岡山": _2, "xn--klty5x": _2, "島根": _2, "xn--kltx9a": _2, "広島": _2, "xn--kltp7d": _2, "徳島": _2, "xn--uuwu58a": _2, "沖縄": _2, "xn--zbx025d": _2, "滋賀": _2, "xn--ntso0iqx3a": _2, "神奈川": _2, "xn--elqq16h": _2, "福井": _2, "xn--4it168d": _2, "福岡": _2, "xn--klt787d": _2, "福島": _2, "xn--rny31h": _2, "秋田": _2, "xn--7t0a264c": _2, "群馬": _2, "xn--5rtq34k": _2, "香川": _2, "xn--k7yn95e": _2, "高知": _2, "xn--tor131o": _2, "鳥取": _2, "xn--d5qv7z876c": _2, "鹿児島": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "usercontent": _4, "blogspot": _4 } }, "ke": { "$": 1, "succ": { "ac": _2, "co": _5, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "nom": _4 } }, "kg": { "$": 1, "succ": { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _4, "io": _4, "jp": _4, "tv": _4, "uk": _4, "us": _4 } }, "kh": _8, "ki": _22, "km": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 } }, "kn": { "$": 1, "succ": { "net": _2, "org": _2, "edu": _2, "gov": _2 } }, "kp": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 } }, "kr": { "$": 1, "succ": { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _4 } }, "kw": { "$": 1, "succ": { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 } }, "ky": _9, "kz": { "$": 1, "succ": { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "nym": _4 } }, "la": { "$": 1, "succ": { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _4, "c": _4, "nym": _4 } }, "lb": _9, "lc": { "$": 1, "succ": { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "nym": _4, "oy": _4 } }, "li": { "$": 1, "succ": { "blogspot": _4, "caa": _4, "nom": _4, "nym": _4 } }, "lk": { "$": 1, "succ": { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 } }, "lr": _9, "ls": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _4 } }, "lt": _20, "lu": _23, "lv": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2, "nom": _4 } }, "ly": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 } }, "ma": { "$": 1, "succ": { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 } }, "mc": { "$": 1, "succ": { "tm": _2, "asso": _2 } }, "md": { "$": 1, "succ": { "blogspot": _4, "at": _4, "de": _4, "jp": _4, "to": _4 } }, "me": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _4, "daplie": { "$": 2, "succ": { "localhost": _4 } }, "edgestack": _4, "couk": _4, "ukco": _4, "filegear": _4, "filegear-au": _4, "filegear-de": _4, "filegear-gb": _4, "filegear-ie": _4, "filegear-jp": _4, "filegear-sg": _4, "glitch": _4, "ravendb": _4, "barsy": _4, "nctu": _4, "soundcast": _4, "tcp4": _4, "brasilia": _4, "ddns": _4, "dnsfor": _4, "hopto": _4, "loginto": _4, "noip": _4, "webhop": _4, "nym": _4, "diskstation": _4, "dscloud": _4, "i234": _4, "myds": _4, "synology": _4, "wedeploy": _4, "yombo": _4, "nohost": _4 } }, "mg": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 } }, "mh": _2, "mil": _2, "mk": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _4, "nom": _4 } }, "ml": { "$": 1, "succ": { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 } }, "mm": _8, "mn": { "$": 1, "succ": { "gov": _2, "edu": _2, "org": _2, "nyc": _4, "nym": _4 } }, "mo": _9, "mobi": { "$": 1, "succ": { "barsy": _4, "dscloud": _4 } }, "mp": _2, "mq": _2, "mr": { "$": 1, "succ": { "gov": _2, "blogspot": _4 } }, "ms": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _4 } }, "mt": { "$": 1, "succ": { "com": _5, "edu": _2, "net": _2, "org": _2 } }, "mu": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 } }, "museum": { "$": 1, "succ": { "academy": _2, "agriculture": _2, "air": _2, "airguard": _2, "alabama": _2, "alaska": _2, "amber": _2, "ambulance": _2, "american": _2, "americana": _2, "americanantiques": _2, "americanart": _2, "amsterdam": _2, "and": _2, "annefrank": _2, "anthro": _2, "anthropology": _2, "antiques": _2, "aquarium": _2, "arboretum": _2, "archaeological": _2, "archaeology": _2, "architecture": _2, "art": _2, "artanddesign": _2, "artcenter": _2, "artdeco": _2, "arteducation": _2, "artgallery": _2, "arts": _2, "artsandcrafts": _2, "asmatart": _2, "assassination": _2, "assisi": _2, "association": _2, "astronomy": _2, "atlanta": _2, "austin": _2, "australia": _2, "automotive": _2, "aviation": _2, "axis": _2, "badajoz": _2, "baghdad": _2, "bahn": _2, "bale": _2, "baltimore": _2, "barcelona": _2, "baseball": _2, "basel": _2, "baths": _2, "bauern": _2, "beauxarts": _2, "beeldengeluid": _2, "bellevue": _2, "bergbau": _2, "berkeley": _2, "berlin": _2, "bern": _2, "bible": _2, "bilbao": _2, "bill": _2, "birdart": _2, "birthplace": _2, "bonn": _2, "boston": _2, "botanical": _2, "botanicalgarden": _2, "botanicgarden": _2, "botany": _2, "brandywinevalley": _2, "brasil": _2, "bristol": _2, "british": _2, "britishcolumbia": _2, "broadcast": _2, "brunel": _2, "brussel": _2, "brussels": _2, "bruxelles": _2, "building": _2, "burghof": _2, "bus": _2, "bushey": _2, "cadaques": _2, "california": _2, "cambridge": _2, "can": _2, "canada": _2, "capebreton": _2, "carrier": _2, "cartoonart": _2, "casadelamoneda": _2, "castle": _2, "castres": _2, "celtic": _2, "center": _2, "chattanooga": _2, "cheltenham": _2, "chesapeakebay": _2, "chicago": _2, "children": _2, "childrens": _2, "childrensgarden": _2, "chiropractic": _2, "chocolate": _2, "christiansburg": _2, "cincinnati": _2, "cinema": _2, "circus": _2, "civilisation": _2, "civilization": _2, "civilwar": _2, "clinton": _2, "clock": _2, "coal": _2, "coastaldefence": _2, "cody": _2, "coldwar": _2, "collection": _2, "colonialwilliamsburg": _2, "coloradoplateau": _2, "columbia": _2, "columbus": _2, "communication": _2, "communications": _2, "community": _2, "computer": _2, "computerhistory": _2, "xn--comunicaes-v6a2o": _2, "comunicações": _2, "contemporary": _2, "contemporaryart": _2, "convent": _2, "copenhagen": _2, "corporation": _2, "xn--correios-e-telecomunicaes-ghc29a": _2, "correios-e-telecomunicações": _2, "corvette": _2, "costume": _2, "countryestate": _2, "county": _2, "crafts": _2, "cranbrook": _2, "creation": _2, "cultural": _2, "culturalcenter": _2, "culture": _2, "cyber": _2, "cymru": _2, "dali": _2, "dallas": _2, "database": _2, "ddr": _2, "decorativearts": _2, "delaware": _2, "delmenhorst": _2, "denmark": _2, "depot": _2, "design": _2, "detroit": _2, "dinosaur": _2, "discovery": _2, "dolls": _2, "donostia": _2, "durham": _2, "eastafrica": _2, "eastcoast": _2, "education": _2, "educational": _2, "egyptian": _2, "eisenbahn": _2, "elburg": _2, "elvendrell": _2, "embroidery": _2, "encyclopedic": _2, "england": _2, "entomology": _2, "environment": _2, "environmentalconservation": _2, "epilepsy": _2, "essex": _2, "estate": _2, "ethnology": _2, "exeter": _2, "exhibition": _2, "family": _2, "farm": _2, "farmequipment": _2, "farmers": _2, "farmstead": _2, "field": _2, "figueres": _2, "filatelia": _2, "film": _2, "fineart": _2, "finearts": _2, "finland": _2, "flanders": _2, "florida": _2, "force": _2, "fortmissoula": _2, "fortworth": _2, "foundation": _2, "francaise": _2, "frankfurt": _2, "franziskaner": _2, "freemasonry": _2, "freiburg": _2, "fribourg": _2, "frog": _2, "fundacio": _2, "furniture": _2, "gallery": _2, "garden": _2, "gateway": _2, "geelvinck": _2, "gemological": _2, "geology": _2, "georgia": _2, "giessen": _2, "glas": _2, "glass": _2, "gorge": _2, "grandrapids": _2, "graz": _2, "guernsey": _2, "halloffame": _2, "hamburg": _2, "handson": _2, "harvestcelebration": _2, "hawaii": _2, "health": _2, "heimatunduhren": _2, "hellas": _2, "helsinki": _2, "hembygdsforbund": _2, "heritage": _2, "histoire": _2, "historical": _2, "historicalsociety": _2, "historichouses": _2, "historisch": _2, "historisches": _2, "history": _2, "historyofscience": _2, "horology": _2, "house": _2, "humanities": _2, "illustration": _2, "imageandsound": _2, "indian": _2, "indiana": _2, "indianapolis": _2, "indianmarket": _2, "intelligence": _2, "interactive": _2, "iraq": _2, "iron": _2, "isleofman": _2, "jamison": _2, "jefferson": _2, "jerusalem": _2, "jewelry": _2, "jewish": _2, "jewishart": _2, "jfk": _2, "journalism": _2, "judaica": _2, "judygarland": _2, "juedisches": _2, "juif": _2, "karate": _2, "karikatur": _2, "kids": _2, "koebenhavn": _2, "koeln": _2, "kunst": _2, "kunstsammlung": _2, "kunstunddesign": _2, "labor": _2, "labour": _2, "lajolla": _2, "lancashire": _2, "landes": _2, "lans": _2, "xn--lns-qla": _2, "läns": _2, "larsson": _2, "lewismiller": _2, "lincoln": _2, "linz": _2, "living": _2, "livinghistory": _2, "localhistory": _2, "london": _2, "losangeles": _2, "louvre": _2, "loyalist": _2, "lucerne": _2, "luxembourg": _2, "luzern": _2, "mad": _2, "madrid": _2, "mallorca": _2, "manchester": _2, "mansion": _2, "mansions": _2, "manx": _2, "marburg": _2, "maritime": _2, "maritimo": _2, "maryland": _2, "marylhurst": _2, "media": _2, "medical": _2, "medizinhistorisches": _2, "meeres": _2, "memorial": _2, "mesaverde": _2, "michigan": _2, "midatlantic": _2, "military": _2, "mill": _2, "miners": _2, "mining": _2, "minnesota": _2, "missile": _2, "missoula": _2, "modern": _2, "moma": _2, "money": _2, "monmouth": _2, "monticello": _2, "montreal": _2, "moscow": _2, "motorcycle": _2, "muenchen": _2, "muenster": _2, "mulhouse": _2, "muncie": _2, "museet": _2, "museumcenter": _2, "museumvereniging": _2, "music": _2, "national": _2, "nationalfirearms": _2, "nationalheritage": _2, "nativeamerican": _2, "naturalhistory": _2, "naturalhistorymuseum": _2, "naturalsciences": _2, "nature": _2, "naturhistorisches": _2, "natuurwetenschappen": _2, "naumburg": _2, "naval": _2, "nebraska": _2, "neues": _2, "newhampshire": _2, "newjersey": _2, "newmexico": _2, "newport": _2, "newspaper": _2, "newyork": _2, "niepce": _2, "norfolk": _2, "north": _2, "nrw": _2, "nyc": _2, "nyny": _2, "oceanographic": _2, "oceanographique": _2, "omaha": _2, "online": _2, "ontario": _2, "openair": _2, "oregon": _2, "oregontrail": _2, "otago": _2, "oxford": _2, "pacific": _2, "paderborn": _2, "palace": _2, "paleo": _2, "palmsprings": _2, "panama": _2, "paris": _2, "pasadena": _2, "pharmacy": _2, "philadelphia": _2, "philadelphiaarea": _2, "philately": _2, "phoenix": _2, "photography": _2, "pilots": _2, "pittsburgh": _2, "planetarium": _2, "plantation": _2, "plants": _2, "plaza": _2, "portal": _2, "portland": _2, "portlligat": _2, "posts-and-telecommunications": _2, "preservation": _2, "presidio": _2, "press": _2, "project": _2, "public": _2, "pubol": _2, "quebec": _2, "railroad": _2, "railway": _2, "research": _2, "resistance": _2, "riodejaneiro": _2, "rochester": _2, "rockart": _2, "roma": _2, "russia": _2, "saintlouis": _2, "salem": _2, "salvadordali": _2, "salzburg": _2, "sandiego": _2, "sanfrancisco": _2, "santabarbara": _2, "santacruz": _2, "santafe": _2, "saskatchewan": _2, "satx": _2, "savannahga": _2, "schlesisches": _2, "schoenbrunn": _2, "schokoladen": _2, "school": _2, "schweiz": _2, "science": _2, "scienceandhistory": _2, "scienceandindustry": _2, "sciencecenter": _2, "sciencecenters": _2, "science-fiction": _2, "sciencehistory": _2, "sciences": _2, "sciencesnaturelles": _2, "scotland": _2, "seaport": _2, "settlement": _2, "settlers": _2, "shell": _2, "sherbrooke": _2, "sibenik": _2, "silk": _2, "ski": _2, "skole": _2, "society": _2, "sologne": _2, "soundandvision": _2, "southcarolina": _2, "southwest": _2, "space": _2, "spy": _2, "square": _2, "stadt": _2, "stalbans": _2, "starnberg": _2, "state": _2, "stateofdelaware": _2, "station": _2, "steam": _2, "steiermark": _2, "stjohn": _2, "stockholm": _2, "stpetersburg": _2, "stuttgart": _2, "suisse": _2, "surgeonshall": _2, "surrey": _2, "svizzera": _2, "sweden": _2, "sydney": _2, "tank": _2, "tcm": _2, "technology": _2, "telekommunikation": _2, "television": _2, "texas": _2, "textile": _2, "theater": _2, "time": _2, "timekeeping": _2, "topology": _2, "torino": _2, "touch": _2, "town": _2, "transport": _2, "tree": _2, "trolley": _2, "trust": _2, "trustee": _2, "uhren": _2, "ulm": _2, "undersea": _2, "university": _2, "usa": _2, "usantiques": _2, "usarts": _2, "uscountryestate": _2, "usculture": _2, "usdecorativearts": _2, "usgarden": _2, "ushistory": _2, "ushuaia": _2, "uslivinghistory": _2, "utah": _2, "uvic": _2, "valley": _2, "vantaa": _2, "versailles": _2, "viking": _2, "village": _2, "virginia": _2, "virtual": _2, "virtuel": _2, "vlaanderen": _2, "volkenkunde": _2, "wales": _2, "wallonie": _2, "war": _2, "washingtondc": _2, "watchandclock": _2, "watch-and-clock": _2, "western": _2, "westfalen": _2, "whaling": _2, "wildlife": _2, "williamsburg": _2, "windmill": _2, "workshop": _2, "york": _2, "yorkshire": _2, "yosemite": _2, "youth": _2, "zoological": _2, "zoology": _2, "xn--9dbhblg6di": _2, "ירושלים": _2, "xn--h1aegh": _2, "иком": _2 } }, "mv": { "$": 1, "succ": { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "mw": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 } }, "mx": { "$": 1, "succ": { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _4, "nym": _4 } }, "my": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "mil": _2, "name": _2, "blogspot": _4 } }, "mz": { "$": 1, "succ": { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "na": { "$": 1, "succ": { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 } }, "name": { "$": 1, "succ": { "her": _26, "his": _26 } }, "nc": { "$": 1, "succ": { "asso": _2, "nom": _2 } }, "ne": _2, "net": { "$": 1, "succ": { "adobeaemcloud": _4, "alwaysdata": _4, "cloudfront": _4, "t3l3p0rt": _4, "myfritz": _4, "blackbaudcdn": _4, "boomla": _4, "bplaced": _4, "square7": _4, "gb": _4, "hu": _4, "jp": _4, "se": _4, "uk": _4, "in": _4, "clic2000": _4, "cloudaccess": _4, "cdn77-ssl": _4, "cdn77": { "$": 0, "succ": { "r": _4 } }, "cloudeity": _4, "feste-ip": _4, "knx-server": _4, "static-access": _4, "cryptonomic": _7, "dattolocal": _4, "mydatto": _4, "debian": _4, "bitbridge": _4, "at-band-camp": _4, "blogdns": _4, "broke-it": _4, "buyshouses": _4, "dnsalias": _4, "dnsdojo": _4, "does-it": _4, "dontexist": _4, "dynalias": _4, "dynathome": _4, "endofinternet": _4, "from-az": _4, "from-co": _4, "from-la": _4, "from-ny": _4, "gets-it": _4, "ham-radio-op": _4, "homeftp": _4, "homeip": _4, "homelinux": _4, "homeunix": _4, "in-the-band": _4, "is-a-chef": _4, "is-a-geek": _4, "isa-geek": _4, "kicks-ass": _4, "office-on-the": _4, "podzone": _4, "scrapper-site": _4, "selfip": _4, "sells-it": _4, "servebbs": _4, "serveftp": _4, "thruhere": _4, "webhop": _4, "definima": _4, "casacam": _4, "dynu": _4, "dynv6": _4, "twmail": _4, "ru": _4, "channelsdvr": { "$": 2, "succ": { "u": _4 } }, "fastlylb": { "$": 2, "succ": { "map": _4 } }, "fastly": { "$": 0, "succ": { "freetls": _4, "map": _4, "prod": { "$": 0, "succ": { "a": _4, "global": _4 } }, "ssl": { "$": 0, "succ": { "a": _4, "b": _4, "global": _4 } } } }, "edgeapp": _4, "flynnhosting": _4, "cloudfunctions": _4, "moonscale": _4, "in-dsl": _4, "in-vpn": _4, "ipifony": _4, "iobb": _4, "cloudjiffy": _4, "elastx": { "$": 0, "succ": { "jls-sto1": _4 } }, "saveincloud": _27, "kinghost": _4, "uni5": _4, "barsy": _4, "memset": _4, "azurewebsites": _4, "azure-mobile": _4, "cloudapp": _4, "dnsup": _4, "hicam": _4, "now-dns": _4, "ownip": _4, "vpndns": _4, "eating-organic": _4, "mydissent": _4, "myeffect": _4, "mymediapc": _4, "mypsx": _4, "mysecuritycamera": _4, "nhlfan": _4, "no-ip": _4, "pgafan": _4, "privatizehealthinsurance": _4, "bounceme": _4, "ddns": _4, "redirectme": _4, "serveblog": _4, "serveminecraft": _4, "sytes": _4, "cloudycluster": _4, "rackmaze": _4, "schokokeks": _4, "firewall-gateway": _4, "seidat": _4, "senseering": _4, "siteleaf": _4, "srcf": { "$": 0, "succ": { "soc": _4, "user": _4 } }, "dsmynas": _4, "familyds": _4, "community-pro": _4, "meinforum": _4, "yandexcloud": { "$": 2, "succ": { "storage": _4, "website": _4 } }, "za": _4 } }, "nf": { "$": 1, "succ": { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 } }, "ng": { "$": 1, "succ": { "com": _5, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _4, "firm": _4, "gen": _4, "ltd": _4, "ngo": _4 } }, "ni": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 } }, "nl": { "$": 1, "succ": { "amsw": _4, "virtueeldomein": _4, "co": _4, "hosting-cluster": _4, "blogspot": _4, "khplay": _4, "transurl": _7, "cistron": _4, "demon": _4 } }, "no": { "$": 1, "succ": { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _28, "ah": _28, "bu": _28, "fm": _28, "hl": _28, "hm": _28, "jan-mayen": _28, "mr": _28, "nl": _28, "nt": _28, "of": _28, "ol": _28, "oslo": _28, "rl": _28, "sf": _28, "st": _28, "svalbard": _28, "tm": _28, "tr": _28, "va": _28, "vf": _28, "akrehamn": _2, "xn--krehamn-dxa": _2, "åkrehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "ålgård": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brønnøysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drøbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florø": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hønefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jørpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevåg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjøndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjøen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osøyro": _2, "raholt": _2, "xn--rholt-mra": _2, "råholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjøen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjørdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "åfjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "ål": _2, "alesund": _2, "xn--lesund-hua": _2, "ålesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "áltá": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "álaheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "åmli": _2, "amot": _2, "xn--mot-tla": _2, "åmot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andøy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "årdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "ås": _2, "aseral": _2, "xn--seral-lra": _2, "åseral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askøy": _2, "asnes": _2, "xn--snes-poa": _2, "åsnes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-høland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averøy": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bálát": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "báhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bájddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "báidár": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevåg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalváhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkøy": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodø": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bådåddjå": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brønnøy": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bærum": _2, "telemark": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2 } }, "nordland": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2, "heroy": _2, "xn--hery-ira": _2, "herøy": _2 } }, "bievat": _2, "xn--bievt-0qa": _2, "bievát": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bømlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "båtsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "báhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrøy": _2, "donna": _2, "xn--dnna-gra": _2, "dønna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenášši": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnøy": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flå": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "fræna": _2, "froya": _2, "xn--frya-hra": _2, "frøya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "førde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gáŋgaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskål": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjøvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kråanghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hábmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hápmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hámmárfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "ákŋoluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": { "$": 0, "succ": { "heroy": _2, "sande": _2 } }, "xn--mre-og-romsdal-qqb": { "$": 0, "succ": { "xn--hery-ira": _2, "sande": _2 } }, "møre-og-romsdal": { "$": 0, "succ": { "herøy": _2, "sande": _2 } }, "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobøl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtålen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hægebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "høyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "høylandet": _2, "ha": _2, "xn--h-2fa": _2, "hå": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderøy": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jølster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kárášjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gálsá": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmøy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klæbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerø": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krødsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "ráhkkerávju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsøy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvæfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvænangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "návuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kåfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gáivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabát": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaŋgaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindås": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "láhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurøy": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lærdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lødingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lørenskog": _2, "loten": _2, "xn--lten-gra": _2, "løten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "måsøy": _2, "muosat": _2, "xn--muost-0qa": _2, "muosát": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "meløy": _2, "meraker": _2, "xn--merker-kua": _2, "meråker": _2, "moareke": _2, "xn--moreke-jua": _2, "moåreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "målselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "málatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nååmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _29, "buskerud": _29, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjárga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjárga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "ráisa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nærøy": _2, "notteroy": _2, "xn--nttery-byae": _2, "nøtterøy": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "øksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegård": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "ørland": _2, "orskog": _2, "xn--rskog-uua": _2, "ørskog": _2, "orsta": _2, "xn--rsta-fra": _2, "ørsta": _2, "hedmark": { "$": 0, "succ": { "os": _2, "valer": _2, "xn--vler-qoa": _2, "våler": _2 } }, "hordaland": { "$": 0, "succ": { "os": _2 } }, "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterøy": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "østre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "øvre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "øyer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "øygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "øystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsáŋgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radøy": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesøy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risør": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rælingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rødøy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rømskog": _2, "roros": _2, "xn--rros-gra": _2, "røros": _2, "rost": _2, "xn--rst-0na": _2, "røst": _2, "royken": _2, "xn--ryken-vua": _2, "røyken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "røyrvik": _2, "rade": _2, "xn--rde-ula": _2, "råde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sálát": _2, "xn--slat-5na": _2, "sálat": _2, "samnanger": _2, "vestfold": { "$": 0, "succ": { "sande": _2 } }, "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandøy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervøy": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervá": _2, "skjak": _2, "xn--skjk-soa": _2, "skjåk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skånland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skánit": _2, "smola": _2, "xn--smla-hra": _2, "smøla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snåsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snåase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjørdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "søgne": _2, "somna": _2, "xn--smna-gra": _2, "sømna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "søndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sør-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sør-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sør-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sør-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mátta-várjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sørfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sørreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sørum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjøme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranøy": _2, "tromso": _2, "xn--troms-zua": _2, "tromsø": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "træna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trøgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvær": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tønsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsø": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "čáhcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardø": _2, "varggat": _2, "xn--vrggt-xqad": _2, "várggát": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegårshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvågøy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "værøy": _2, "vagan": _2, "xn--vgan-qoa": _2, "vågan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vågsøy": _2, "vaga": _2, "xn--vg-yiab": _2, "vågå": _2, "ostfold": { "$": 0, "succ": { "valer": _2 } }, "xn--stfold-9xa": { "$": 0, "succ": { "xn--vler-qoa": _2 } }, "østfold": { "$": 0, "succ": { "våler": _2 } }, "co": _4, "blogspot": _4 } }, "np": _8, "nr": _22, "nu": { "$": 1, "succ": { "merseine": _4, "mine": _4, "shacknet": _4, "nom": _4, "uwu": _4, "enterprisecloud": _4 } }, "nz": { "$": 1, "succ": { "ac": _2, "co": _5, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "māori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2, "nym": _4 } }, "om": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 } }, "onion": _2, "org": { "$": 1, "succ": { "altervista": _4, "amune": { "$": 0, "succ": { "tele": _4 } }, "pimienta": _4, "poivron": _4, "potager": _4, "sweetpepper": _4, "ae": _4, "us": _4, "certmgr": _4, "cdn77": { "$": 0, "succ": { "c": _4, "rsc": _4 } }, "cdn77-secure": { "$": 0, "succ": { "origin": { "$": 0, "succ": { "ssl": _4 } } } }, "cloudns": _4, "duckdns": _4, "tunk": _4, "dyndns": { "$": 2, "succ": { "go": _4, "home": _4 } }, "blogdns": _4, "blogsite": _4, "boldlygoingnowhere": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dvrdns": _4, "dynalias": _4, "endofinternet": _4, "endoftheinternet": _4, "from-me": _4, "game-host": _4, "gotdns": _4, "hobby-site": _4, "homedns": _4, "homeftp": _4, "homelinux": _4, "homeunix": _4, "is-a-bruinsfan": _4, "is-a-candidate": _4, "is-a-celticsfan": _4, "is-a-chef": _4, "is-a-geek": _4, "is-a-knight": _4, "is-a-linux-user": _4, "is-a-patsfan": _4, "is-a-soxfan": _4, "is-found": _4, "is-lost": _4, "is-saved": _4, "is-very-bad": _4, "is-very-evil": _4, "is-very-good": _4, "is-very-nice": _4, "is-very-sweet": _4, "isa-geek": _4, "kicks-ass": _4, "misconfused": _4, "podzone": _4, "readmyblog": _4, "selfip": _4, "sellsyourhome": _4, "servebbs": _4, "serveftp": _4, "servegame": _4, "stuff-4-sale": _4, "webhop": _4, "ddnss": _4, "accesscam": _4, "camdvr": _4, "freeddns": _4, "mywire": _4, "webredirect": _4, "eu": { "$": 2, "succ": { "al": _4, "asso": _4, "at": _4, "au": _4, "be": _4, "bg": _4, "ca": _4, "cd": _4, "ch": _4, "cn": _4, "cy": _4, "cz": _4, "de": _4, "dk": _4, "edu": _4, "ee": _4, "es": _4, "fi": _4, "fr": _4, "gr": _4, "hr": _4, "hu": _4, "ie": _4, "il": _4, "in": _4, "int": _4, "is": _4, "it": _4, "jp": _4, "kr": _4, "lt": _4, "lu": _4, "lv": _4, "mc": _4, "me": _4, "mk": _4, "mt": _4, "my": _4, "net": _4, "ng": _4, "nl": _4, "no": _4, "nz": _4, "paris": _4, "pl": _4, "pt": _4, "q-a": _4, "ro": _4, "ru": _4, "se": _4, "si": _4, "sk": _4, "tr": _4, "uk": _4, "us": _4 } }, "twmail": _4, "fedorainfracloud": _4, "fedorapeople": _4, "fedoraproject": { "$": 0, "succ": { "cloud": _4, "os": _16, "stg": { "$": 0, "succ": { "os": _16 } } } }, "freedesktop": _4, "hepforge": _4, "in-dsl": _4, "in-vpn": _4, "js": _4, "uklugs": _4, "barsy": _4, "mayfirst": _4, "mozilla-iot": _4, "bmoattachments": _4, "dynserv": _4, "now-dns": _4, "cable-modem": _4, "collegefan": _4, "couchpotatofries": _4, "mlbfan": _4, "mysecuritycamera": _4, "nflfan": _4, "read-books": _4, "ufcfan": _4, "hopto": _4, "myftp": _4, "no-ip": _4, "zapto": _4, "pubtls": _4, "my-firewall": _4, "myfirewall": _4, "spdns": _4, "dsmynas": _4, "familyds": _4, "edugit": _4, "tuxfamily": _4, "diskstation": _4, "hk": _4, "wmflabs": _4, "toolforge": _4, "wmcloud": _4, "za": _4 } }, "pa": { "$": 1, "succ": { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 } }, "pe": { "$": 1, "succ": { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _4, "nym": _4 } }, "pf": { "$": 1, "succ": { "com": _2, "org": _2, "edu": _2 } }, "pg": _8, "ph": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 } }, "pk": { "$": 1, "succ": { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 } }, "pl": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": { "$": 1, "succ": { "ap": _2, "ic": _2, "is": _2, "us": _2, "kmpsp": _2, "kppsp": _2, "kwpsp": _2, "psp": _2, "wskr": _2, "kwp": _2, "mw": _2, "ug": _2, "um": _2, "umig": _2, "ugim": _2, "upow": _2, "uw": _2, "starostwo": _2, "pa": _2, "po": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "so": _2, "sr": _2, "wsa": _2, "sko": _2, "uzs": _2, "wiih": _2, "winb": _2, "pinb": _2, "wios": _2, "witd": _2, "wzmiuw": _2, "piw": _2, "wiw": _2, "griw": _2, "wif": _2, "oum": _2, "sdn": _2, "zp": _2, "uppo": _2, "mup": _2, "wuoz": _2, "konsulat": _2, "oirm": _2 } }, "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _4, "krasnik": _4, "leczna": _4, "lubartow": _4, "lublin": _4, "poniatowa": _4, "swidnik": _4, "co": _4, "art": _4, "gliwice": _4, "krakow": _4, "poznan": _4, "wroc": _4, "zakopane": _4, "gda": _4, "gdansk": _4, "gdynia": _4, "med": _4, "sopot": _4 } }, "pm": { "$": 1, "succ": { "own": _4 } }, "pn": { "$": 1, "succ": { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 } }, "post": _2, "pr": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 } }, "pro": { "$": 1, "succ": { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _4, "dnstrace": { "$": 0, "succ": { "bci": _4 } }, "barsy": _4 } }, "ps": { "$": 1, "succ": { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 } }, "pt": { "$": 1, "succ": { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _4, "nym": _4 } }, "pw": { "$": 1, "succ": { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _4, "x443": _4, "nom": _4 } }, "py": { "$": 1, "succ": { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "qa": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _4, "nom": _4 } }, "re": { "$": 1, "succ": { "asso": _2, "com": _2, "nom": _2, "blogspot": _4 } }, "ro": { "$": 1, "succ": { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "shop": _4, "blogspot": _4, "nym": _4 } }, "rs": { "$": 1, "succ": { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "blogspot": _4, "ua": _4, "nom": _4, "ox": _4 } }, "ru": { "$": 1, "succ": { "ac": _4, "edu": _4, "gov": _4, "int": _4, "mil": _4, "test": _4, "adygeya": _4, "bashkiria": _4, "bir": _4, "cbg": _4, "com": _4, "dagestan": _4, "grozny": _4, "kalmykia": _4, "kustanai": _4, "marine": _4, "mordovia": _4, "msk": _4, "mytis": _4, "nalchik": _4, "nov": _4, "pyatigorsk": _4, "spb": _4, "vladikavkaz": _4, "vladimir": _4, "blogspot": _4, "regruhosting": _27, "myjino": { "$": 2, "succ": { "hosting": _7, "landing": _7, "spectrum": _7, "vps": _7 } }, "cldmail": { "$": 0, "succ": { "hb": _4 } }, "net": _4, "org": _4, "pp": _4, "ras": _4 } }, "rw": { "$": 1, "succ": { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "sa": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 } }, "sb": _9, "sc": _9, "sd": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 } }, "se": { "$": 1, "succ": { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _4, "blogspot": _4, "conf": _4 } }, "sg": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _4 } }, "sh": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "hashbang": _4, "platform": { "$": 0, "succ": { "bc": _4, "ent": _4, "eu": _4, "us": _4 } }, "now": _4, "vxl": _4, "wedeploy": _4 } }, "si": { "$": 1, "succ": { "gitpage": _4, "blogspot": _4, "nom": _4 } }, "sj": _2, "sk": _23, "sl": _9, "sm": _2, "sn": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _4 } }, "so": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _4 } }, "sr": _2, "ss": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2 } }, "st": { "$": 1, "succ": { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "nom": _4, "noho": _4 } }, "su": { "$": 1, "succ": { "abkhazia": _4, "adygeya": _4, "aktyubinsk": _4, "arkhangelsk": _4, "armenia": _4, "ashgabad": _4, "azerbaijan": _4, "balashov": _4, "bashkiria": _4, "bryansk": _4, "bukhara": _4, "chimkent": _4, "dagestan": _4, "east-kazakhstan": _4, "exnet": _4, "georgia": _4, "grozny": _4, "ivanovo": _4, "jambyl": _4, "kalmykia": _4, "kaluga": _4, "karacol": _4, "karaganda": _4, "karelia": _4, "khakassia": _4, "krasnodar": _4, "kurgan": _4, "kustanai": _4, "lenug": _4, "mangyshlak": _4, "mordovia": _4, "msk": _4, "murmansk": _4, "nalchik": _4, "navoi": _4, "north-kazakhstan": _4, "nov": _4, "obninsk": _4, "penza": _4, "pokrovsk": _4, "sochi": _4, "spb": _4, "tashkent": _4, "termez": _4, "togliatti": _4, "troitsk": _4, "tselinograd": _4, "tula": _4, "tuva": _4, "vladikavkaz": _4, "vladimir": _4, "vologda": _4, "nym": _4 } }, "sv": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 } }, "sx": { "$": 1, "succ": { "gov": _2, "nym": _4 } }, "sy": _3, "sz": { "$": 1, "succ": { "co": _2, "ac": _2, "org": _2 } }, "tc": { "$": 1, "succ": { "ch": _4, "me": _4, "we": _4 } }, "td": _5, "tel": _2, "tf": _2, "tg": _2, "th": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _4, "shop": _4 } }, "tj": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2, "nom": _4 } }, "tk": _2, "tl": _6, "tm": { "$": 1, "succ": { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 } }, "tn": { "$": 1, "succ": { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "intl": _2, "nat": _2, "net": _2, "org": _2, "info": _2, "perso": _2, "tourism": _2, "edunet": _2, "rnrt": _2, "rns": _2, "rnu": _2, "mincom": _2, "agrinet": _2, "defense": _2, "turen": _2 } }, "to": { "$": 1, "succ": { "611": _4, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _4, "vpnplus": _4, "quickconnect": { "$": 0, "succ": { "direct": _4 } }, "nyan": _4 } }, "tr": { "$": 1, "succ": { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _5, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _6 } }, "tt": { "$": 1, "succ": { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 } }, "tv": { "$": 1, "succ": { "dyndns": _4, "better-than": _4, "on-the-web": _4, "worse-than": _4 } }, "tw": { "$": 1, "succ": { "edu": _2, "gov": _2, "mil": _2, "com": { "$": 1, "succ": { "mymailer": _4 } }, "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "網路": _2, "xn--uc0atv": _2, "組織": _2, "xn--czrw28b": _2, "商業": _2, "url": _4, "blogspot": _4, "nym": _4 } }, "tz": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 } }, "ua": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _4, "inf": _4, "ltd": _4, "biz": _4, "co": _4, "pp": _4, "v": _4 } }, "ug": { "$": 1, "succ": { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _4, "nom": _4 } }, "uk": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "bytemark": { "$": 0, "succ": { "dh": _4, "vm": _4 } }, "blogspot": _4, "layershift": _17, "barsy": _4, "barsyonline": _4, "nh-serv": _4, "no-ip": _4, "wellbeingzone": _4, "gwiddle": _4 } }, "gov": { "$": 1, "succ": { "service": _4, "homeoffice": _4 } }, "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": { "$": 1, "succ": { "glug": _4, "lug": _4, "lugs": _4 } }, "plc": _2, "police": _2, "sch": _8, "conn": _4, "copro": _4, "barsy": _4 } }, "us": { "$": 1, "succ": { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _30, "al": _30, "ar": _30, "as": _30, "az": _30, "ca": _30, "co": _30, "ct": _30, "dc": _30, "de": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _4 } }, "fl": _30, "ga": _30, "gu": _30, "hi": _31, "ia": _30, "id": _30, "il": _30, "in": _30, "ks": _30, "ky": _30, "la": _30, "ma": { "$": 1, "succ": { "k12": { "$": 1, "succ": { "pvt": _2, "chtr": _2, "paroch": _2 } }, "cc": _2, "lib": _2 } }, "md": _30, "me": _30, "mi": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 } }, "mn": _30, "mo": _30, "ms": _30, "mt": _30, "nc": _30, "nd": _31, "ne": _30, "nh": _30, "nj": _30, "nm": _30, "nv": _30, "ny": _30, "oh": _30, "ok": _30, "or": _30, "pa": _30, "pr": _30, "ri": _31, "sc": _30, "sd": _31, "tn": _30, "tx": _30, "ut": _30, "vi": _30, "vt": _30, "va": _30, "wa": _30, "wi": _30, "wv": { "$": 1, "succ": { "cc": _2 } }, "wy": _30, "cloudns": _4, "drud": _4, "is-by": _4, "land-4-sale": _4, "stuff-4-sale": _4, "graphox": _4, "freeddns": _4, "golffan": _4, "noip": _4, "pointto": _4, "platterp": _4 } }, "uy": { "$": 1, "succ": { "com": _5, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2, "nom": _4 } }, "uz": { "$": 1, "succ": { "co": _2, "com": _2, "net": _2, "org": _2 } }, "va": _2, "vc": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": { "$": 2, "succ": { "d": _4 } }, "0e": _4, "nom": _4 } }, "ve": { "$": 1, "succ": { "arts": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "org": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 } }, "vg": { "$": 1, "succ": { "nom": _4, "at": _4 } }, "vi": { "$": 1, "succ": { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 } }, "vn": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "int": _2, "ac": _2, "biz": _2, "info": _2, "name": _2, "pro": _2, "health": _2, "blogspot": _4 } }, "vu": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "blog": _4, "dev": _4, "me": _4, "cn": _4 } }, "wf": _2, "ws": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _7, "cloud66": _4, "dyndns": _4, "mypets": _4 } }, "yt": _2, "xn--mgbaam7a8h": _2, "امارات": _2, "xn--y9a3aq": _2, "հայ": _2, "xn--54b7fta0cc": _2, "বাংলা": _2, "xn--90ae": _2, "бг": _2, "xn--90ais": _2, "бел": _2, "xn--fiqs8s": _2, "中国": _2, "xn--fiqz9s": _2, "中國": _2, "xn--lgbbat1ad8j": _2, "الجزائر": _2, "xn--wgbh1c": _2, "مصر": _2, "xn--e1a4c": _2, "ею": _2, "xn--qxa6a": _2, "ευ": _2, "xn--mgbah1a3hjkrd": _2, "موريتانيا": _2, "xn--node": _2, "გე": _2, "xn--qxam": _2, "ελ": _2, "xn--j6w193g": { "$": 1, "succ": { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 } }, "香港": { "$": 1, "succ": { "公司": _2, "教育": _2, "政府": _2, "個人": _2, "網絡": _2, "組織": _2 } }, "xn--2scrj9c": _2, "ಭಾರತ": _2, "xn--3hcrj9c": _2, "ଭାରତ": _2, "xn--45br5cyl": _2, "ভাৰত": _2, "xn--h2breg3eve": _2, "भारतम्": _2, "xn--h2brj9c8c": _2, "भारोत": _2, "xn--mgbgu82a": _2, "ڀارت": _2, "xn--rvc1e0am3e": _2, "ഭാരതം": _2, "xn--h2brj9c": _2, "भारत": _2, "xn--mgbbh1a": _2, "بارت": _2, "xn--mgbbh1a71e": _2, "بھارت": _2, "xn--fpcrj9c3d": _2, "భారత్": _2, "xn--gecrj9c": _2, "ભારત": _2, "xn--s9brj9c": _2, "ਭਾਰਤ": _2, "xn--45brj9c": _2, "ভারত": _2, "xn--xkc2dl3a5ee0h": _2, "இந்தியா": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2, "xn--mgbtx2b": _2, "عراق": _2, "xn--mgbayh7gpa": _2, "الاردن": _2, "xn--3e0b707e": _2, "한국": _2, "xn--80ao21a": _2, "қаз": _2, "xn--fzc2c9e2c": _2, "ලංකා": _2, "xn--xkc2al3hye2a": _2, "இலங்கை": _2, "xn--mgbc0a9azcg": _2, "المغرب": _2, "xn--d1alf": _2, "мкд": _2, "xn--l1acc": _2, "мон": _2, "xn--mix891f": _2, "澳門": _2, "xn--mix082f": _2, "澳门": _2, "xn--mgbx4cd0ab": _2, "مليسيا": _2, "xn--mgb9awbf": _2, "عمان": _2, "xn--mgbai9azgqp6j": _2, "پاکستان": _2, "xn--mgbai9a5eva00b": _2, "پاكستان": _2, "xn--ygbi2ammx": _2, "فلسطين": _2, "xn--90a3ac": { "$": 1, "succ": { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 } }, "срб": { "$": 1, "succ": { "пр": _2, "орг": _2, "обр": _2, "од": _2, "упр": _2, "ак": _2 } }, "xn--p1ai": _2, "рф": _2, "xn--wgbl6a": _2, "قطر": _2, "xn--mgberp4a5d4ar": _2, "السعودية": _2, "xn--mgberp4a5d4a87g": _2, "السعودیة": _2, "xn--mgbqly7c0a67fbc": _2, "السعودیۃ": _2, "xn--mgbqly7cvafr": _2, "السعوديه": _2, "xn--mgbpl2fh": _2, "سودان": _2, "xn--yfro4i67o": _2, "新加坡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "சிங்கப்பூர்": _2, "xn--ogbpf8fl": _2, "سورية": _2, "xn--mgbtf8fl": _2, "سوريا": _2, "xn--o3cw4h": { "$": 1, "succ": { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 } }, "ไทย": { "$": 1, "succ": { "ศึกษา": _2, "ธุรกิจ": _2, "รัฐบาล": _2, "ทหาร": _2, "เน็ต": _2, "องค์กร": _2 } }, "xn--pgbs0dh": _2, "تونس": _2, "xn--kpry57d": _2, "台灣": _2, "xn--kprw13d": _2, "台湾": _2, "xn--nnx388a": _2, "臺灣": _2, "xn--j1amh": _2, "укр": _2, "xn--mgb2ddes": _2, "اليمن": _2, "xxx": _2, "ye": _8, "za": { "$": 0, "succ": { "ac": _2, "agric": _2, "alt": _2, "co": _5, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 } }, "zm": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 } }, "zw": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 } }, "aaa": _2, "aarp": _2, "abarth": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": { "$": 1, "succ": { "official": _4 } }, "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "adac": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afamilycompany": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alfaromeo": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": { "$": 1, "succ": { "wnext": _4, "run": { "$": 2, "succ": { "a": _4 } }, "web": _4, "hasura": _4, "loginline": _4, "netlify": _4, "telebit": _4, "vercel": _4 } }, "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": _2, "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "budapest": _2, "bugatti": _2, "build": _2, "builders": _2, "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "cancerresearch": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": { "$": 1, "succ": { "nabu": { "$": 0, "succ": { "ui": _4 } } } }, "case": _2, "caseih": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "ceb": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _11, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": { "$": 1, "succ": { "banzai": _7, "statics": _7, "jele": _4, "linkyard": _4, "magentosite": _7, "perspecta": _4, "vapor": _4, "on-rancher": _7, "sensiosite": _7, "trafficplex": _4, "urown": _4, "voorloper": _4 } }, "club": { "$": 1, "succ": { "cloudns": _4, "jele": _4, "barsy": _4, "pony": _4 } }, "clubmed": _2, "coach": _2, "codes": { "$": 1, "succ": { "owo": _7 } }, "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": { "$": 1, "succ": { "ravendb": _4, "myforum": _4 } }, "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cookingchannel": _2, "cool": { "$": 1, "succ": { "de": _4 } }, "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "csc": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": { "$": 1, "succ": { "bss": _4 } }, "dev": { "$": 1, "succ": { "lcl": _7, "stg": _7, "workers": _4, "curv": _4, "fly": _4, "iserv": _4, "loginline": _4, "platter-app": _4, "vercel": _4, "webhare": _7 } }, "dhl": _2, "diamonds": _2, "diet": _2, "digital": { "$": 1, "succ": { "cloudapps": { "$": 2, "succ": { "london": _4 } } } }, "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "duck": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": { "$": 1, "succ": { "dapps": { "$": 0, "succ": { "*": _4, "bzz": _7 } } } }, "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": { "$": 1, "succ": { "compute": _7 } }, "etisalat": _2, "eurovision": _2, "eus": { "$": 1, "succ": { "party": _18 } }, "events": _10, "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _19, "family": _2, "fan": _2, "fans": _2, "farm": { "$": 1, "succ": { "storj": _4 } }, "farmers": _2, "fashion": { "$": 1, "succ": { "of": _4, "on": _4 } }, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fiat": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": { "$": 1, "succ": { "ptplus": _4 } }, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "foodnetwork": _2, "football": { "$": 1, "succ": { "of": _4 } }, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fujixerox": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": { "$": 1, "succ": { "cnpy": _4 } }, "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glade": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": { "$": 1, "succ": { "cloud": _4 } }, "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": { "$": 1, "succ": { "discourse": _4 } }, "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": _2, "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hgtv": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": { "$": 1, "succ": { "cloudaccess": _4, "freesite": _4, "fastvps": _4, "myfast": _4, "jele": _4, "mircloud": _4, "pcloud": _4, "half": _4 } }, "hosting": { "$": 1, "succ": { "opencraft": _4 } }, "hot": _2, "hoteles": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _11, "institute": _2, "insurance": _2, "insure": _2, "intel": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "iveco": _2, "jaguar": _2, "java": _2, "jcb": _2, "jcp": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": { "$": 1, "succ": { "co": _4, "edu": _4 } }, "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "lancia": _2, "land": { "$": 1, "succ": { "static": { "$": 2, "succ": { "dev": _4, "sites": _4 } } } }, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "linde": _2, "link": { "$": 1, "succ": { "cyon": _4, "mypep": _4, "dweb": _7 } }, "lipsy": _2, "live": _2, "living": _2, "lixil": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "loft": _2, "lol": _2, "london": { "$": 1, "succ": { "in": _4, "of": _4 } }, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "lupin": _2, "luxe": _2, "luxury": _2, "macys": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": { "$": 1, "succ": { "router": _4 } }, "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "maserati": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _2, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _24, "menu": _25, "merckmsd": _2, "metlife": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": { "$": 1, "succ": { "and": _4, "for": _4 } }, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "mutual": _2, "nab": _2, "nagoya": _2, "nationwide": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": { "$": 1, "succ": { "alces": _7, "co": _4, "arvo": _4, "azimuth": _4 } }, "neustar": _2, "new": _2, "newholland": _2, "news": _2, "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "northwesternmutual": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "off": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": { "$": 1, "succ": { "onred": { "$": 2, "succ": { "staging": _4 } }, "for": _4, "homelink": _4 } }, "ong": _2, "onl": _2, "online": _25, "onyourside": _2, "ooo": _2, "open": _2, "oracle": _2, "orange": _2, "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": { "$": 1, "succ": { "nerdpol": _4 } }, "page": { "$": 1, "succ": { "pdns": _4, "plesk": _4, "prvcy": _4 } }, "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _19, "passagens": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _2, "physio": _2, "pics": _2, "pictet": _2, "pictures": { "$": 1, "succ": { "1337": _4 } }, "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": _2, "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": { "$": 1, "succ": { "indie": _4 } }, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _25, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "qvc": _2, "racing": _2, "radio": _2, "raid": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _19, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": { "$": 1, "succ": { "clan": _4 } }, "rmit": _2, "rocher": _2, "rocks": { "$": 1, "succ": { "myddns": _4, "lima-city": _4, "webspace": _4 } }, "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": { "$": 1, "succ": { "hs": _4, "development": _4, "ravendb": _4, "repl": _4 } }, "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _24, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _11, "schule": _2, "schwarz": _2, "science": _19, "scjohnson": _2, "scot": { "$": 1, "succ": { "gov": _4 } }, "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": { "$": 1, "succ": { "loginline": _4 } }, "ses": _2, "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": _25, "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "shriram": _2, "silk": _2, "sina": _2, "singles": _2, "site": { "$": 1, "succ": { "cloudera": _4, "cyon": _4, "fastvps": _4, "jele": _4, "lelux": _4, "loginline": _4, "barsy": _4, "opensocial": _4, "platformsh": _7, "byen": _4, "mintere": _4 } }, "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": _2, "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": { "$": 1, "succ": { "myfast": _4, "linkitools": _4, "uber": _4, "xs4all": _4 } }, "sport": _2, "spot": _2, "spreadbetting": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": { "$": 1, "succ": { "shopware": _4 } }, "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _25, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiftcover": _2, "swiss": _2, "sydney": _2, "systems": { "$": 1, "succ": { "knightpoint": _4 } }, "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": { "$": 1, "succ": { "discourse": _4, "jelastic": _4 } }, "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tiffany": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": _2, "tokyo": _2, "tools": _2, "top": { "$": 1, "succ": { "now-dns": _4, "ntdll": _4 } }, "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _19, "trading": _2, "training": _2, "travel": _2, "travelchannel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "vuelos": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _2, "wed": _2, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _2, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": { "$": 1, "succ": { "of": _4, "to": _4 } }, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "कॉम": _2, "xn--1ck2e1b": _2, "セール": _2, "xn--1qqw23a": _2, "佛山": _2, "xn--30rr7y": _2, "慈善": _2, "xn--3bst00m": _2, "集团": _2, "xn--3ds443g": _2, "在线": _2, "xn--3oq18vl8pn36a": _2, "大众汽车": _2, "xn--3pxu8k": _2, "点看": _2, "xn--42c2d9a": _2, "คอม": _2, "xn--45q11c": _2, "八卦": _2, "xn--4gbrim": _2, "موقع": _2, "xn--55qw42g": _2, "公益": _2, "xn--55qx5d": _2, "公司": _2, "xn--5su34j936bgsg": _2, "香格里拉": _2, "xn--5tzm5g": _2, "网站": _2, "xn--6frz82g": _2, "移动": _2, "xn--6qq986b3xl": _2, "我爱你": _2, "xn--80adxhks": _2, "москва": _2, "xn--80aqecdr1a": _2, "католик": _2, "xn--80asehdb": _2, "онлайн": _2, "xn--80aswg": _2, "сайт": _2, "xn--8y0a063a": _2, "联通": _2, "xn--9dbq2a": _2, "קום": _2, "xn--9et52u": _2, "时尚": _2, "xn--9krt00a": _2, "微博": _2, "xn--b4w605ferd": _2, "淡马锡": _2, "xn--bck1b9a5dre4c": _2, "ファッション": _2, "xn--c1avg": _2, "орг": _2, "xn--c2br7g": _2, "नेट": _2, "xn--cck2b3b": _2, "ストア": _2, "xn--cckwcxetd": _2, "アマゾン": _2, "xn--cg4bki": _2, "삼성": _2, "xn--czr694b": _2, "商标": _2, "xn--czrs0t": _2, "商店": _2, "xn--czru2d": _2, "商城": _2, "xn--d1acj3b": _2, "дети": _2, "xn--eckvdtc9d": _2, "ポイント": _2, "xn--efvy88h": _2, "新闻": _2, "xn--fct429k": _2, "家電": _2, "xn--fhbei": _2, "كوم": _2, "xn--fiq228c5hs": _2, "中文网": _2, "xn--fiq64b": _2, "中信": _2, "xn--fjq720a": _2, "娱乐": _2, "xn--flw351e": _2, "谷歌": _2, "xn--fzys8d69uvgm": _2, "電訊盈科": _2, "xn--g2xx48c": _2, "购物": _2, "xn--gckr3f0f": _2, "クラウド": _2, "xn--gk3at1e": _2, "通販": _2, "xn--hxt814e": _2, "网店": _2, "xn--i1b6b1a6a2e": _2, "संगठन": _2, "xn--imr513n": _2, "餐厅": _2, "xn--io0a7i": _2, "网络": _2, "xn--j1aef": _2, "ком": _2, "xn--jlq480n2rg": _2, "亚马逊": _2, "xn--jlq61u9w7b": _2, "诺基亚": _2, "xn--jvr189m": _2, "食品": _2, "xn--kcrx77d1x4a": _2, "飞利浦": _2, "xn--kput3i": _2, "手机": _2, "xn--mgba3a3ejt": _2, "ارامكو": _2, "xn--mgba7c0bbn0a": _2, "العليان": _2, "xn--mgbaakc7dvf": _2, "اتصالات": _2, "xn--mgbab2bd": _2, "بازار": _2, "xn--mgbca7dzdo": _2, "ابوظبي": _2, "xn--mgbi4ecexp": _2, "كاثوليك": _2, "xn--mgbt3dhd": _2, "همراه": _2, "xn--mk1bu44c": _2, "닷컴": _2, "xn--mxtq1m": _2, "政府": _2, "xn--ngbc5azd": _2, "شبكة": _2, "xn--ngbe9e0a": _2, "بيتك": _2, "xn--ngbrx": _2, "عرب": _2, "xn--nqv7f": _2, "机构": _2, "xn--nqv7fs00ema": _2, "组织机构": _2, "xn--nyqy26a": _2, "健康": _2, "xn--otu796d": _2, "招聘": _2, "xn--p1acf": _2, "рус": _2, "xn--pssy2u": _2, "大拿": _2, "xn--q9jyb4c": _2, "みんな": _2, "xn--qcka1pmc": _2, "グーグル": _2, "xn--rhqv96g": _2, "世界": _2, "xn--rovu88b": _2, "書籍": _2, "xn--ses554g": _2, "网址": _2, "xn--t60b56a": _2, "닷넷": _2, "xn--tckwe": _2, "コム": _2, "xn--tiq49xqyj": _2, "天主教": _2, "xn--unup4y": _2, "游戏": _2, "xn--vermgensberater-ctb": _2, "vermögensberater": _2, "xn--vermgensberatung-pwb": _2, "vermögensberatung": _2, "xn--vhquv": _2, "企业": _2, "xn--vuq861b": _2, "信息": _2, "xn--w4r85el8fhu5dnra": _2, "嘉里大酒店": _2, "xn--w4rs40l": _2, "嘉里": _2, "xn--xhq521b": _2, "广东": _2, "xn--zfr164b": _2, "政务": _2, "xyz": { "$": 1, "succ": { "blogsite": _4, "fhapp": _4, "crafting": _4, "zapto": _4, "telebit": _7 } }, "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": { "$": 1, "succ": { "cloud66": _4, "hs": _4, "triton": _7, "lima": _4 } }, "zuerich": _2 } };
        return rules;
    })();

    function lookupInTrie(parts, trie, index, allowedMask) {
        let result = null;
        let node = trie;
        while (node !== undefined) {
            if ((node.$ & allowedMask) !== 0) {
                result = {
                    index: index + 1,
                    isIcann: node.$ === 1 ,
                    isPrivate: node.$ === 2 ,
                };
            }
            if (index === -1) {
                break;
            }
            const succ = node.succ;
            node = succ && (succ[parts[index]] || succ['*']);
            index -= 1;
        }
        return result;
    }
    function suffixLookup(hostname, options, out) {
        if (fastPathLookup(hostname, options, out) === true) {
            return;
        }
        const hostnameParts = hostname.split('.');
        const allowedMask = (options.allowPrivateDomains === true ? 2  : 0) |
            (options.allowIcannDomains === true ? 1  : 0);
        const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
        if (exceptionMatch !== null) {
            out.isIcann = exceptionMatch.isIcann;
            out.isPrivate = exceptionMatch.isPrivate;
            out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
            return;
        }
        const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
        if (rulesMatch !== null) {
            out.isIcann = rulesMatch.isIcann;
            out.isPrivate = rulesMatch.isPrivate;
            out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
            return;
        }
        out.isIcann = false;
        out.isPrivate = false;
        out.publicSuffix = hostnameParts[hostnameParts.length - 1];
    }

    const RESULT = getEmptyResult();
    function parse(url, options = {}) {
        return parseImpl(url, 5 , suffixLookup, options, getEmptyResult());
    }
    function getHostname(url, options = {}) {
        resetResult(RESULT);
        return parseImpl(url, 0 , suffixLookup, options, RESULT).hostname;
    }
    function getPublicSuffix(url, options = {}) {
        resetResult(RESULT);
        return parseImpl(url, 2 , suffixLookup, options, RESULT).publicSuffix;
    }

    /**
     * This is a helper class that is used specifically to work
     * with domains restrictions.
     *
     * There are two options how you can add a domain restriction:
     * * `$domain` modifier: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     * * domains list for the cosmetic rules
     *
     * The only difference between them is that in one case we use `|` as a separator,
     * and in the other case - `,`.
     *
     * Examples:
     * * `||example.org^$domain=example.com|~sub.example.com` -- network rule
     * * `example.com,~sub.example.com##banner` -- cosmetic rule
     */
    var DomainModifier = /** @class */ (function () {
        /**
         * Parses the `domains` string and initializes the object.
         *
         * @param domains - domains string
         * @param sep - separator (`,` or `|`)
         *
         * @throws an error if the domains string is empty or invalid
         */
        function DomainModifier(domains, sep) {
            if (!domains) {
                throw new SyntaxError('Modifier $domain cannot be empty');
            }
            var permittedDomains = [];
            var restrictedDomains = [];
            var parts = domains.split(sep);
            for (var i = 0; i < parts.length; i += 1) {
                var domain = parts[i].toLocaleLowerCase();
                var restricted = false;
                if (domain.startsWith('~')) {
                    restricted = true;
                    domain = domain.substring(1).trim();
                }
                if (domain === '') {
                    throw new SyntaxError("Empty domain specified in \"".concat(domains, "\""));
                }
                if (restricted) {
                    restrictedDomains.push(domain);
                }
                else {
                    permittedDomains.push(domain);
                }
            }
            this.restrictedDomains = restrictedDomains.length > 0 ? restrictedDomains : null;
            this.permittedDomains = permittedDomains.length > 0 ? permittedDomains : null;
        }
        /**
         * isDomainOrSubdomainOfAny checks if `domain` is the same or a subdomain
         * of any of `domains`.
         *
         * @param domain - domain to check
         * @param domains - domains list to check against
         */
        DomainModifier.isDomainOrSubdomainOfAny = function (domain, domains) {
            for (var i = 0; i < domains.length; i += 1) {
                var d = domains[i];
                if (DomainModifier.isWildcardDomain(d)) {
                    if (DomainModifier.matchAsWildcard(d, domain)) {
                        return true;
                    }
                }
                if (domain === d || (domain.endsWith(d) && domain.endsWith(".".concat(d)))) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Checks if domain ends with wildcard
         *
         * @param domain
         */
        DomainModifier.isWildcardDomain = function (domain) {
            return domain.endsWith('.*');
        };
        /**
         * Checks if wildcard matches domain
         *
         * @param wildcard
         * @param domainNameToCheck
         */
        DomainModifier.matchAsWildcard = function (wildcard, domainNameToCheck) {
            var wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
            if (wildcardedDomainToCheck) {
                return wildcardedDomainToCheck === wildcard
                    || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(".".concat(wildcard)));
            }
            return false;
        };
        /**
         * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
         *
         * @param {string} domainName
         * @returns {string} string is empty if tld for provided domain name doesn't exists
         */
        DomainModifier.genTldWildcard = function (domainName) {
            var tld = getPublicSuffix(domainName);
            if (tld) {
                return "".concat(domainName.slice(0, domainName.indexOf(".".concat(tld))), ".*");
            }
            return '';
        };
        return DomainModifier;
    }());
    /**
     * Comma separator
     */
    var COMMA_SEPARATOR = ',';
    /**
     * Pipe separator
     */
    var PIPE_SEPARATOR = '|';

    /**
     * Replace modifier class
     */
    var ReplaceModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function ReplaceModifier(value) {
            var parsed = ReplaceModifier.parseReplaceOption(value);
            this.replaceOption = parsed.optionText;
            this.replaceApply = parsed.apply;
        }
        /**
         *
         * @param option
         */
        ReplaceModifier.parseReplaceOption = function (option) {
            if (!option) {
                return {
                    apply: function (x) { return x; },
                    optionText: '',
                };
            }
            var parts = splitByDelimiterWithEscapeCharacter(option, '/', '\\', true);
            if (parts.length < 2 || parts.length > 3) {
                throw new Error("Cannot parse ".concat(option));
            }
            var modifiers = (parts[2] || '');
            if (modifiers.indexOf('g') < 0) {
                modifiers += 'g';
            }
            var pattern = new RegExp(parts[0], modifiers);
            // unescape replacement alias
            var replacement = parts[1].replace(/\\\$/g, '$');
            var apply = function (input) { return input.replace(pattern, replacement); };
            return {
                apply: apply,
                optionText: option,
            };
        };
        /**
         * Replace content
         */
        ReplaceModifier.prototype.getValue = function () {
            return this.replaceOption;
        };
        /**
         * Replace apply function
         */
        ReplaceModifier.prototype.getApplyFunc = function () {
            return this.replaceApply;
        };
        return ReplaceModifier;
    }());

    /**
     * Csp modifier class
     */
    var CspModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param isAllowlist
         */
        function CspModifier(value, isAllowlist) {
            this.cspDirective = value;
            this.isAllowlist = isAllowlist;
            this.validateCspDirective();
        }
        /**
         * Csp directive
         */
        CspModifier.prototype.getValue = function () {
            return this.cspDirective;
        };
        /**
         * Validates CSP rule
         */
        CspModifier.prototype.validateCspDirective = function () {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
             * CSP directive may be empty in case of allowlist rule,
             * it means to disable all $csp rules matching the allowlist rule
             */
            if (!this.isAllowlist && !this.cspDirective) {
                throw new Error('Invalid $CSP rule: CSP directive must not be empty');
            }
            if (this.cspDirective) {
                /**
                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
                 * Forbids report-to and report-uri directives
                 */
                var cspDirective = this.cspDirective.toLowerCase();
                if (cspDirective.indexOf('report-') >= 0) {
                    throw new Error("Forbidden CSP directive: ".concat(cspDirective));
                }
            }
        };
        return CspModifier;
    }());

    /**
     * Cookie modifier class
     *
     * Learn more about it here:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
     */
    var CookieModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function CookieModifier(value) {
            // Save the source text of the option modifier
            this.optionValue = value || '';
            this.regex = null;
            this.cookieName = null;
            this.sameSite = null;
            this.maxAge = null;
            // Parse cookie name/regex
            var parts = this.optionValue.split(/;/);
            if (parts.length < 1) {
                throw new Error("Cannot parse ".concat(this.optionValue));
            }
            var cookieName = parts[0];
            if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
                var pattern = cookieName.substring(1, cookieName.length - 1);
                // Save regex to be used further for matching cookies
                this.regex = new RegExp(pattern);
            }
            else {
                // Match by cookie name
                this.cookieName = cookieName;
            }
            // Parse other cookie options
            if (parts.length > 1) {
                for (var i = 1; i < parts.length; i += 1) {
                    var nameValue = parts[i].split('=');
                    var optionName = nameValue[0];
                    var optionValue = nameValue[1];
                    if (optionName === CookieModifier.MAX_AGE) {
                        this.maxAge = parseInt(optionValue, 10);
                    }
                    else if (optionName === CookieModifier.SAME_SITE) {
                        this.sameSite = optionValue;
                    }
                    else {
                        throw new Error("Unknown $cookie option: ".concat(optionName));
                    }
                }
            }
        }
        /**
         * Modifier value
         */
        CookieModifier.prototype.getValue = function () {
            return this.optionValue;
        };
        /**
         * First cookie name
         */
        CookieModifier.prototype.getCookieName = function () {
            return this.cookieName;
        };
        /**
         * Max age cookie value
         */
        CookieModifier.prototype.getMaxAge = function () {
            return this.maxAge;
        };
        /**
         * Same site cookie value
         */
        CookieModifier.prototype.getSameSite = function () {
            return this.sameSite;
        };
        /**
         * Checks if cookie with the specified name matches this option
         *
         * @param {string} name Cookie name
         * @return {boolean} true if it does
         */
        CookieModifier.prototype.matches = function (name) {
            if (!name) {
                return false;
            }
            if (this.regex) {
                return this.regex.test(name);
            }
            if (this.cookieName) {
                return this.cookieName === name;
            }
            // Empty regex and cookieName means that we must match all cookies
            return true;
        };
        /**
         * Checks if cookie rule has an empty $cookie option
         *
         * @return {boolean} True if $cookie option is empty
         */
        CookieModifier.prototype.isEmpty = function () {
            return !this.regex && !this.cookieName;
        };
        /**
         * Cookie name maxAge
         */
        CookieModifier.MAX_AGE = 'maxAge';
        /**
         * Cookie name sameSite
         */
        CookieModifier.SAME_SITE = 'sameSite';
        return CookieModifier;
    }());

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
      var f = n.default;
    	if (typeof f == "function") {
    		var a = function () {
    			return f.apply(this, arguments);
    		};
    		a.prototype = f.prototype;
      } else a = {};
      Object.defineProperty(a, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var scriptlets_umd = {exports: {}};

    (function (factory) {
        factory();
    })((function () {
        function attachDependencies(scriptlet) {
          var _scriptlet$injections = scriptlet.injections,
              injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
          return injections.reduce(function (accum, dep) {
            return "".concat(accum, "\n").concat(dep.toString());
          }, scriptlet.toString());
        }
        function addCall(scriptlet, code) {
          return "".concat(code, "\n    const updatedArgs = args ? [].concat(source).concat(args) : [source];\n    try {\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    } catch (e) {\n        console.log(e);\n    }");
        }
        function passSourceAndProps(source, code) {
          var redirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (source.hit) {
            source.hit = source.hit.toString();
          }
          var sourceString = JSON.stringify(source);
          var argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
          var params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
          if (redirect) {
            return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
          }
          return "(".concat(code, ")(").concat(params, ");");
        }
        function wrapInNonameFunc(code) {
          return "function(source, args){\n".concat(code, "\n}");
        }
        var nativeIsNaN = function nativeIsNaN(num) {
          var native = Number.isNaN || window.isNaN;
          return native(num);
        };
        var nativeIsFinite = function nativeIsFinite(num) {
          var native = Number.isFinite || window.isFinite;
          return native(num);
        };
        var getNumberFromString = function getNumberFromString(rawString) {
          var parsedDelay = parseInt(rawString, 10);
          var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
          return validDelay;
        };
        var getObjectEntries = function getObjectEntries(object) {
          var keys = Object.keys(object);
          var entries = [];
          keys.forEach(function (key) {
            return entries.push([key, object[key]]);
          });
          return entries;
        };
        var getObjectFromEntries = function getObjectFromEntries(entries) {
          var output = entries.reduce(function (acc, el) {
            var key = el[0];
            var value = el[1];
            acc[key] = value;
            return acc;
          }, {});
          return output;
        };
        var isEmptyObject = function isEmptyObject(obj) {
          return Object.keys(obj).length === 0;
        };
        var safeGetDescriptor = function safeGetDescriptor(obj, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          if (descriptor && descriptor.configurable) {
            return descriptor;
          }
          return null;
        };
        var replaceAll = function replaceAll(input, substr, newSubstr) {
          return input.split(substr).join(newSubstr);
        };
        var escapeRegExp = function escapeRegExp(str) {
          return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        };
        var toRegExp = function toRegExp() {
          var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var DEFAULT_VALUE = '.?';
          var FORWARD_SLASH = '/';
          if (input === '') {
            return new RegExp(DEFAULT_VALUE);
          }
          if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            return new RegExp(input.slice(1, -1));
          }
          var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          return new RegExp(escaped);
        };
        var isValidStrPattern = function isValidStrPattern(input) {
          var FORWARD_SLASH = '/';
          var str = escapeRegExp(input);
          if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
          }
          var isValid;
          try {
            isValid = new RegExp(str);
            isValid = true;
          } catch (e) {
            isValid = false;
          }
          return isValid;
        };
        var getBeforeRegExp = function getBeforeRegExp(str, rx) {
          var index = str.search(rx);
          return str.substring(0, index);
        };
        var startsWith = function startsWith(str, prefix) {
          return !!str && str.indexOf(prefix) === 0;
        };
        var endsWith = function endsWith(str, ending) {
          return !!str && str.indexOf(ending) === str.length - ending.length;
        };
        var substringAfter$1 = function substringAfter(str, separator) {
          if (!str) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? '' : str.substring(index + separator.length);
        };
        var substringBefore = function substringBefore(str, separator) {
          if (!str || !separator) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? str : str.substring(0, index);
        };
        var wrapInSingleQuotes = function wrapInSingleQuotes(str) {
          if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
            str = str.substring(1, str.length - 1);
          }
          str = str.replace(/\'/g, '"');
          return "'".concat(str, "'");
        };
        var getStringInBraces = function getStringInBraces(str) {
          var firstIndex = str.indexOf('(');
          var lastIndex = str.lastIndexOf(')');
          return str.substring(firstIndex + 1, lastIndex);
        };
        var convertRtcConfigToString = function convertRtcConfigToString(config) {
          var UNDEF_STR = 'undefined';
          var str = UNDEF_STR;
          if (config === null) {
            str = 'null';
          } else if (config instanceof Object) {
            var SERVERS_PROP_NAME = 'iceServers';
            var URLS_PROP_NAME = 'urls';
            if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
              str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
            }
          }
          return str;
        };
        var isValidMatchStr = function isValidMatchStr(match) {
          var INVERT_MARKER = '!';
          var str = match;
          if (startsWith(match, INVERT_MARKER)) {
            str = match.slice(1);
          }
          return isValidStrPattern(str);
        };
        var isValidMatchNumber = function isValidMatchNumber(match) {
          var INVERT_MARKER = '!';
          var str = match;
          if (startsWith(match, INVERT_MARKER)) {
            str = match.slice(1);
          }
          var num = parseFloat(str);
          return !nativeIsNaN(num) && nativeIsFinite(num);
        };
        var parseMatchArg = function parseMatchArg(match) {
          var INVERT_MARKER = '!';
          var isInvertedMatch = startsWith(match, INVERT_MARKER);
          var matchValue = isInvertedMatch ? match.slice(1) : match;
          var matchRegexp = toRegExp(matchValue);
          return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp
          };
        };
        var parseDelayArg = function parseDelayArg(delay) {
          var INVERT_MARKER = '!';
          var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
          var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
          delayValue = parseInt(delayValue, 10);
          var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
          return {
            isInvertedDelayMatch: isInvertedDelayMatch,
            delayMatch: delayMatch
          };
        };
        var objectToString = function objectToString(obj) {
          return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
              recordValueStr = "{ ".concat(objectToString(value), " }");
            }
            return "".concat(key, ":\"").concat(recordValueStr, "\"");
          }).join(' ');
        };
        var convertTypeToString = function convertTypeToString(value) {
          var output;
          if (typeof value === 'undefined') {
            output = 'undefined';
          } else if (typeof value === 'object') {
            if (value === null) {
              output = 'null';
            } else {
              output = objectToString(value);
            }
          } else {
            output = value.toString();
          }
          return output;
        };
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var defineProperty = _defineProperty;
        function iterateWithTransitions(iterable, transitions, init, args) {
          var state = init || Object.keys(transitions)[0];
          for (var i = 0; i < iterable.length; i += 1) {
            state = transitions[state](iterable, i, args);
          }
          return state;
        }
        var ADG_SCRIPTLET_MASK = '#//scriptlet';
        var wordSaver = function wordSaver() {
          var str = '';
          var strs = [];
          var saveSymb = function saveSymb(s) {
            str += s;
            return str;
          };
          var saveStr = function saveStr() {
            strs.push(str);
            str = '';
          };
          var getAll = function getAll() {
            return [].concat(strs);
          };
          return {
            saveSymb: saveSymb,
            saveStr: saveStr,
            getAll: getAll
          };
        };
        var substringAfter = function substringAfter(str, separator) {
          if (!str) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? '' : str.substring(index + separator.length);
        };
        var parseRule = function parseRule(ruleText) {
          var _transitions;
          ruleText = substringAfter(ruleText, ADG_SCRIPTLET_MASK);
          var TRANSITION = {
            OPENED: 'opened',
            PARAM: 'param',
            CLOSED: 'closed'
          };
          var opened = function opened(rule, index, _ref) {
            var sep = _ref.sep;
            var char = rule[index];
            var transition;
            switch (char) {
              case ' ':
              case '(':
              case ',':
                {
                  transition = TRANSITION.OPENED;
                  break;
                }
              case '\'':
              case '"':
                {
                  sep.symb = char;
                  transition = TRANSITION.PARAM;
                  break;
                }
              case ')':
                {
                  transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
                  break;
                }
              default:
                {
                  throw new Error('The rule is not a scriptlet');
                }
            }
            return transition;
          };
          var param = function param(rule, index, _ref2) {
            var saver = _ref2.saver,
                sep = _ref2.sep;
            var char = rule[index];
            switch (char) {
              case '\'':
              case '"':
                {
                  var preIndex = index - 1;
                  var before = rule[preIndex];
                  if (char === sep.symb && before !== '\\') {
                    sep.symb = null;
                    saver.saveStr();
                    return TRANSITION.OPENED;
                  }
                }
              default:
                {
                  saver.saveSymb(char);
                  return TRANSITION.PARAM;
                }
            }
          };
          var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);
          var sep = {
            symb: null
          };
          var saver = wordSaver();
          var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
            sep: sep,
            saver: saver
          });
          if (state !== 'closed') {
            throw new Error("Invalid scriptlet rule ".concat(ruleText));
          }
          var args = saver.getAll();
          return {
            name: args[0],
            args: args.slice(1)
          };
        };
        var getWildcardSymbol = function getWildcardSymbol() {
          return '*';
        };
        function randomId() {
          return Math.random().toString(36).substr(2, 9);
        }
        function setPropertyAccess(object, property, descriptor) {
          var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
          if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
          }
          Object.defineProperty(object, property, descriptor);
          return true;
        }
        function getPropertyInChain(base, chain) {
          var pos = chain.indexOf('.');
          if (pos === -1) {
            return {
              base: base,
              prop: chain
            };
          }
          var prop = chain.slice(0, pos);
          if (base === null) {
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          var nextBase = base[prop];
          chain = chain.slice(pos + 1);
          if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
          }
          Object.defineProperty(base, prop, {
            configurable: true
          });
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        function getWildcardPropertyInChain(base, chain) {
          var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var pos = chain.indexOf('.');
          if (pos === -1) {
            if (chain === getWildcardSymbol() || chain === '[]') {
              for (var key in base) {
                if (Object.prototype.hasOwnProperty.call(base, key)) {
                  output.push({
                    base: base,
                    prop: key
                  });
                }
              }
            } else {
              output.push({
                base: base,
                prop: chain
              });
            }
            return output;
          }
          var prop = chain.slice(0, pos);
          var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === getWildcardSymbol() && base instanceof Object;
          if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            baseKeys.forEach(function (key) {
              var item = base[key];
              getWildcardPropertyInChain(item, nextProp, lookThrough, output);
            });
          }
          var nextBase = base[prop];
          chain = chain.slice(pos + 1);
          if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
          }
          return output;
        }
        function createOnErrorHandler(rid) {
          var nativeOnError = window.onerror;
          return function onError(error) {
            if (typeof error === 'string' && error.indexOf(rid) !== -1) {
              return true;
            }
            if (nativeOnError instanceof Function) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeOnError.apply(this, [error].concat(args));
            }
            return false;
          };
        }
        var noopFunc = function noopFunc() {};
        var noopNull = function noopNull() {
          return null;
        };
        var trueFunc = function trueFunc() {
          return true;
        };
        var falseFunc = function falseFunc() {
          return false;
        };
        function noopThis() {
          return this;
        }
        var noopStr = function noopStr() {
          return '';
        };
        var noopArray = function noopArray() {
          return [];
        };
        var noopObject = function noopObject() {
          return {};
        };
        var noopPromiseReject = function noopPromiseReject() {
          return Promise.reject();
        };
        var noopPromiseResolve = function noopPromiseResolve() {
          var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';
          if (typeof Response === 'undefined') {
            return;
          }
          var response = new Response(responseBody, {
            status: 200,
            statusText: 'OK'
          });
          return Promise.resolve(response);
        };
        var hit = function hit(source, message) {
          if (source.verbose !== true) {
            return;
          }
          try {
            var log = console.log.bind(console);
            var trace = console.trace.bind(console);
            var prefix = source.ruleText || '';
            if (source.domainName) {
              var AG_SCRIPTLET_MARKER = '#%#//';
              var UBO_SCRIPTLET_MARKER = '##+js';
              var ruleStartIndex;
              if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
              } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
              }
              var rulePart = source.ruleText.slice(ruleStartIndex);
              prefix = "".concat(source.domainName).concat(rulePart);
            }
            var LOG_MARKER = 'log: ';
            if (message) {
              if (message.indexOf(LOG_MARKER) === -1) {
                log("".concat(prefix, " message:\n").concat(message));
              } else {
                log(message.slice(LOG_MARKER.length));
              }
            }
            log("".concat(prefix, " trace start"));
            if (trace) {
              trace();
            }
            log("".concat(prefix, " trace end"));
          } catch (e) {
          }
          if (typeof window.__debug === 'function') {
            window.__debug(source);
          }
        };
        var observeDOMChanges = function observeDOMChanges(callback) {
          var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var throttle = function throttle(method, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              method.apply(void 0, args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          };
          var THROTTLE_DELAY_MS = 20;
          var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
          var connect = function connect() {
            if (attrsToObserve.length > 0) {
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: observeAttrs,
                attributeFilter: attrsToObserve
              });
            } else {
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: observeAttrs
              });
            }
          };
          var disconnect = function disconnect() {
            observer.disconnect();
          };
          function callbackWrapper() {
            disconnect();
            callback();
            connect();
          }
          connect();
        };
        var getNativeRegexpTest = function getNativeRegexpTest() {
          return Object.getOwnPropertyDescriptor(RegExp.prototype, 'test').value;
        };
        var matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {
          if (!stackMatch || stackMatch === '') {
            return true;
          }
          var stackRegexp = toRegExp(stackMatch);
          var refinedStackTrace = stackTrace.split('\n').slice(2)
          .map(function (line) {
            return line.trim();
          })
          .join('\n');
          return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
        };
        var flatten = function flatten(input) {
          var stack = [];
          input.forEach(function (el) {
            return stack.push(el);
          });
          var res = [];
          while (stack.length) {
            var next = stack.pop();
            if (Array.isArray(next)) {
              next.forEach(function (el) {
                return stack.push(el);
              });
            } else {
              res.push(next);
            }
          }
          return res.reverse();
        };
        var isExisting = function isExisting(item) {
          return !!item;
        };
        var findHostElements = function findHostElements(rootElement) {
          var hosts = [];
          var domElems = rootElement.querySelectorAll('*');
          domElems.forEach(function (el) {
            if (el.shadowRoot) {
              hosts.push(el);
            }
          });
          return hosts;
        };
        var pierceShadowDom = function pierceShadowDom(selector, hostElements) {
          var targets = [];
          var innerHostsAcc = [];
          hostElements.forEach(function (host) {
            var simpleElems = host.querySelectorAll(selector);
            targets = targets.concat([].slice.call(simpleElems));
            var shadowRootElem = host.shadowRoot;
            var shadowChildren = shadowRootElem.querySelectorAll(selector);
            targets = targets.concat([].slice.call(shadowChildren));
            innerHostsAcc.push(findHostElements(shadowRootElem));
          });
          var innerHosts = flatten(innerHostsAcc);
          return {
            targets: targets,
            innerHosts: innerHosts
          };
        };
        var prepareCookie = function prepareCookie(name, value) {
          if (!name || !value) {
            return null;
          }
          var valueToSet;
          if (value === 'true') {
            valueToSet = 'true';
          } else if (value === 'True') {
            valueToSet = 'True';
          } else if (value === 'false') {
            valueToSet = 'false';
          } else if (value === 'False') {
            valueToSet = 'False';
          } else if (value === 'yes') {
            valueToSet = 'yes';
          } else if (value === 'Yes') {
            valueToSet = 'Yes';
          } else if (value === 'Y') {
            valueToSet = 'Y';
          } else if (value === 'no') {
            valueToSet = 'no';
          } else if (value === 'ok') {
            valueToSet = 'ok';
          } else if (value === 'OK') {
            valueToSet = 'OK';
          } else if (/^\d+$/.test(value)) {
            valueToSet = parseFloat(value);
            if (nativeIsNaN(valueToSet)) {
              return null;
            }
            if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {
              return null;
            }
          } else {
            return null;
          }
          var pathToSet = 'path=/;';
          var cookieData = "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(valueToSet), "; ").concat(pathToSet);
          return cookieData;
        };
        var shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {
          return delay === getWildcardSymbol();
        };
        var getMatchDelay = function getMatchDelay(delay) {
          var DEFAULT_DELAY = 1000;
          var parsedDelay = parseInt(delay, 10);
          var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY
          : parsedDelay;
          return delayMatch;
        };
        var isDelayMatched = function isDelayMatched(inputDelay, realDelay) {
          return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
        };
        var getBoostMultiplier = function getBoostMultiplier(boost) {
          var DEFAULT_MULTIPLIER = 0.05;
          var MIN_MULTIPLIER = 0.02;
          var MAX_MULTIPLIER = 50;
          var parsedBoost = parseFloat(boost);
          var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER
          : parsedBoost;
          if (boostMultiplier < MIN_MULTIPLIER) {
            boostMultiplier = MIN_MULTIPLIER;
          }
          if (boostMultiplier > MAX_MULTIPLIER) {
            boostMultiplier = MAX_MULTIPLIER;
          }
          return boostMultiplier;
        };
        var getRequestData = function getRequestData(request) {
          var REQUEST_INIT_OPTIONS = ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'integrity'];
          var entries = REQUEST_INIT_OPTIONS.map(function (key) {
            var value = request[key];
            return [key, value];
          });
          return getObjectFromEntries(entries);
        };
        var getFetchData = function getFetchData(args) {
          var fetchPropsObj = {};
          var fetchUrl;
          var fetchInit;
          if (args[0] instanceof Request) {
            var requestData = getRequestData(args[0]);
            fetchUrl = requestData.url;
            fetchInit = requestData;
          } else {
            fetchUrl = args[0];
            fetchInit = args[1];
          }
          fetchPropsObj.url = fetchUrl;
          if (fetchInit instanceof Object) {
            Object.keys(fetchInit).forEach(function (prop) {
              fetchPropsObj[prop] = fetchInit[prop];
            });
          }
          return fetchPropsObj;
        };
        var parseMatchProps = function parseMatchProps(propsToMatchStr) {
          var PROPS_DIVIDER = ' ';
          var PAIRS_MARKER = ':';
          var propsObj = {};
          var props = propsToMatchStr.split(PROPS_DIVIDER);
          props.forEach(function (prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            if (dividerInd === -1) {
              propsObj.url = prop;
            } else {
              var key = prop.slice(0, dividerInd);
              var value = prop.slice(dividerInd + 1);
              propsObj[key] = value;
            }
          });
          return propsObj;
        };
        var validateParsedData = function validateParsedData(data) {
          return Object.values(data).every(function (value) {
            return isValidStrPattern(value);
          });
        };
        var getMatchPropsData = function getMatchPropsData(data) {
          var matchData = {};
          Object.keys(data).forEach(function (key) {
            matchData[key] = toRegExp(data[key]);
          });
          return matchData;
        };
        var handleOldReplacement = function handleOldReplacement(replacement) {
          var result;
          if (!replacement) {
            result = noopFunc;
          } else if (replacement === 'trueFunc') {
            result = trueFunc;
          } else if (replacement.indexOf('=') > -1) {
            var isProp = startsWith(replacement, '{') && endsWith(replacement, '}');
            if (isProp) {
              var propertyPart = replacement.slice(1, -1);
              var propertyName = substringBefore(propertyPart, '=');
              var propertyValue = substringAfter$1(propertyPart, '=');
              if (propertyValue === 'noopFunc') {
                result = {};
                result[propertyName] = noopFunc;
              }
            }
          }
          return result;
        };
        var createDecoy = function createDecoy(args) {
          var OBJECT_TAG_NAME = 'object';
          var OBJECT_URL_PROP_NAME = 'data';
          var IFRAME_TAG_NAME = 'iframe';
          var IFRAME_URL_PROP_NAME = 'src';
          var replacement = args.replacement,
              url = args.url,
              delay = args.delay;
          var tag;
          var urlProp;
          if (replacement === 'obj') {
            tag = OBJECT_TAG_NAME;
            urlProp = OBJECT_URL_PROP_NAME;
          } else {
            tag = IFRAME_TAG_NAME;
            urlProp = IFRAME_URL_PROP_NAME;
          }
          var decoy = document.createElement(tag);
          decoy[urlProp] = url;
          decoy.style.setProperty('height', '1px', 'important');
          decoy.style.setProperty('position', 'fixed', 'important');
          decoy.style.setProperty('top', '-1px', 'important');
          decoy.style.setProperty('width', '1px', 'important');
          document.body.appendChild(decoy);
          setTimeout(function () {
            return decoy.remove();
          }, delay * 1000);
          return decoy;
        };
        var getPreventGetter = function getPreventGetter(nativeGetter) {
          var preventGetter = function preventGetter(target, prop) {
            if (prop && prop === 'closed') {
              return false;
            }
            if (typeof nativeGetter === 'function') {
              return noopFunc;
            }
            return prop && target[prop];
          };
          return preventGetter;
        };
        var validateType = function validateType(type) {
          return typeof type !== 'undefined';
        };
        var validateListener = function validateListener(listener) {
          return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object'
          && listener !== null && typeof listener.handleEvent === 'function');
        };
        var listenerToString = function listenerToString(listener) {
          return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();
        };
        var isValidCallback = function isValidCallback(callback) {
          return callback instanceof Function
          || typeof callback === 'string';
        };
        var isPreventionNeeded = function isPreventionNeeded(_ref) {
          var callback = _ref.callback,
              delay = _ref.delay,
              matchCallback = _ref.matchCallback,
              matchDelay = _ref.matchDelay;
          if (!isValidCallback(callback)) {
            return false;
          }
          if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
            return false;
          }
          var _parseMatchArg = parseMatchArg(matchCallback),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
          var _parseDelayArg = parseDelayArg(matchDelay),
              isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
              delayMatch = _parseDelayArg.delayMatch;
          var shouldPrevent = false;
          var callbackStr = String(callback);
          if (delayMatch === null) {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
          } else if (!matchCallback) {
            shouldPrevent = delay === delayMatch !== isInvertedDelayMatch;
          } else {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && delay === delayMatch !== isInvertedDelayMatch;
          }
          return shouldPrevent;
        };
        function getRandomIntInclusive(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1) + min);
        }
        function getRandomStrByLength(length) {
          var result = '';
          var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~';
          var charactersLength = characters.length;
          for (var i = 0; i < length; i += 1) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
          }
          return result;
        }
        function generateRandomResponse(customResponseText) {
          var customResponse = customResponseText;
          if (customResponse === 'true') {
            customResponse = Math.random().toString(36).slice(-10);
            return customResponse;
          }
          customResponse = customResponse.replace('length:', '');
          var rangeRegex = /^\d+-\d+$/;
          if (!rangeRegex.test(customResponse)) {
            return null;
          }
          var rangeMin = getNumberFromString(customResponse.split('-')[0]);
          var rangeMax = getNumberFromString(customResponse.split('-')[1]);
          if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
            return null;
          }
          if (rangeMin > rangeMax) {
            var temp = rangeMin;
            rangeMin = rangeMax;
            rangeMax = temp;
          }
          var LENGTH_RANGE_LIMIT = 500 * 1000;
          if (rangeMax > LENGTH_RANGE_LIMIT) {
            return null;
          }
          var length = getRandomIntInclusive(rangeMin, rangeMax);
          customResponse = getRandomStrByLength(length);
          return customResponse;
        }
        function getDescriptorAddon() {
          return {
            isAbortingSuspended: false,
            isolateCallback: function isolateCallback(cb) {
              this.isAbortingSuspended = true;
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              var result = cb.apply(void 0, args);
              this.isAbortingSuspended = false;
              return result;
            }
          };
        }
        var parseFlags = function parseFlags(flags) {
          var FLAGS_DIVIDER = ' ';
          var ASAP_FLAG = 'asap';
          var COMPLETE_FLAG = 'complete';
          var STAY_FLAG = 'stay';
          var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
          var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
            return VALID_FLAGS.indexOf(f) !== -1;
          });
          return {
            ASAP: ASAP_FLAG,
            COMPLETE: COMPLETE_FLAG,
            STAY: STAY_FLAG,
            hasFlag: function hasFlag(flag) {
              return passedFlags.indexOf(flag) !== -1;
            }
          };
        };
        function abortOnPropertyRead$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              get: abort,
              set: function set() {}
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnPropertyRead$1.names = ['abort-on-property-read',
        'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
        abortOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];
        function abortOnPropertyWrite$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              set: abort
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnPropertyWrite$1.names = ['abort-on-property-write',
        'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
        abortOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];
        function preventSetTimeout$1(source, matchCallback, matchDelay) {
          var isProxySupported = typeof Proxy !== 'undefined';
          var nativeTimeout = window.setTimeout;
          var log = console.log.bind(console);
          var shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
          var legacyTimeoutWrapper = function legacyTimeoutWrapper(callback, delay) {
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              log("setTimeout(".concat(String(callback), ", ").concat(delay, ")"));
            } else {
              shouldPrevent = isPreventionNeeded({
                callback: callback,
                delay: delay,
                matchCallback: matchCallback,
                matchDelay: matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              return nativeTimeout(noopFunc, delay);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeTimeout.apply(window, [callback, delay].concat(args));
          };
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              log("setTimeout(".concat(String(callback), ", ").concat(delay, ")"));
            } else {
              shouldPrevent = isPreventionNeeded({
                callback: callback,
                delay: delay,
                matchCallback: matchCallback,
                matchDelay: matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
          };
          var setTimeoutHandler = {
            apply: handlerWrapper
          };
          window.setTimeout = isProxySupported ? new Proxy(window.setTimeout, setTimeoutHandler) : legacyTimeoutWrapper;
        }
        preventSetTimeout$1.names = ['prevent-setTimeout',
        'no-setTimeout-if.js',
        'ubo-no-setTimeout-if.js', 'nostif.js',
        'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif',
        'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];
        preventSetTimeout$1.injections = [hit, noopFunc, isPreventionNeeded,
        parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN, isValidCallback, isValidMatchStr, escapeRegExp, isValidStrPattern, nativeIsFinite, isValidMatchNumber];
        function preventSetInterval$1(source, matchCallback, matchDelay) {
          var isProxySupported = typeof Proxy !== 'undefined';
          var nativeInterval = window.setInterval;
          var log = console.log.bind(console);
          var shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
          var legacyIntervalWrapper = function legacyIntervalWrapper(callback, delay) {
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              log("setInterval(".concat(String(callback), ", ").concat(delay, ")"));
            } else {
              shouldPrevent = isPreventionNeeded({
                callback: callback,
                delay: delay,
                matchCallback: matchCallback,
                matchDelay: matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              return nativeInterval(noopFunc, delay);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeInterval.apply(window, [callback, delay].concat(args));
          };
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              log("setInterval(".concat(String(callback), ", ").concat(delay, ")"));
            } else {
              shouldPrevent = isPreventionNeeded({
                callback: callback,
                delay: delay,
                matchCallback: matchCallback,
                matchDelay: matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
          };
          var setIntervalHandler = {
            apply: handlerWrapper
          };
          window.setInterval = isProxySupported ? new Proxy(window.setInterval, setIntervalHandler) : legacyIntervalWrapper;
        }
        preventSetInterval$1.names = ['prevent-setInterval',
        'no-setInterval-if.js',
        'ubo-no-setInterval-if.js', 'setInterval-defuser.js',
        'ubo-setInterval-defuser.js', 'nosiif.js',
        'ubo-nosiif.js', 'sid.js',
        'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
        preventSetInterval$1.injections = [hit, noopFunc, isPreventionNeeded,
        toRegExp, startsWith, nativeIsNaN, parseMatchArg, parseDelayArg, isValidCallback, isValidMatchStr, isValidStrPattern, escapeRegExp, nativeIsFinite, isValidMatchNumber];
        function preventWindowOpen$1(source) {
          var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getWildcardSymbol();
          var delay = arguments.length > 2 ? arguments[2] : undefined;
          var replacement = arguments.length > 3 ? arguments[3] : undefined;
          var nativeOpen = window.open;
          var isNewSyntax = match !== '0' && match !== '1';
          var oldOpenWrapper = function oldOpenWrapper(str) {
            match = Number(match) > 0;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (!isValidStrPattern(delay)) {
              console.log("Invalid parameter: ".concat(delay));
              return nativeOpen.apply(window, [str].concat(args));
            }
            var searchRegexp = toRegExp(delay);
            if (match !== searchRegexp.test(str)) {
              return nativeOpen.apply(window, [str].concat(args));
            }
            hit(source);
            return handleOldReplacement(replacement);
          };
          var newOpenWrapper = function newOpenWrapper(url) {
            var shouldLog = replacement && replacement.indexOf('log') > -1;
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            if (shouldLog) {
              var argsStr = args && args.length > 0 ? ", ".concat(args.join(', ')) : '';
              var logMessage = "log: window-open: ".concat(url).concat(argsStr);
              hit(source, logMessage);
            }
            var shouldPrevent = false;
            if (match === getWildcardSymbol()) {
              shouldPrevent = true;
            } else if (isValidMatchStr(match)) {
              var _parseMatchArg = parseMatchArg(match),
                  isInvertedMatch = _parseMatchArg.isInvertedMatch,
                  matchRegexp = _parseMatchArg.matchRegexp;
              shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
            } else {
              console.log("Invalid parameter: ".concat(match));
              shouldPrevent = false;
            }
            if (shouldPrevent) {
              var parsedDelay = parseInt(delay, 10);
              var result;
              if (nativeIsNaN(parsedDelay)) {
                result = noopNull();
              } else {
                var decoyArgs = {
                  replacement: replacement,
                  url: url,
                  delay: parsedDelay
                };
                var decoy = createDecoy(decoyArgs);
                var popup = decoy.contentWindow;
                if (typeof popup === 'object' && popup !== null) {
                  Object.defineProperty(popup, 'closed', {
                    value: false
                  });
                  Object.defineProperty(popup, 'opener', {
                    value: window
                  });
                  Object.defineProperty(popup, 'frameElement', {
                    value: null
                  });
                } else {
                  var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                  Object.defineProperty(decoy, 'contentWindow', {
                    get: getPreventGetter(nativeGetter)
                  });
                  popup = decoy.contentWindow;
                }
                result = popup;
              }
              hit(source);
              return result;
            }
            return nativeOpen.apply(window, [url].concat(args));
          };
          window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
          window.open.toString = nativeOpen.toString.bind(nativeOpen);
        }
        preventWindowOpen$1.names = ['prevent-window-open',
        'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];
        preventWindowOpen$1.injections = [hit, isValidStrPattern, escapeRegExp, isValidMatchStr, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, getWildcardSymbol, noopFunc, trueFunc, startsWith, endsWith, substringBefore, substringAfter$1];
        function abortCurrentInlineScript$1(source, property, search) {
          var searchRegexp = toRegExp(search);
          var rid = randomId();
          var SRC_DATA_MARKER = 'data:text/javascript;base64,';
          var getCurrentScript = function getCurrentScript() {
            if ('currentScript' in document) {
              return document.currentScript;
            }
            var scripts = document.getElementsByTagName('script');
            return scripts[scripts.length - 1];
          };
          var ourScript = getCurrentScript();
          var abort = function abort() {
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
              return;
            }
            var content = scriptEl.textContent;
            try {
              var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
              content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (content.length === 0 && typeof scriptEl.src !== 'undefined' && startsWith(scriptEl.src, SRC_DATA_MARKER)) {
              var encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
              content = window.atob(encodedContent);
            }
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
              hit(source);
              throw new ReferenceError(rid);
            }
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (base instanceof Object === false && base === null) {
              var props = property.split('.');
              var propIndex = props.indexOf(prop);
              var baseName = props[propIndex - 1];
              console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded."));
              return;
            }
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var currentValue = base[prop];
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
              currentValue = base[prop];
              origDescriptor = undefined;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
              currentValue: currentValue,
              get: function get() {
                if (!this.isAbortingSuspended) {
                  this.isolateCallback(abort);
                }
                if (origDescriptor instanceof Object) {
                  return origDescriptor.get.call(base);
                }
                return this.currentValue;
              },
              set: function set(newValue) {
                if (!this.isAbortingSuspended) {
                  this.isolateCallback(abort);
                }
                if (origDescriptor instanceof Object) {
                  origDescriptor.set.call(base, newValue);
                } else {
                  this.currentValue = newValue;
                }
              }
            });
            setPropertyAccess(base, prop, {
              get: function get() {
                return descriptorWrapper.get.call(descriptorWrapper);
              },
              set: function set(newValue) {
                descriptorWrapper.set.call(descriptorWrapper, newValue);
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortCurrentInlineScript$1.names = ['abort-current-inline-script',
        'abort-current-script.js', 'ubo-abort-current-script.js', 'acs.js', 'ubo-acs.js',
        'ubo-abort-current-script', 'ubo-acs',
        'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
        abortCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, startsWith, createOnErrorHandler, hit, getDescriptorAddon];
        function setConstant$1(source, property, value, stack) {
          if (!property || !matchStackTrace(stack, new Error().stack)) {
            return;
          }
          var log = console.log.bind(console);
          var emptyArr = noopArray();
          var emptyObj = noopObject();
          var constantValue;
          if (value === 'undefined') {
            constantValue = undefined;
          } else if (value === 'false') {
            constantValue = false;
          } else if (value === 'true') {
            constantValue = true;
          } else if (value === 'null') {
            constantValue = null;
          } else if (value === 'emptyArr') {
            constantValue = emptyArr;
          } else if (value === 'emptyObj') {
            constantValue = emptyObj;
          } else if (value === 'noopFunc') {
            constantValue = noopFunc;
          } else if (value === 'trueFunc') {
            constantValue = trueFunc;
          } else if (value === 'falseFunc') {
            constantValue = falseFunc;
          } else if (value === 'noopPromiseResolve') {
            constantValue = noopPromiseResolve;
          } else if (value === 'noopPromiseReject') {
            constantValue = noopPromiseReject;
          } else if (/^\d+$/.test(value)) {
            constantValue = parseFloat(value);
            if (nativeIsNaN(constantValue)) {
              return;
            }
            if (Math.abs(constantValue) > 0x7FFF) {
              return;
            }
          } else if (value === '-1') {
            constantValue = -1;
          } else if (value === '') {
            constantValue = '';
          } else if (value === 'yes') {
            constantValue = 'yes';
          } else if (value === 'no') {
            constantValue = 'no';
          } else {
            return;
          }
          var canceled = false;
          var mustCancel = function mustCancel(value) {
            if (canceled) {
              return canceled;
            }
            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;
            return canceled;
          };
          var trapProp = function trapProp(base, prop, configurable, handler) {
            if (!handler.init(base[prop])) {
              return false;
            }
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            var prevSetter;
            if (origDescriptor instanceof Object) {
              if (!origDescriptor.configurable) {
                if (source.verbose) {
                  log("set-constant: property '".concat(prop, "' is not configurable"));
                }
                return false;
              }
              base[prop] = constantValue;
              if (origDescriptor.set instanceof Function) {
                prevSetter = origDescriptor.set;
              }
            }
            Object.defineProperty(base, prop, {
              configurable: configurable,
              get: function get() {
                return handler.get();
              },
              set: function set(a) {
                if (prevSetter !== undefined) {
                  prevSetter(a);
                }
                handler.set(a);
              }
            });
            return true;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            var undefPropHandler = {
              factValue: undefined,
              init: function init(a) {
                this.factValue = a;
                return true;
              },
              get: function get() {
                return this.factValue;
              },
              set: function set(a) {
                if (this.factValue === a) {
                  return;
                }
                this.factValue = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              }
            };
            var endPropHandler = {
              init: function init(a) {
                if (mustCancel(a)) {
                  return false;
                }
                return true;
              },
              get: function get() {
                return constantValue;
              },
              set: function set(a) {
                if (!mustCancel(a)) {
                  return;
                }
                constantValue = a;
              }
            };
            if (!chain) {
              var isTrapped = trapProp(base, prop, false, endPropHandler);
              if (isTrapped) {
                hit(source);
              }
              return;
            }
            var propValue = owner[prop];
            if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
              setChainPropAccess(propValue, chain);
            }
            trapProp(base, prop, true, undefPropHandler);
          };
          setChainPropAccess(window, property);
        }
        setConstant$1.names = ['set-constant',
        'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];
        setConstant$1.injections = [hit, noopArray, noopObject, noopFunc, trueFunc, falseFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, getNativeRegexpTest];
        function removeCookie$1(source, match) {
          var matchRegexp = toRegExp(match);
          var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
            var cookieSpec = "".concat(cookieName, "=");
            var domain1 = "; domain=".concat(hostName);
            var domain2 = "; domain=.".concat(hostName);
            var path = '; path=/';
            var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
            document.cookie = cookieSpec + expiration;
            document.cookie = cookieSpec + domain1 + expiration;
            document.cookie = cookieSpec + domain2 + expiration;
            document.cookie = cookieSpec + path + expiration;
            document.cookie = cookieSpec + domain1 + path + expiration;
            document.cookie = cookieSpec + domain2 + path + expiration;
            hit(source);
          };
          var rmCookie = function rmCookie() {
            document.cookie.split(';').forEach(function (cookieStr) {
              var pos = cookieStr.indexOf('=');
              if (pos === -1) {
                return;
              }
              var cookieName = cookieStr.slice(0, pos).trim();
              if (!matchRegexp.test(cookieName)) {
                return;
              }
              var hostParts = document.location.hostname.split('.');
              for (var i = 0; i <= hostParts.length - 1; i += 1) {
                var hostName = hostParts.slice(i).join('.');
                if (hostName) {
                  removeCookieFromHost(cookieName, hostName);
                }
              }
            });
          };
          rmCookie();
          window.addEventListener('beforeunload', rmCookie);
        }
        removeCookie$1.names = ['remove-cookie',
        'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];
        removeCookie$1.injections = [toRegExp, hit];
        function preventAddEventListener$1(source, typeSearch, listenerSearch) {
          var typeSearchRegexp = toRegExp(typeSearch);
          var listenerSearchRegexp = toRegExp(listenerSearch);
          var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
          function addEventListenerWrapper(type, listener) {
            var shouldPrevent = false;
            if (validateType(type) && validateListener(listener)) {
              shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
            }
            if (shouldPrevent) {
              hit(source);
              return undefined;
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(this, [type, listener].concat(args));
          }
          window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
          window.addEventListener = addEventListenerWrapper;
          document.addEventListener = addEventListenerWrapper;
        }
        preventAddEventListener$1.names = ['prevent-addEventListener',
        'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];
        preventAddEventListener$1.injections = [hit, toRegExp, validateType, validateListener, listenerToString];
        function preventBab$1(source) {
          var nativeSetTimeout = window.setTimeout;
          var babRegex = /\.bab_elementid.$/;
          var timeoutWrapper = function timeoutWrapper(callback) {
            if (typeof callback !== 'string' || !babRegex.test(callback)) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeSetTimeout.apply(window, [callback].concat(args));
            }
            hit(source);
          };
          window.setTimeout = timeoutWrapper;
          var signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];
          var check = function check(str) {
            if (typeof str !== 'string') {
              return false;
            }
            for (var i = 0; i < signatures.length; i += 1) {
              var tokens = signatures[i];
              var match = 0;
              for (var j = 0; j < tokens.length; j += 1) {
                var token = tokens[j];
                var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
                if (found) {
                  match += 1;
                }
              }
              if (match / tokens.length >= 0.8) {
                return true;
              }
            }
            return false;
          };
          var nativeEval = window.eval;
          var evalWrapper = function evalWrapper(str) {
            if (!check(str)) {
              return nativeEval(str);
            }
            hit(source);
            var bodyEl = document.body;
            if (bodyEl) {
              bodyEl.style.removeProperty('visibility');
            }
            var el = document.getElementById('babasbmsgx');
            if (el) {
              el.parentNode.removeChild(el);
            }
          };
          window.eval = evalWrapper.bind(window);
        }
        preventBab$1.names = ['prevent-bab',
        'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];
        preventBab$1.injections = [hit];
        function nowebrtc$1(source) {
          var propertyName = '';
          if (window.RTCPeerConnection) {
            propertyName = 'RTCPeerConnection';
          } else if (window.webkitRTCPeerConnection) {
            propertyName = 'webkitRTCPeerConnection';
          }
          if (propertyName === '') {
            return;
          }
          var rtcReplacement = function rtcReplacement(config) {
            hit(source, "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config)));
          };
          rtcReplacement.prototype = {
            close: noopFunc,
            createDataChannel: noopFunc,
            createOffer: noopFunc,
            setRemoteDescription: noopFunc
          };
          var rtc = window[propertyName];
          window[propertyName] = rtcReplacement;
          if (rtc.prototype) {
            rtc.prototype.createDataChannel = function (a, b) {
              return {
                close: noopFunc,
                send: noopFunc
              };
            }.bind(null);
          }
        }
        nowebrtc$1.names = ['nowebrtc',
        'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
        nowebrtc$1.injections = [hit, noopFunc, convertRtcConfigToString];
        function logAddEventListener$1(source) {
          var log = console.log.bind(console);
          var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
          function addEventListenerWrapper(type, listener) {
            if (validateType(type) && validateListener(listener)) {
              var logMessage = "addEventListener(\"".concat(type, "\", ").concat(listenerToString(listener), ")");
              log(logMessage);
              hit(source);
            } else if (source.verbose) {
              var _logMessage = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
              log(_logMessage);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(this, [type, listener].concat(args));
          }
          window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
        }
        logAddEventListener$1.names = ['log-addEventListener',
        'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
        logAddEventListener$1.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, objectToString, isEmptyObject, getObjectEntries];
        function logEval$1(source) {
          var log = console.log.bind(console);
          var nativeEval = window.eval;
          function evalWrapper(str) {
            hit(source);
            log("eval(\"".concat(str, "\")"));
            return nativeEval(str);
          }
          window.eval = evalWrapper;
          var nativeFunction = window.Function;
          function FunctionWrapper() {
            hit(source);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            log("new Function(".concat(args.join(', '), ")"));
            return nativeFunction.apply(this, [].concat(args));
          }
          FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
          FunctionWrapper.prototype.constructor = FunctionWrapper;
          window.Function = FunctionWrapper;
        }
        logEval$1.names = ['log-eval'];
        logEval$1.injections = [hit];
        function log$1() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          console.log(args);
        }
        log$1.names = ['log'];
        function noeval$1(source) {
          window.eval = function evalWrapper(s) {
            hit(source, "AdGuard has prevented eval:\n".concat(s));
          }.bind();
        }
        noeval$1.names = ['noeval',
        'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
        noeval$1.injections = [hit];
        function preventEvalIf$1(source, search) {
          var searchRegexp = toRegExp(search);
          var nativeEval = window.eval;
          window.eval = function (payload) {
            if (!searchRegexp.test(payload.toString())) {
              return nativeEval.call(window, payload);
            }
            hit(source, payload);
            return undefined;
          }.bind(window);
        }
        preventEvalIf$1.names = ['prevent-eval-if',
        'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
        preventEvalIf$1.injections = [toRegExp, hit];
        function preventFab$1(source) {
          hit(source);
          var Fab = function Fab() {};
          Fab.prototype.check = noopFunc;
          Fab.prototype.clearEvent = noopFunc;
          Fab.prototype.emitEvent = noopFunc;
          Fab.prototype.on = function (a, b) {
            if (!a) {
              b();
            }
            return this;
          };
          Fab.prototype.onDetected = noopThis;
          Fab.prototype.onNotDetected = function (a) {
            a();
            return this;
          };
          Fab.prototype.setOption = noopFunc;
          Fab.prototype.options = {
            set: noopFunc,
            get: noopFunc
          };
          var fab = new Fab();
          var getSetFab = {
            get: function get() {
              return Fab;
            },
            set: function set() {}
          };
          var getsetfab = {
            get: function get() {
              return fab;
            },
            set: function set() {}
          };
          if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
            window.FuckAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'FuckAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
            window.BlockAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'BlockAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
            window.SniffAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'SniffAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
            window.fuckAdBlock = fab;
          } else {
            Object.defineProperty(window, 'fuckAdBlock', getsetfab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
            window.blockAdBlock = fab;
          } else {
            Object.defineProperty(window, 'blockAdBlock', getsetfab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
            window.sniffAdBlock = fab;
          } else {
            Object.defineProperty(window, 'sniffAdBlock', getsetfab);
          }
        }
        preventFab$1.names = ['prevent-fab-3.2.0',
        'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
        preventFab$1.injections = [hit, noopFunc, noopThis];
        function setPopadsDummy$1(source) {
          delete window.PopAds;
          delete window.popns;
          Object.defineProperties(window, {
            PopAds: {
              get: function get() {
                hit(source);
                return {};
              }
            },
            popns: {
              get: function get() {
                hit(source);
                return {};
              }
            }
          });
        }
        setPopadsDummy$1.names = ['set-popads-dummy',
        'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
        setPopadsDummy$1.injections = [hit];
        function preventPopadsNet$1(source) {
          var rid = randomId();
          var throwError = function throwError() {
            throw new ReferenceError(rid);
          };
          delete window.PopAds;
          delete window.popns;
          Object.defineProperties(window, {
            PopAds: {
              set: throwError
            },
            popns: {
              set: throwError
            }
          });
          window.onerror = createOnErrorHandler(rid).bind();
          hit(source);
        }
        preventPopadsNet$1.names = ['prevent-popads-net',
        'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
        preventPopadsNet$1.injections = [createOnErrorHandler, randomId, hit];
        function preventAdfly$1(source) {
          var isDigit = function isDigit(data) {
            return /^\d$/.test(data);
          };
          var handler = function handler(encodedURL) {
            var evenChars = '';
            var oddChars = '';
            for (var i = 0; i < encodedURL.length; i += 1) {
              if (i % 2 === 0) {
                evenChars += encodedURL.charAt(i);
              } else {
                oddChars = encodedURL.charAt(i) + oddChars;
              }
            }
            var data = (evenChars + oddChars).split('');
            for (var _i = 0; _i < data.length; _i += 1) {
              if (isDigit(data[_i])) {
                for (var ii = _i + 1; ii < data.length; ii += 1) {
                  if (isDigit(data[ii])) {
                    var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);
                    if (temp < 10) {
                      data[_i] = temp.toString();
                    }
                    _i = ii;
                    break;
                  }
                }
              }
            }
            data = data.join('');
            var decodedURL = window.atob(data).slice(16, -16);
            if (window.stop) {
              window.stop();
            }
            window.onbeforeunload = null;
            window.location.href = decodedURL;
          };
          var val;
          var applyHandler = true;
          var result = setPropertyAccess(window, 'ysmm', {
            configurable: false,
            set: function set(value) {
              if (applyHandler) {
                applyHandler = false;
                try {
                  if (typeof value === 'string') {
                    handler(value);
                  }
                } catch (err) {}
              }
              val = value;
            },
            get: function get() {
              return val;
            }
          });
          if (result) {
            hit(source);
          } else {
            window.console.error('Failed to set up prevent-adfly scriptlet');
          }
        }
        preventAdfly$1.names = ['prevent-adfly',
        'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
        preventAdfly$1.injections = [setPropertyAccess, hit];
        function debugOnPropertyRead$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            debugger;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              get: abort,
              set: noopFunc
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugOnPropertyRead$1.names = ['debug-on-property-read'];
        debugOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, noopFunc];
        function debugOnPropertyWrite$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            debugger;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              set: abort
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugOnPropertyWrite$1.names = ['debug-on-property-write'];
        debugOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];
        function debugCurrentInlineScript$1(source, property, search) {
          var searchRegexp = toRegExp(search);
          var rid = randomId();
          var getCurrentScript = function getCurrentScript() {
            if ('currentScript' in document) {
              return document.currentScript;
            }
            var scripts = document.getElementsByTagName('script');
            return scripts[scripts.length - 1];
          };
          var ourScript = getCurrentScript();
          var abort = function abort() {
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
              return;
            }
            var content = scriptEl.textContent;
            try {
              var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
              content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
              hit(source);
              debugger;
            }
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (base instanceof Object === false && base === null) {
              var props = property.split('.');
              var propIndex = props.indexOf(prop);
              var baseName = props[propIndex - 1];
              console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded."));
              return;
            }
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var currentValue = base[prop];
            setPropertyAccess(base, prop, {
              set: function set(value) {
                abort();
                currentValue = value;
              },
              get: function get() {
                abort();
                return currentValue;
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugCurrentInlineScript$1.names = ['debug-current-inline-script'];
        debugCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];
        function removeAttr$1(source, attrs, selector) {
          var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
          if (!attrs) {
            return;
          }
          attrs = attrs.split(/\s*\|\s*/);
          if (!selector) {
            selector = "[".concat(attrs.join('],['), "]");
          }
          var rmattr = function rmattr() {
            var nodes = [];
            try {
              nodes = [].slice.call(document.querySelectorAll(selector));
            } catch (e) {
              console.log("Invalid remove-attr selector arg: '".concat(selector, "'"));
            }
            var removed = false;
            nodes.forEach(function (node) {
              attrs.forEach(function (attr) {
                node.removeAttribute(attr);
                removed = true;
              });
            });
            if (removed) {
              hit(source);
            }
          };
          var flags = parseFlags(applying);
          var run = function run() {
            rmattr();
            if (!flags.hasFlag(flags.STAY)) {
              return;
            }
            observeDOMChanges(rmattr, true);
          };
          if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === 'loading') {
              window.addEventListener('DOMContentLoaded', rmattr, {
                once: true
              });
            } else {
              rmattr();
            }
          }
          if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener('load', run, {
              once: true
            });
          } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.indexOf(' ') !== -1) {
              rmattr();
            }
            observeDOMChanges(rmattr, true);
          }
        }
        removeAttr$1.names = ['remove-attr',
        'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
        removeAttr$1.injections = [hit, observeDOMChanges, parseFlags];
        function setAttr$1(source, selector, attr) {
          var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          if (!selector || !attr) {
            return;
          }
          if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 0x7FFF)) {
            return;
          }
          var setAttr = function setAttr() {
            var nodes = [].slice.call(document.querySelectorAll(selector));
            var set = false;
            nodes.forEach(function (node) {
              node.setAttribute(attr, value);
              set = true;
            });
            if (set) {
              hit(source);
            }
          };
          setAttr();
          observeDOMChanges(setAttr, true);
        }
        setAttr$1.names = ['set-attr'];
        setAttr$1.injections = [hit, observeDOMChanges, nativeIsNaN];
        function removeClass$1(source, classNames, selector) {
          var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
          if (!classNames) {
            return;
          }
          classNames = classNames.split(/\s*\|\s*/);
          var selectors = [];
          if (!selector) {
            selectors = classNames.map(function (className) {
              return ".".concat(className);
            });
          }
          var removeClassHandler = function removeClassHandler() {
            var nodes = new Set();
            if (selector) {
              var foundNodes = [];
              try {
                foundNodes = [].slice.call(document.querySelectorAll(selector));
              } catch (e) {
                console.log("Invalid remove-class selector arg: '".concat(selector, "'"));
              }
              foundNodes.forEach(function (n) {
                return nodes.add(n);
              });
            } else if (selectors.length > 0) {
              selectors.forEach(function (s) {
                var elements = document.querySelectorAll(s);
                for (var i = 0; i < elements.length; i += 1) {
                  var element = elements[i];
                  nodes.add(element);
                }
              });
            }
            var removed = false;
            nodes.forEach(function (node) {
              classNames.forEach(function (className) {
                if (node.classList.contains(className)) {
                  node.classList.remove(className);
                  removed = true;
                }
              });
            });
            if (removed) {
              hit(source);
            }
          };
          var CLASS_ATTR_NAME = ['class'];
          var flags = parseFlags(applying);
          var run = function run() {
            removeClassHandler();
            if (!flags.hasFlag(flags.STAY)) {
              return;
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
          };
          if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === 'loading') {
              window.addEventListener('DOMContentLoaded', removeClassHandler, {
                once: true
              });
            } else {
              removeClassHandler();
            }
          }
          if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener('load', run, {
              once: true
            });
          } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.indexOf(' ') !== -1) {
              removeClassHandler();
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
          }
        }
        removeClass$1.names = ['remove-class',
        'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
        removeClass$1.injections = [hit, observeDOMChanges, parseFlags];
        function disableNewtabLinks$1(source) {
          document.addEventListener('click', function (ev) {
            var target = ev.target;
            while (target !== null) {
              if (target.localName === 'a' && target.hasAttribute('target')) {
                ev.stopPropagation();
                ev.preventDefault();
                hit(source);
                break;
              }
              target = target.parentNode;
            }
          });
        }
        disableNewtabLinks$1.names = ['disable-newtab-links',
        'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
        disableNewtabLinks$1.injections = [hit];
        function adjustSetInterval$1(source, matchCallback, matchDelay, boost) {
          var nativeSetInterval = window.setInterval;
          var matchRegexp = toRegExp(matchCallback);
          var intervalWrapper = function intervalWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
              if (source.verbose) {
                console.log("Scriptlet adjust-setInterval can not be applied because of invalid callback: '".concat(String(callback), "'."));
              }
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
              delay *= getBoostMultiplier(boost);
              hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeSetInterval.apply(window, [callback, delay].concat(args));
          };
          window.setInterval = intervalWrapper;
        }
        adjustSetInterval$1.names = ['adjust-setInterval',
        'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];
        adjustSetInterval$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched,
        nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];
        function adjustSetTimeout$1(source, matchCallback, matchDelay, boost) {
          var nativeSetTimeout = window.setTimeout;
          var matchRegexp = toRegExp(matchCallback);
          var timeoutWrapper = function timeoutWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
              if (source.verbose) {
                console.log("Scriptlet adjust-setTimeout can not be applied because of invalid callback: '".concat(String(callback), "'."));
              }
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
              delay *= getBoostMultiplier(boost);
              hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeSetTimeout.apply(window, [callback, delay].concat(args));
          };
          window.setTimeout = timeoutWrapper;
        }
        adjustSetTimeout$1.names = ['adjust-setTimeout',
        'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
        adjustSetTimeout$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched,
        nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];
        function dirString$1(source, times) {
          var _console = console,
              dir = _console.dir;
          times = parseInt(times, 10);
          function dirWrapper(object) {
            var temp;
            for (var i = 0; i < times; i += 1) {
              temp = "".concat(object);
            }
            if (typeof dir === 'function') {
              dir.call(this, object);
            }
            hit(source, temp);
          }
          console.dir = dirWrapper;
        }
        dirString$1.names = ['dir-string', 'abp-dir-string'];
        dirString$1.injections = [hit];
        function jsonPrune$1(source, propsToRemove, requiredInitialProps, stack) {
          if (!!stack && !matchStackTrace(stack, new Error().stack)) {
            return;
          }
          var log = console.log.bind(console);
          var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
          var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];
          function isPruningNeeded(root) {
            if (!root) {
              return false;
            }
            var shouldProcess;
            if (prunePaths.length === 0 && requiredPaths.length > 0) {
              var rootString = JSON.stringify(root);
              var matchRegex = toRegExp(requiredPaths.join(''));
              var shouldLog = matchRegex.test(rootString);
              if (shouldLog) {
                log(window.location.hostname, root);
                shouldProcess = false;
                return shouldProcess;
              }
            }
            for (var i = 0; i < requiredPaths.length; i += 1) {
              var requiredPath = requiredPaths[i];
              var lastNestedPropName = requiredPath.split('.').pop();
              var hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1;
              var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
              shouldProcess = !hasWildcard;
              for (var _i = 0; _i < details.length; _i += 1) {
                if (hasWildcard) {
                  shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;
                } else {
                  shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;
                }
              }
            }
            return shouldProcess;
          }
          var jsonPruner = function jsonPruner(root) {
            if (prunePaths.length === 0 && requiredPaths.length === 0) {
              log(window.location.hostname, root);
              return root;
            }
            try {
              if (isPruningNeeded(root) === false) {
                return root;
              }
              prunePaths.forEach(function (path) {
                var ownerObjArr = getWildcardPropertyInChain(root, path, true);
                ownerObjArr.forEach(function (ownerObj) {
                  if (ownerObj !== undefined && ownerObj.base) {
                    delete ownerObj.base[ownerObj.prop];
                    hit(source);
                  }
                });
              });
            } catch (e) {
              log(e.toString());
            }
            return root;
          };
          var nativeJSONParse = JSON.parse;
          var jsonParseWrapper = function jsonParseWrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var root = nativeJSONParse.apply(JSON, args);
            return jsonPruner(root);
          };
          jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
          JSON.parse = jsonParseWrapper;
          var nativeResponseJson = Response.prototype.json;
          var responseJsonWrapper = function responseJsonWrapper() {
            var promise = nativeResponseJson.apply(this);
            return promise.then(function (obj) {
              return jsonPruner(obj);
            });
          };
          if (typeof Response === 'undefined') {
            return;
          }
          Response.prototype.json = responseJsonWrapper;
        }
        jsonPrune$1.names = ['json-prune',
        'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
        jsonPrune$1.injections = [hit, matchStackTrace, getWildcardPropertyInChain, toRegExp, getWildcardSymbol, getNativeRegexpTest];
        function preventRequestAnimationFrame$1(source, match) {
          var nativeRequestAnimationFrame = window.requestAnimationFrame;
          var log = console.log.bind(console);
          var shouldLog = typeof match === 'undefined';
          var _parseMatchArg = parseMatchArg(match),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
          var rafWrapper = function rafWrapper(callback) {
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              log("requestAnimationFrame(".concat(String(callback), ")"));
            } else if (isValidCallback(callback) && isValidStrPattern(match)) {
              shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
            }
            if (shouldPrevent) {
              hit(source);
              return nativeRequestAnimationFrame(noopFunc);
            }
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeRequestAnimationFrame.apply(window, [callback].concat(args));
          };
          window.requestAnimationFrame = rafWrapper;
        }
        preventRequestAnimationFrame$1.names = ['prevent-requestAnimationFrame',
        'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
        preventRequestAnimationFrame$1.injections = [hit, noopFunc, parseMatchArg, isValidStrPattern, isValidCallback,
        escapeRegExp, toRegExp, startsWith];
        function setCookie$1(source, name, value) {
          var cookieData = prepareCookie(name, value);
          if (cookieData) {
            hit(source);
            document.cookie = cookieData;
          }
        }
        setCookie$1.names = ['set-cookie'];
        setCookie$1.injections = [hit, nativeIsNaN, prepareCookie];
        function setCookieReload$1(source, name, value) {
          var isCookieSetWithValue = function isCookieSetWithValue(name, value) {
            return document.cookie.split(';').some(function (cookieStr) {
              var pos = cookieStr.indexOf('=');
              if (pos === -1) {
                return false;
              }
              var cookieName = cookieStr.slice(0, pos).trim();
              var cookieValue = cookieStr.slice(pos + 1).trim();
              return name === cookieName && value === cookieValue;
            });
          };
          if (isCookieSetWithValue(name, value)) {
            return;
          }
          var cookieData = prepareCookie(name, value);
          if (cookieData) {
            document.cookie = cookieData;
            hit(source);
            if (isCookieSetWithValue(name, value)) {
              window.location.reload();
            }
          }
        }
        setCookieReload$1.names = ['set-cookie-reload'];
        setCookieReload$1.injections = [hit, nativeIsNaN, prepareCookie];
        function hideInShadowDom$1(source, selector, baseSelector) {
          if (!Element.prototype.attachShadow) {
            return;
          }
          var hideElement = function hideElement(targetElement) {
            var DISPLAY_NONE_CSS = 'display:none!important;';
            targetElement.style.cssText = DISPLAY_NONE_CSS;
          };
          var hideHandler = function hideHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            while (hostElements.length !== 0) {
              var isHidden = false;
              var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                  targets = _pierceShadowDom.targets,
                  innerHosts = _pierceShadowDom.innerHosts;
              targets.forEach(function (targetEl) {
                hideElement(targetEl);
                isHidden = true;
              });
              if (isHidden) {
                hit(source);
              }
              hostElements = innerHosts;
            }
          };
          hideHandler();
          observeDOMChanges(hideHandler, true);
        }
        hideInShadowDom$1.names = ['hide-in-shadow-dom'];
        hideInShadowDom$1.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];
        function removeInShadowDom$1(source, selector, baseSelector) {
          if (!Element.prototype.attachShadow) {
            return;
          }
          var removeElement = function removeElement(targetElement) {
            targetElement.remove();
          };
          var removeHandler = function removeHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            while (hostElements.length !== 0) {
              var isRemoved = false;
              var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                  targets = _pierceShadowDom.targets,
                  innerHosts = _pierceShadowDom.innerHosts;
              targets.forEach(function (targetEl) {
                removeElement(targetEl);
                isRemoved = true;
              });
              if (isRemoved) {
                hit(source);
              }
              hostElements = innerHosts;
            }
          };
          removeHandler();
          observeDOMChanges(removeHandler, true);
        }
        removeInShadowDom$1.names = ['remove-in-shadow-dom'];
        removeInShadowDom$1.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];
        function preventFetch$1(source, propsToMatch) {
          var responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'emptyObj';
          if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
            return;
          }
          var strResponseBody;
          if (responseBody === 'emptyObj') {
            strResponseBody = '{}';
          } else if (responseBody === 'emptyArr') {
            strResponseBody = '[]';
          } else {
            return;
          }
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var shouldPrevent = false;
            var fetchData = getFetchData(args);
            if (typeof propsToMatch === 'undefined') {
              var logMessage = "log: fetch( ".concat(objectToString(fetchData), " )");
              hit(source, logMessage);
            } else if (propsToMatch === '' || propsToMatch === getWildcardSymbol()) {
              shouldPrevent = true;
            } else {
              var parsedData = parseMatchProps(propsToMatch);
              if (!validateParsedData(parsedData)) {
                console.log("Invalid parameter: ".concat(propsToMatch));
                shouldPrevent = false;
              } else {
                var matchData = getMatchPropsData(parsedData);
                shouldPrevent = Object.keys(matchData).every(function (matchKey) {
                  var matchValue = matchData[matchKey];
                  return Object.prototype.hasOwnProperty.call(fetchData, matchKey) && matchValue.test(fetchData[matchKey]);
                });
              }
            }
            if (shouldPrevent) {
              hit(source);
              return noopPromiseResolve(strResponseBody);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var fetchHandler = {
            apply: handlerWrapper
          };
          fetch = new Proxy(fetch, fetchHandler);
        }
        preventFetch$1.names = ['prevent-fetch',
        'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];
        preventFetch$1.injections = [hit, getFetchData, objectToString, parseMatchProps, validateParsedData, getMatchPropsData, noopPromiseResolve, getWildcardSymbol, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getObjectEntries, getObjectFromEntries];
        function setLocalStorageItem$1(source, key, value) {
          if (!key || !value && value !== '') {
            return;
          }
          var keyValue;
          if (value === 'undefined') {
            keyValue = undefined;
          } else if (value === 'false') {
            keyValue = false;
          } else if (value === 'true') {
            keyValue = true;
          } else if (value === 'null') {
            keyValue = null;
          } else if (value === 'emptyArr') {
            keyValue = '[]';
          } else if (value === 'emptyObj') {
            keyValue = '{}';
          } else if (value === '') {
            keyValue = '';
          } else if (/^\d+$/.test(value)) {
            keyValue = parseFloat(value);
            if (nativeIsNaN(keyValue)) {
              return;
            }
            if (Math.abs(keyValue) > 0x7FFF) {
              return;
            }
          } else if (value === 'yes') {
            keyValue = 'yes';
          } else if (value === 'no') {
            keyValue = 'no';
          } else {
            return;
          }
          var setItem = function setItem(key, value) {
            var _window = window,
                localStorage = _window.localStorage;
            try {
              localStorage.setItem(key, value);
              hit(source);
            } catch (e) {
              if (source.verbose) {
                console.log("Was unable to set localStorage item due to: ".concat(e.message));
              }
            }
          };
          setItem(key, keyValue);
        }
        setLocalStorageItem$1.names = ['set-local-storage-item'];
        setLocalStorageItem$1.injections = [hit, nativeIsNaN];
        function setSessionStorageItem$1(source, key, value) {
          if (!key || !value && value !== '') {
            return;
          }
          var keyValue;
          if (value === 'undefined') {
            keyValue = undefined;
          } else if (value === 'false') {
            keyValue = false;
          } else if (value === 'true') {
            keyValue = true;
          } else if (value === 'null') {
            keyValue = null;
          } else if (value === 'emptyArr') {
            keyValue = '[]';
          } else if (value === 'emptyObj') {
            keyValue = '{}';
          } else if (value === '') {
            keyValue = '';
          } else if (/^\d+$/.test(value)) {
            keyValue = parseFloat(value);
            if (nativeIsNaN(keyValue)) {
              return;
            }
            if (Math.abs(keyValue) > 0x7FFF) {
              return;
            }
          } else if (value === 'yes') {
            keyValue = 'yes';
          } else if (value === 'no') {
            keyValue = 'no';
          } else {
            return;
          }
          var setItem = function setItem(key, value) {
            var _window = window,
                sessionStorage = _window.sessionStorage;
            try {
              sessionStorage.setItem(key, value);
              hit(source);
            } catch (e) {
              if (source.verbose) {
                console.log("Was unable to set sessionStorage item due to: ".concat(e.message));
              }
            }
          };
          setItem(key, keyValue);
        }
        setSessionStorageItem$1.names = ['set-session-storage-item'];
        setSessionStorageItem$1.injections = [hit, nativeIsNaN];
        function abortOnStackTrace$1(source, property, stack) {
          if (!property || !stack) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            if (!isValidStrPattern(stack)) {
              console.log("Invalid parameter: ".concat(stack));
              return;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
              value: base[prop],
              get: function get() {
                if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                  abort();
                }
                return this.value;
              },
              set: function set(newValue) {
                if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                  abort();
                }
                this.value = newValue;
              }
            });
            setPropertyAccess(base, prop, {
              get: function get() {
                return descriptorWrapper.get.call(descriptorWrapper);
              },
              set: function set(newValue) {
                descriptorWrapper.set.call(descriptorWrapper, newValue);
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnStackTrace$1.names = ['abort-on-stack-trace',
        'abort-on-stack-trace.js', 'ubo-abort-on-stack-trace.js', 'aost.js', 'ubo-aost.js', 'ubo-abort-on-stack-trace', 'ubo-aost', 'abp-abort-on-stack-trace'];
        abortOnStackTrace$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isValidStrPattern, escapeRegExp, matchStackTrace, getDescriptorAddon, toRegExp, getNativeRegexpTest];
        function logOnStacktrace$1(source, property) {
          if (!property) {
            return;
          }
          var refineStackTrace = function refineStackTrace(stackString) {
            var stackSteps = stackString.split('\n').slice(2).map(function (line) {
              return line.replace(/ {4}at /, '');
            });
            var logInfoArray = stackSteps.map(function (line) {
              var funcName;
              var funcFullPath;
              var reg = /\(([^\)]+)\)/;
              if (line.match(reg)) {
                funcName = line.split(' ').slice(0, -1).join(' ');
                funcFullPath = line.match(reg)[1];
              } else {
                funcName = 'function name is not available';
                funcFullPath = line;
              }
              return [funcName, funcFullPath];
            });
            var logInfoObject = {};
            logInfoArray.forEach(function (pair) {
              logInfoObject[pair[0]] = pair[1];
            });
            return logInfoObject;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var value = base[prop];
            setPropertyAccess(base, prop, {
              get: function get() {
                hit(source);
                console.log("%cGet %c".concat(prop), 'color:red;', 'color:green;');
                console.table(refineStackTrace(new Error().stack));
                return value;
              },
              set: function set(newValue) {
                hit(source);
                console.log("%cSet %c".concat(prop), 'color:red;', 'color:green;');
                console.table(refineStackTrace(new Error().stack));
                value = newValue;
              }
            });
          };
          setChainPropAccess(window, property);
        }
        logOnStacktrace$1.names = ['log-on-stack-trace'];
        logOnStacktrace$1.injections = [getPropertyInChain, setPropertyAccess, hit];
        function preventXHR$1(source, propsToMatch, customResponseText) {
          if (typeof Proxy === 'undefined') {
            return;
          }
          var shouldPrevent = false;
          var response = '';
          var responseText = '';
          var responseUrl;
          var openWrapper = function openWrapper(target, thisArg, args) {
            var xhrData = {
              method: args[0],
              url: args[1]
            };
            responseUrl = xhrData.url;
            if (typeof propsToMatch === 'undefined') {
              var logMessage = "log: xhr( ".concat(objectToString(xhrData), " )");
              hit(source, logMessage);
            } else if (propsToMatch === '' || propsToMatch === getWildcardSymbol()) {
              shouldPrevent = true;
            } else {
              var parsedData = parseMatchProps(propsToMatch);
              if (!validateParsedData(parsedData)) {
                console.log("Invalid parameter: ".concat(propsToMatch));
                shouldPrevent = false;
              } else {
                var matchData = getMatchPropsData(parsedData);
                shouldPrevent = Object.keys(matchData).every(function (matchKey) {
                  var matchValue = matchData[matchKey];
                  return Object.prototype.hasOwnProperty.call(xhrData, matchKey) && matchValue.test(xhrData[matchKey]);
                });
              }
            }
            return Reflect.apply(target, thisArg, args);
          };
          var sendWrapper = function sendWrapper(target, thisArg, args) {
            if (!shouldPrevent) {
              return Reflect.apply(target, thisArg, args);
            }
            if (thisArg.responseType === 'blob') {
              response = new Blob();
            }
            if (thisArg.responseType === 'arraybuffer') {
              response = new ArrayBuffer();
            }
            if (customResponseText) {
              var randomText = generateRandomResponse(customResponseText);
              if (randomText) {
                responseText = randomText;
              } else {
                console.log("Invalid range: ".concat(customResponseText));
              }
            }
            Object.defineProperties(thisArg, {
              readyState: {
                value: 4,
                writable: false
              },
              response: {
                value: response,
                writable: false
              },
              responseText: {
                value: responseText,
                writable: false
              },
              responseURL: {
                value: responseUrl,
                writable: false
              },
              responseXML: {
                value: '',
                writable: false
              },
              status: {
                value: 200,
                writable: false
              },
              statusText: {
                value: 'OK',
                writable: false
              }
            });
            setTimeout(function () {
              var stateEvent = new Event('readystatechange');
              thisArg.dispatchEvent(stateEvent);
              var loadEvent = new Event('load');
              thisArg.dispatchEvent(loadEvent);
              var loadEndEvent = new Event('loadend');
              thisArg.dispatchEvent(loadEndEvent);
            }, 1);
            hit(source);
            return undefined;
          };
          var openHandler = {
            apply: openWrapper
          };
          var sendHandler = {
            apply: sendWrapper
          };
          XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
          XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
        }
        preventXHR$1.names = ['prevent-xhr',
        'no-xhr-if.js', 'ubo-no-xhr-if.js', 'ubo-no-xhr-if'];
        preventXHR$1.injections = [hit, objectToString, getWildcardSymbol, parseMatchProps, validateParsedData, getMatchPropsData, getRandomIntInclusive, getRandomStrByLength, generateRandomResponse, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getObjectEntries, getNumberFromString, nativeIsFinite, nativeIsNaN];
        function forceWindowClose$1(source) {
          var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var log = console.log.bind(console);
          if (typeof window.close !== 'function') {
            if (source.verbose) {
              log('window.close() is not a function so \'close-window\' scriptlet is unavailable');
            }
            return;
          }
          var closeImmediately = function closeImmediately() {
            try {
              hit(source);
              window.close();
            } catch (e) {
              log(e);
            }
          };
          var closeByExtension = function closeByExtension() {
            var extCall = function extCall() {
              dispatchEvent(new Event('adguard:scriptlet-close-window'));
            };
            window.addEventListener('adguard:subscribed-to-close-window', extCall, {
              once: true
            });
            setTimeout(function () {
              window.removeEventListener('adguard:subscribed-to-close-window', extCall, {
                once: true
              });
            }, 5000);
          };
          var shouldClose = function shouldClose() {
            if (path === '') {
              return true;
            }
            var pathRegexp = toRegExp(path);
            var currentPath = "".concat(window.location.pathname).concat(window.location.search);
            return pathRegexp.test(currentPath);
          };
          if (shouldClose()) {
            closeImmediately();
            if (navigator.userAgent.indexOf('Chrome') > -1) {
              closeByExtension();
            }
          }
        }
        forceWindowClose$1.names = ['close-window', 'window-close-if.js', 'ubo-window-close-if.js', 'ubo-window-close-if'];
        forceWindowClose$1.injections = [hit, toRegExp];
        function preventRefresh$1(source, delaySec) {
          var getMetaElements = function getMetaElements() {
            var metaNodes = [];
            try {
              metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
            } catch (e) {
              try {
                metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
              } catch (e) {
                if (source.verbose) {
                  console.log(e);
                }
              }
            }
            return Array.from(metaNodes);
          };
          var getMetaContentDelay = function getMetaContentDelay(metaElements) {
            var delays = metaElements.map(function (meta) {
              var contentString = meta.getAttribute('content');
              if (contentString.length === 0) {
                return null;
              }
              var contentDelay;
              var limiterIndex = contentString.indexOf(';');
              if (limiterIndex !== -1) {
                var delaySubstring = contentString.substring(0, limiterIndex);
                contentDelay = getNumberFromString(delaySubstring);
              } else {
                contentDelay = getNumberFromString(contentString);
              }
              return contentDelay;
            }).filter(function (delay) {
              return delay !== null;
            });
            if (!delays.length) {
              return null;
            }
            var minDelay = delays.reduce(function (a, b) {
              return Math.min(a, b);
            });
            return minDelay;
          };
          var stop = function stop() {
            var metaElements = getMetaElements();
            if (metaElements.length === 0) {
              return;
            }
            var secondsToRun = getNumberFromString(delaySec);
            if (secondsToRun === null) {
              secondsToRun = getMetaContentDelay(metaElements);
            }
            if (secondsToRun === null) {
              return;
            }
            var delayMs = secondsToRun * 1000;
            setTimeout(function () {
              window.stop();
              hit(source);
            }, delayMs);
          };
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', stop, {
              once: true
            });
          } else {
            stop();
          }
        }
        preventRefresh$1.names = ['prevent-refresh',
        'refresh-defuser.js', 'refresh-defuser',
        'ubo-refresh-defuser.js', 'ubo-refresh-defuser'];
        preventRefresh$1.injections = [hit, getNumberFromString, nativeIsNaN];
        function preventElementSrcLoading$1(source, tagName, match) {
          if (typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
            return;
          }
          var srcMockData = {
            script: 'data:text/javascript;base64,KCk9Pnt9',
            img: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
            iframe: 'data:text/html;base64, PGRpdj48L2Rpdj4='
          };
          var instance;
          if (tagName === 'script') {
            instance = HTMLScriptElement;
          } else if (tagName === 'img') {
            instance = HTMLImageElement;
          } else if (tagName === 'iframe') {
            instance = HTMLIFrameElement;
          } else {
            return;
          }
          var hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === 'function';
          var policy;
          if (hasTrustedTypes) {
            policy = window.trustedTypes.createPolicy('mock', {
              createScriptURL: function createScriptURL(arg) {
                return arg;
              }
            });
          }
          var SOURCE_PROPERTY_NAME = 'src';
          var searchRegexp = toRegExp(match);
          var setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
            if (!args[0] || !args[1]) {
              return Reflect.apply(target, thisArg, args);
            }
            var nodeName = thisArg.nodeName.toLowerCase();
            var attrName = args[0].toLowerCase();
            var attrValue = args[1];
            var isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
            if (!isMatched) {
              return Reflect.apply(target, thisArg, args);
            }
            hit(source);
            return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
          };
          var setAttributeHandler = {
            apply: setAttributeWrapper
          };
          instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
          var origDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
          if (!origDescriptor) {
            return;
          }
          Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return origDescriptor.get.call(this);
            },
            set: function set(urlValue) {
              var nodeName = this.nodeName.toLowerCase();
              var isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
              if (!isMatched) {
                origDescriptor.set.call(this, urlValue);
                return;
              }
              if (policy && urlValue instanceof TrustedScriptURL) {
                var trustedSrc = policy.createScriptURL(urlValue);
                origDescriptor.set.call(this, trustedSrc);
                hit(source);
                return;
              }
              origDescriptor.set.call(this, srcMockData[nodeName]);
              hit(source);
            }
          });
        }
        preventElementSrcLoading$1.names = ['prevent-element-src-loading'];
        preventElementSrcLoading$1.injections = [hit, toRegExp, safeGetDescriptor];
        function noTopics$1(source) {
          var TOPICS_PROPERTY_NAME = 'browsingTopics';
          if (Document instanceof Object === false) {
            return;
          }
          if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
            return;
          }
          Document.prototype[TOPICS_PROPERTY_NAME] = function () {
            return noopPromiseResolve('[]');
          };
          hit(source);
        }
        noTopics$1.names = ['no-topics'];
        noTopics$1.injections = [hit, noopPromiseResolve];
        var scriptletList = Object.freeze({
            __proto__: null,
            abortOnPropertyRead: abortOnPropertyRead$1,
            abortOnPropertyWrite: abortOnPropertyWrite$1,
            preventSetTimeout: preventSetTimeout$1,
            preventSetInterval: preventSetInterval$1,
            preventWindowOpen: preventWindowOpen$1,
            abortCurrentInlineScript: abortCurrentInlineScript$1,
            setConstant: setConstant$1,
            removeCookie: removeCookie$1,
            preventAddEventListener: preventAddEventListener$1,
            preventBab: preventBab$1,
            nowebrtc: nowebrtc$1,
            logAddEventListener: logAddEventListener$1,
            logEval: logEval$1,
            log: log$1,
            noeval: noeval$1,
            preventEvalIf: preventEvalIf$1,
            preventFab: preventFab$1,
            setPopadsDummy: setPopadsDummy$1,
            preventPopadsNet: preventPopadsNet$1,
            preventAdfly: preventAdfly$1,
            debugOnPropertyRead: debugOnPropertyRead$1,
            debugOnPropertyWrite: debugOnPropertyWrite$1,
            debugCurrentInlineScript: debugCurrentInlineScript$1,
            removeAttr: removeAttr$1,
            setAttr: setAttr$1,
            removeClass: removeClass$1,
            disableNewtabLinks: disableNewtabLinks$1,
            adjustSetInterval: adjustSetInterval$1,
            adjustSetTimeout: adjustSetTimeout$1,
            dirString: dirString$1,
            jsonPrune: jsonPrune$1,
            preventRequestAnimationFrame: preventRequestAnimationFrame$1,
            setCookie: setCookie$1,
            setCookieReload: setCookieReload$1,
            hideInShadowDom: hideInShadowDom$1,
            removeInShadowDom: removeInShadowDom$1,
            preventFetch: preventFetch$1,
            setLocalStorageItem: setLocalStorageItem$1,
            setSessionStorageItem: setSessionStorageItem$1,
            abortOnStackTrace: abortOnStackTrace$1,
            logOnStacktrace: logOnStacktrace$1,
            preventXHR: preventXHR$1,
            forceWindowClose: forceWindowClose$1,
            preventRefresh: preventRefresh$1,
            preventElementSrcLoading: preventElementSrcLoading$1,
            noTopics: noTopics$1
        });
        var redirects$1 = [{
          adg: '1x1-transparent.gif',
          ubo: '1x1.gif',
          abp: '1x1-transparent-gif'
        }, {
          adg: '2x2-transparent.png',
          ubo: '2x2.png',
          abp: '2x2-transparent-png'
        }, {
          adg: '3x2-transparent.png',
          ubo: '3x2.png',
          abp: '3x2-transparent-png'
        }, {
          adg: '32x32-transparent.png',
          ubo: '32x32.png',
          abp: '32x32-transparent-png'
        }, {
          adg: 'amazon-apstag',
          ubo: 'amazon_apstag.js'
        }, {
          adg: 'ati-smarttag'
        }, {
          adg: 'didomi-loader'
        }, {
          adg: 'click2load.html',
          ubo: 'click2load.html'
        }, {
          adg: 'fingerprintjs2',
          ubo: 'fingerprint2.js'
        }, {
          adg: 'fingerprintjs3',
          ubo: 'fingerprint3.js'
        }, {
          adg: 'google-analytics',
          ubo: 'google-analytics_analytics.js'
        }, {
          adg: 'google-analytics-ga',
          ubo: 'google-analytics_ga.js'
        }, {
          adg: 'googlesyndication-adsbygoogle',
          ubo: 'googlesyndication_adsbygoogle.js'
        }, {
          adg: 'googlesyndication-adsbygoogle',
          ubo: 'googlesyndication.com/adsbygoogle.js'
        }, {
          adg: 'googletagmanager-gtm',
          ubo: 'google-analytics_ga.js'
        }, {
          adg: 'googletagservices-gpt',
          ubo: 'googletagservices_gpt.js'
        }, {
          adg: 'google-ima3'
        }, {
          adg: 'gemius'
        }, {
          adg: 'matomo'
        }, {
          adg: 'metrika-yandex-watch'
        }, {
          adg: 'metrika-yandex-tag'
        }, {
          adg: 'naver-wcslog'
        }, {
          adg: 'noeval',
          ubo: 'noeval-silent.js'
        }, {
          adg: 'noopcss',
          abp: 'blank-css'
        }, {
          adg: 'noopframe',
          ubo: 'noop.html',
          abp: 'blank-html'
        }, {
          adg: 'noopjs',
          ubo: 'noop.js',
          abp: 'blank-js'
        }, {
          adg: 'noopjson'
        }, {
          adg: 'nooptext',
          ubo: 'noop.txt',
          abp: 'blank-text'
        }, {
          adg: 'noopmp3-0.1s',
          ubo: 'noop-0.1s.mp3',
          abp: 'blank-mp3'
        }, {
          adg: 'noopmp4-1s',
          ubo: 'noop-1s.mp4',
          abp: 'blank-mp4'
        }, {
          adg: 'noopvmap-1.0',
          ubo: 'noop-vmap1.0.xml'
        }, {
          adg: 'noopvast-2.0'
        }, {
          adg: 'noopvast-3.0'
        }, {
          adg: 'noopvast-4.0'
        }, {
          adg: 'prebid'
        }, {
          adg: 'pardot-1.0'
        }, {
          adg: 'prevent-bab',
          ubo: 'nobab.js'
        }, {
          adg: 'prevent-bab2',
          ubo: 'nobab2.js'
        }, {
          adg: 'prevent-fab-3.2.0',
          ubo: 'nofab.js'
        }, {
          adg: 'prevent-fab-3.2.0',
          ubo: 'fuckadblock.js-3.2.0'
        }, {
          adg: 'prevent-popads-net',
          ubo: 'popads.js'
        }, {
          adg: 'scorecardresearch-beacon',
          ubo: 'scorecardresearch_beacon.js'
        }, {
          adg: 'set-popads-dummy',
          ubo: 'popads-dummy.js'
        }, {
          adg: 'empty',
          ubo: 'empty'
        }, {
          adg: 'prebid-ads',
          ubo: 'prebid-ads.js'
        }];
        var JS_RULE_MARKER = '#%#';
        var COMMENT_MARKER = '!';
        var isComment = function isComment(rule) {
          return startsWith(rule, COMMENT_MARKER);
        };
        var UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
        var UBO_SCRIPTLET_MASK_1 = '##+js';
        var UBO_SCRIPTLET_MASK_2 = '##script:inject';
        var UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
        var UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
        var ABP_SCRIPTLET_MASK = '#$#';
        var ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
        var ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
        var isAdgScriptletRule = function isAdgScriptletRule(rule) {
          return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
        };
        var isUboScriptletRule = function isUboScriptletRule(rule) {
          return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
        };
        var isAbpSnippetRule = function isAbpSnippetRule(rule) {
          return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
        };
        var getScriptletByName = function getScriptletByName(name) {
          var scriptlets = Object.keys(scriptletList).map(function (key) {
            return scriptletList[key];
          });
          return scriptlets.find(function (s) {
            return s.names
            && (s.names.indexOf(name) > -1
            || !endsWith(name, '.js') && s.names.indexOf("".concat(name, ".js")) > -1);
          });
        };
        var isValidScriptletName = function isValidScriptletName(name) {
          if (!name) {
            return false;
          }
          var scriptlet = getScriptletByName(name);
          if (!scriptlet) {
            return false;
          }
          return true;
        };
        var ADG_UBO_REDIRECT_MARKER = 'redirect=';
        var ADG_UBO_REDIRECT_RULE_MARKER = 'redirect-rule=';
        var ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
        var EMPTY_REDIRECT_MARKER = 'empty';
        var VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];
        var ABSENT_SOURCE_TYPE_REPLACEMENT = [{
          NAME: 'nooptext',
          TYPES: VALID_SOURCE_TYPES
        }, {
          NAME: 'noopjs',
          TYPES: ['script']
        }, {
          NAME: 'noopframe',
          TYPES: ['subdocument']
        }, {
          NAME: '1x1-transparent.gif',
          TYPES: ['image']
        }, {
          NAME: 'noopmp3-0.1s',
          TYPES: ['media']
        }, {
          NAME: 'noopmp4-1s',
          TYPES: ['media']
        }, {
          NAME: 'googlesyndication-adsbygoogle',
          TYPES: ['xmlhttprequest', 'script']
        }, {
          NAME: 'google-analytics',
          TYPES: ['script']
        }, {
          NAME: 'googletagservices-gpt',
          TYPES: ['script']
        }];
        var validAdgRedirects = redirects$1.filter(function (el) {
          return el.adg;
        });
        var uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
          return el.ubo;
        }).map(function (el) {
          return [el.ubo, el.adg];
        }));
        var abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
          return el.abp;
        }).map(function (el) {
          return [el.abp, el.adg];
        }));
        var adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
          return el.ubo;
        }).map(function (el) {
          return [el.adg, el.ubo];
        }));
        var validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {
          return [el.adg, 'valid adg redirect'];
        }));
        var REDIRECT_RULE_TYPES = {
          VALID_ADG: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
            compatibility: validAdgCompatibility
          },
          ADG: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
            compatibility: adgToUboCompatibility
          },
          UBO: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
            compatibility: uboToAdgCompatibility
          },
          ABP: {
            redirectMarker: ABP_REDIRECT_MARKER,
            compatibility: abpToAdgCompatibility
          }
        };
        var parseModifiers = function parseModifiers(rule) {
          return substringAfter$1(rule, '$').split(',');
        };
        var getRedirectName = function getRedirectName(rule, marker) {
          var ruleModifiers = parseModifiers(rule);
          var redirectNamePart = ruleModifiers.find(function (el) {
            return el.indexOf(marker) > -1;
          });
          return substringAfter$1(redirectNamePart, marker);
        };
        var isAdgRedirectRule = function isAdgRedirectRule(rule) {
          var MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect((-rule)?)=(.{0,}?)\\$(popup)?/';
          return !isComment(rule) && (rule.indexOf(REDIRECT_RULE_TYPES.ADG.redirectMarker) > -1 || rule.indexOf(REDIRECT_RULE_TYPES.ADG.redirectRuleMarker) > -1)
          && rule.indexOf(JS_RULE_MARKER) === -1
          && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
        };
        var isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
          var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],
              redirectMarker = _REDIRECT_RULE_TYPES$.redirectMarker,
              redirectRuleMarker = _REDIRECT_RULE_TYPES$.redirectRuleMarker,
              compatibility = _REDIRECT_RULE_TYPES$.compatibility;
          if (rule && !isComment(rule)) {
            var marker;
            var markerIndex = redirectRuleMarker ? rule.indexOf(redirectRuleMarker) : -1;
            if (markerIndex > -1) {
              marker = redirectRuleMarker;
            } else {
              markerIndex = rule.indexOf(redirectMarker);
              if (markerIndex > -1) {
                marker = redirectMarker;
              } else {
                return false;
              }
            }
            var redirectName = getRedirectName(rule, marker);
            if (!redirectName) {
              return false;
            }
            return redirectName === Object.keys(compatibility).find(function (el) {
              return el === redirectName;
            });
          }
          return false;
        };
        var isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
          return isRedirectRuleByType(rule, 'VALID_ADG');
        };
        var isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
          return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');
        };
        var isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
          return isRedirectRuleByType(rule, 'UBO');
        };
        var isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
          return isRedirectRuleByType(rule, 'ABP');
        };
        var hasValidContentType = function hasValidContentType(rule) {
          var ruleModifiers = parseModifiers(rule);
          var sourceTypes = ruleModifiers.filter(function (el) {
            return VALID_SOURCE_TYPES.indexOf(el) > -1;
          });
          var isSourceTypeSpecified = sourceTypes.length > 0;
          var isEmptyRedirect = ruleModifiers.indexOf("".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) > -1 || ruleModifiers.indexOf("".concat(ADG_UBO_REDIRECT_RULE_MARKER).concat(EMPTY_REDIRECT_MARKER)) > -1;
          if (isEmptyRedirect) {
            return true;
          }
          return isSourceTypeSpecified;
        };
        var validator = {
          UBO_SCRIPTLET_MASK_REG: UBO_SCRIPTLET_MASK_REG,
          ABP_SCRIPTLET_MASK: ABP_SCRIPTLET_MASK,
          ABP_SCRIPTLET_EXCEPTION_MASK: ABP_SCRIPTLET_EXCEPTION_MASK,
          isComment: isComment,
          isAdgScriptletRule: isAdgScriptletRule,
          isUboScriptletRule: isUboScriptletRule,
          isAbpSnippetRule: isAbpSnippetRule,
          getScriptletByName: getScriptletByName,
          isValidScriptletName: isValidScriptletName,
          ADG_UBO_REDIRECT_RULE_MARKER: ADG_UBO_REDIRECT_RULE_MARKER,
          REDIRECT_RULE_TYPES: REDIRECT_RULE_TYPES,
          ABSENT_SOURCE_TYPE_REPLACEMENT: ABSENT_SOURCE_TYPE_REPLACEMENT,
          isAdgRedirectRule: isAdgRedirectRule,
          isValidAdgRedirectRule: isValidAdgRedirectRule,
          isAdgRedirectCompatibleWithUbo: isAdgRedirectCompatibleWithUbo,
          isUboRedirectCompatibleWithAdg: isUboRedirectCompatibleWithAdg,
          isAbpRedirectCompatibleWithAdg: isAbpRedirectCompatibleWithAdg,
          parseModifiers: parseModifiers,
          getRedirectName: getRedirectName,
          hasValidContentType: hasValidContentType
        };
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        var arrayLikeToArray = _arrayLikeToArray;
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return arrayLikeToArray(arr);
        }
        var arrayWithoutHoles = _arrayWithoutHoles;
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        }
        var iterableToArray = _iterableToArray;
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
        }
        var unsupportedIterableToArray = _unsupportedIterableToArray;
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var nonIterableSpread = _nonIterableSpread;
        function _toConsumableArray(arr) {
          return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
        }
        var toConsumableArray = _toConsumableArray;
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        var arrayWithHoles = _arrayWithHoles;
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var nonIterableRest = _nonIterableRest;
        function _toArray(arr) {
          return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
        }
        var toArray$1 = _toArray;
        var ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/;
        var ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})';
        var ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
        var UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})';
        var UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
        var UBO_ALIAS_NAME_MARKER = 'ubo-';
        var UBO_SCRIPTLET_JS_ENDING = '.js';
        var UBO_XHR_TYPE = 'xhr';
        var ADG_XHR_TYPE = 'xmlhttprequest';
        var ADG_SET_CONSTANT_NAME = 'set-constant';
        var ADG_SET_CONSTANT_EMPTY_STRING = '';
        var UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
        var ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
        var ADG_PREVENT_FETCH_EMPTY_STRING = '';
        var ADG_PREVENT_FETCH_WILDCARD = getWildcardSymbol();
        var UBO_NO_FETCH_IF_WILDCARD = '/^/';
        var ESCAPED_COMMA_SEPARATOR = '\\,';
        var COMMA_SEPARATOR = ',';
        var REMOVE_ATTR_METHOD = 'removeAttr';
        var REMOVE_CLASS_METHOD = 'removeClass';
        var REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;
        var REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;
        var ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];
        var ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];
        var REMOVE_ATTR_CLASS_APPLYING = ['asap', 'stay', 'complete'];
        var getSentences = function getSentences(str) {
          var reg = /'.*?'|".*?"|\S+/g;
          return str.match(reg);
        };
        var replacePlaceholders = function replacePlaceholders(str, data) {
          return Object.keys(data).reduce(function (acc, key) {
            var reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
            acc = acc.replace(reg, data[key]);
            return acc;
          }, str);
        };
        var splitArgs = function splitArgs(str) {
          var args = [];
          var prevArgStart = 0;
          for (var i = 0; i < str.length; i += 1) {
            if (str[i] === COMMA_SEPARATOR && str[i - 1] !== '\\') {
              args.push(str.slice(prevArgStart, i).trim());
              prevArgStart = i + 1;
            }
          }
          args.push(str.slice(prevArgStart, str.length).trim());
          return args;
        };
        var validateRemoveAttrClassArgs = function validateRemoveAttrClassArgs(parsedArgs) {
          var _parsedArgs = toArray$1(parsedArgs),
              name = _parsedArgs[0],
              value = _parsedArgs[1],
              restArgs = _parsedArgs.slice(2);
          if (restArgs.length === 0) {
            return [name, value];
          }
          var lastArg = restArgs.pop();
          var applying;
          if (REMOVE_ATTR_CLASS_APPLYING.some(function (el) {
            return lastArg.indexOf(el) > -1;
          })) {
            applying = lastArg;
          } else {
            restArgs.push(lastArg);
          }
          var selector = replaceAll(restArgs.join(', '), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR);
          if (selector.length > 0 && typeof document !== 'undefined') {
            document.querySelectorAll(selector);
          }
          var validArgs = applying ? [name, value, selector, applying] : [name, value, selector];
          return validArgs;
        };
        var convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
          var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
          var mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];
          var template;
          if (mask.indexOf('@') > -1) {
            template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
          } else {
            template = ADGUARD_SCRIPTLET_TEMPLATE;
          }
          var argsStr = getStringInBraces(rule);
          var parsedArgs = splitArgs(argsStr);
          var scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? "ubo-".concat(parsedArgs[0]) : "ubo-".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);
          if (REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) {
            parsedArgs = validateRemoveAttrClassArgs(parsedArgs);
          }
          var args = parsedArgs.map(function (arg, index) {
            var outputArg = arg;
            if (index === 0) {
              outputArg = scriptletName;
            }
            if (arg === '$') {
              outputArg = '$$';
            }
            return outputArg;
          }).map(function (arg) {
            return wrapInSingleQuotes(arg);
          }).join("".concat(COMMA_SEPARATOR, " "));
          var adgRule = replacePlaceholders(template, {
            domains: domains,
            args: args
          });
          return [adgRule];
        };
        var convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
          var SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
          var mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
          var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
          var domains = substringBefore(rule, mask);
          var args = substringAfter$1(rule, mask);
          return args.split(SEMICOLON_DIVIDER)
          .filter(isExisting).map(function (args) {
            return getSentences(args).map(function (arg, index) {
              return index === 0 ? "abp-".concat(arg) : arg;
            }).map(function (arg) {
              return wrapInSingleQuotes(arg);
            }).join("".concat(COMMA_SEPARATOR, " "));
          }).map(function (args) {
            return replacePlaceholders(template, {
              domains: domains,
              args: args
            });
          });
        };
        var convertScriptletToAdg = function convertScriptletToAdg(rule) {
          var result;
          if (validator.isUboScriptletRule(rule)) {
            result = convertUboScriptletToAdg(rule);
          } else if (validator.isAbpSnippetRule(rule)) {
            result = convertAbpSnippetToAdg(rule);
          } else if (validator.isAdgScriptletRule(rule) || validator.isComment(rule)) {
            result = [rule];
          }
          return result;
        };
        var convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
          var res;
          if (validator.isAdgScriptletRule(rule)) {
            var _parseRule = parseRule(rule),
                parsedName = _parseRule.name,
                parsedParams = _parseRule.args;
            var preparedParams;
            if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {
              preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];
            } else if (parsedName === ADG_PREVENT_FETCH_NAME
            && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {
              preparedParams = [UBO_NO_FETCH_IF_WILDCARD];
            } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {
              preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];
            } else {
              preparedParams = parsedParams;
            }
            var adgScriptletObject = Object.keys(scriptletList).map(function (el) {
              return scriptletList[el];
            }).map(function (s) {
              var _s$names = toArray$1(s.names),
                  name = _s$names[0],
                  aliases = _s$names.slice(1);
              return {
                name: name,
                aliases: aliases
              };
            }).find(function (el) {
              return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
            });
            var aliases = adgScriptletObject.aliases;
            if (aliases.length > 0) {
              var uboAlias = adgScriptletObject.aliases
              .find(function (alias) {
                return alias.includes(UBO_ALIAS_NAME_MARKER);
              });
              if (uboAlias) {
                var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
                var template;
                if (mask.indexOf('@') > -1) {
                  template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
                } else {
                  template = UBO_SCRIPTLET_TEMPLATE;
                }
                var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
                var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '')
                .replace(UBO_SCRIPTLET_JS_ENDING, '');
                var args = preparedParams.length > 0 ? "".concat(uboName, ", ").concat(preparedParams.join("".concat(COMMA_SEPARATOR, " "))) : uboName;
                var uboRule = replacePlaceholders(template, {
                  domains: domains,
                  args: args
                });
                res = uboRule;
              }
            }
          }
          return res;
        };
        var isValidScriptletRule = function isValidScriptletRule(input) {
          if (!input) {
            return false;
          }
          var rulesArray = convertScriptletToAdg(input);
          var isValid = rulesArray.every(function (rule) {
            var parsedRule = parseRule(rule);
            return validator.isValidScriptletName(parsedRule.name);
          });
          return isValid;
        };
        var getMarkerData = function getMarkerData(modifiers, redirectsData, rule) {
          var marker;
          var index = modifiers.findIndex(function (m) {
            return m.indexOf(redirectsData.redirectRuleMarker) > -1;
          });
          if (index > -1) {
            marker = redirectsData.redirectRuleMarker;
          } else {
            index = modifiers.findIndex(function (m) {
              return m.indexOf(redirectsData.redirectMarker) > -1;
            });
            if (index > -1) {
              marker = redirectsData.redirectMarker;
            } else {
              throw new Error("No redirect resource modifier found in rule: ".concat(rule));
            }
          }
          return {
            index: index,
            marker: marker
          };
        };
        var convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
          var firstPartOfRule = substringBefore(rule, '$');
          var uboModifiers = validator.parseModifiers(rule);
          var uboMarkerData = getMarkerData(uboModifiers, validator.REDIRECT_RULE_TYPES.UBO, rule);
          var adgModifiers = uboModifiers.map(function (modifier, index) {
            if (index === uboMarkerData.index) {
              var uboName = substringAfter$1(modifier, uboMarkerData.marker);
              var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
              var adgMarker = uboMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.ADG.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.ADG.redirectMarker;
              return "".concat(adgMarker).concat(adgName);
            }
            if (modifier === UBO_XHR_TYPE) {
              return ADG_XHR_TYPE;
            }
            return modifier;
          }).join(COMMA_SEPARATOR);
          return "".concat(firstPartOfRule, "$").concat(adgModifiers);
        };
        var convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
          var firstPartOfRule = substringBefore(rule, '$');
          var abpModifiers = validator.parseModifiers(rule);
          var adgModifiers = abpModifiers.map(function (modifier) {
            if (modifier.indexOf(validator.REDIRECT_RULE_TYPES.ABP.redirectMarker) > -1) {
              var abpName = substringAfter$1(modifier, validator.REDIRECT_RULE_TYPES.ABP.redirectMarker);
              var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
              return "".concat(validator.REDIRECT_RULE_TYPES.ADG.redirectMarker).concat(adgName);
            }
            return modifier;
          }).join(COMMA_SEPARATOR);
          return "".concat(firstPartOfRule, "$").concat(adgModifiers);
        };
        var convertRedirectToAdg = function convertRedirectToAdg(rule) {
          var result;
          if (validator.isUboRedirectCompatibleWithAdg(rule)) {
            result = convertUboRedirectToAdg(rule);
          } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
            result = convertAbpRedirectToAdg(rule);
          } else if (validator.isValidAdgRedirectRule(rule)) {
            result = rule;
          }
          return result;
        };
        var convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
          if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {
            throw new Error("Unable to convert for uBO - unsupported redirect in rule: ".concat(rule));
          }
          var basePart = substringBefore(rule, '$');
          var adgModifiers = validator.parseModifiers(rule);
          var adgMarkerData = getMarkerData(adgModifiers, validator.REDIRECT_RULE_TYPES.ADG, rule);
          var adgRedirectName = adgModifiers[adgMarkerData.index].slice(adgMarkerData.marker.length);
          if (!validator.hasValidContentType(rule)) {
            var sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {
              return el.NAME === adgRedirectName;
            });
            if (typeof sourceTypesData === 'undefined') {
              throw new Error("Unable to convert for uBO - no types to add for specific redirect in rule: ".concat(rule));
            }
            var additionModifiers = sourceTypesData.TYPES;
            adgModifiers.push.apply(adgModifiers, toConsumableArray(additionModifiers));
          }
          var uboModifiers = adgModifiers.map(function (el, index) {
            if (index === adgMarkerData.index) {
              var uboMarker = adgMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.UBO.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.UBO.redirectMarker;
              var uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];
              return "".concat(uboMarker).concat(uboRedirectName);
            }
            return el;
          }).join(COMMA_SEPARATOR);
          return "".concat(basePart, "$").concat(uboModifiers);
        };
        function GoogleAnalytics(source) {
          var Tracker = function Tracker() {};
          var proto = Tracker.prototype;
          proto.get = noopFunc;
          proto.set = noopFunc;
          proto.send = noopFunc;
          var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga';
          function ga(a) {
            var len = arguments.length;
            if (len === 0) {
              return;
            }
            var lastArg = arguments[len - 1];
            var replacer;
            if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {
              replacer = lastArg.hitCallback;
            } else if (typeof lastArg === 'function') {
              replacer = function replacer() {
                lastArg(ga.create());
              };
            }
            try {
              setTimeout(replacer, 1);
            } catch (ex) {}
          }
          ga.create = function () {
            return new Tracker();
          };
          ga.getByName = function () {
            return new Tracker();
          };
          ga.getAll = function () {
            return [new Tracker()];
          };
          ga.remove = noopFunc;
          ga.loaded = true;
          window[googleAnalyticsName] = ga;
          var _window = window,
              dataLayer = _window.dataLayer,
              google_optimize = _window.google_optimize;
          if (dataLayer instanceof Object === false) {
            return;
          }
          if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
            dataLayer.hide.end();
          }
          var handleCallback = function handleCallback(dataObj, funcName) {
            if (dataObj && typeof dataObj[funcName] === 'function') {
              setTimeout(dataObj[funcName]);
            }
          };
          if (typeof dataLayer.push === 'function') {
            dataLayer.push = function (data) {
              if (data instanceof Object) {
                handleCallback(data, 'eventCallback');
                for (var key in data) {
                  handleCallback(data[key], 'event_callback');
                }
                if (!data.hasOwnProperty('eventCallback') && !data.hasOwnProperty('eventCallback')) {
                  [].push.call(window.dataLayer, data);
                }
              }
              if (Array.isArray(data)) {
                data.forEach(function (arg) {
                  handleCallback(arg, 'callback');
                });
              }
              return noopFunc;
            };
          }
          if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
            var googleOptimizeWrapper = {
              get: noopFunc
            };
            window.google_optimize = googleOptimizeWrapper;
          }
          hit(source);
        }
        GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js',
        'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
        GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];
        function GoogleAnalyticsGa(source) {
          function Gaq() {}
          Gaq.prototype.Na = noopFunc;
          Gaq.prototype.O = noopFunc;
          Gaq.prototype.Sa = noopFunc;
          Gaq.prototype.Ta = noopFunc;
          Gaq.prototype.Va = noopFunc;
          Gaq.prototype._createAsyncTracker = noopFunc;
          Gaq.prototype._getAsyncTracker = noopFunc;
          Gaq.prototype._getPlugin = noopFunc;
          Gaq.prototype.push = function (data) {
            if (typeof data === 'function') {
              data();
              return;
            }
            if (Array.isArray(data) === false) {
              return;
            }
            if (typeof data[0] === 'string' && /(^|\.)_link$/.test(data[0]) && typeof data[1] === 'string') {
              window.location.assign(data[1]);
            }
            if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
              data[2]();
            }
          };
          var gaq = new Gaq();
          var asyncTrackers = window._gaq || [];
          if (Array.isArray(asyncTrackers)) {
            while (asyncTrackers[0]) {
              gaq.push(asyncTrackers.shift());
            }
          }
          window._gaq = gaq.qf = gaq;
          function Gat() {}
          var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
          var tracker = api.reduce(function (res, funcName) {
            res[funcName] = noopFunc;
            return res;
          }, {});
          tracker._getLinkerUrl = function (a) {
            return a;
          };
          tracker._link = function (url) {
            if (typeof url !== 'string') {
              return;
            }
            try {
              window.location.assign(url);
            } catch (e) {
              if (source.verbose) {
                console.log(e);
              }
            }
          };
          Gat.prototype._anonymizeIP = noopFunc;
          Gat.prototype._createTracker = noopFunc;
          Gat.prototype._forceSSL = noopFunc;
          Gat.prototype._getPlugin = noopFunc;
          Gat.prototype._getTracker = function () {
            return tracker;
          };
          Gat.prototype._getTrackerByName = function () {
            return tracker;
          };
          Gat.prototype._getTrackers = noopFunc;
          Gat.prototype.aa = noopFunc;
          Gat.prototype.ab = noopFunc;
          Gat.prototype.hb = noopFunc;
          Gat.prototype.la = noopFunc;
          Gat.prototype.oa = noopFunc;
          Gat.prototype.pa = noopFunc;
          Gat.prototype.u = noopFunc;
          var gat = new Gat();
          window._gat = gat;
          hit(source);
        }
        GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
        GoogleAnalyticsGa.injections = [hit, noopFunc];
        function GoogleSyndicationAdsByGoogle(source) {
          window.adsbygoogle = {
            loaded: true,
            push: function push(arg) {
              if (typeof this.length === 'undefined') {
                this.length = 0;
                this.length += 1;
              }
              if (arg !== null && arg instanceof Object && arg.constructor.name === 'Object') {
                for (var _i = 0, _Object$keys = Object.keys(arg); _i < _Object$keys.length; _i++) {
                  var key = _Object$keys[_i];
                  if (typeof arg[key] === 'function') {
                    try {
                      arg[key].call();
                    } catch (_unused) {
                    }
                  }
                }
              }
            }
          };
          var adElems = document.querySelectorAll('.adsbygoogle');
          var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
          var statusAttrName = 'data-adsbygoogle-status';
          var ASWIFT_IFRAME_MARKER = 'aswift_';
          var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
          var executed = false;
          for (var i = 0; i < adElems.length; i += 1) {
            var adElemChildNodes = adElems[i].childNodes;
            var childNodesQuantity = adElemChildNodes.length;
            var areIframesDefined = false;
            if (childNodesQuantity > 0) {
              areIframesDefined = childNodesQuantity === 2
              && adElemChildNodes[0].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1
              && adElemChildNodes[1].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;
            }
            if (!areIframesDefined) {
              adElems[i].setAttribute(statusAttrName, 'done');
              var aswiftIframe = document.createElement('iframe');
              aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i);
              aswiftIframe.style = css;
              adElems[i].appendChild(aswiftIframe);
              var innerAswiftIframe = document.createElement('iframe');
              aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
              var googleadsIframe = document.createElement('iframe');
              googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);
              googleadsIframe.style = css;
              adElems[i].appendChild(googleadsIframe);
              var innerGoogleadsIframe = document.createElement('iframe');
              googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
              executed = true;
            }
          }
          if (executed) {
            hit(source);
          }
        }
        GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
        GoogleSyndicationAdsByGoogle.injections = [hit];
        function GoogleTagServicesGpt(source) {
          var slots = new Map();
          var slotsById = new Map();
          var eventCallbacks = new Map();
          var addEventListener = function addEventListener(name, listener) {
            if (!eventCallbacks.has(name)) {
              eventCallbacks.set(name, new Set());
            }
            eventCallbacks.get(name).add(listener);
            return this;
          };
          var removeEventListener = function removeEventListener(name, listener) {
            if (eventCallbacks.has(name)) {
              return eventCallbacks.get(name).delete(listener);
            }
            return false;
          };
          var fireSlotEvent = function fireSlotEvent(name, slot) {
            return new Promise(function (resolve) {
              requestAnimationFrame(function () {
                var size = [0, 0];
                var callbacksSet = eventCallbacks.get(name) || [];
                var callbackArray = Array.from(callbacksSet);
                for (var i = 0; i < callbackArray.length; i += 1) {
                  callbackArray[i]({
                    isEmpty: true,
                    size: size,
                    slot: slot
                  });
                }
                resolve();
              });
            });
          };
          var displaySlot = function displaySlot(slot) {
            if (!slot) {
              return;
            }
            var id = slot.getSlotElementId();
            if (!document.getElementById(id)) {
              return;
            }
            var parent = document.getElementById(id);
            if (parent) {
              parent.appendChild(document.createElement('div'));
            }
            fireSlotEvent('slotRenderEnded', slot);
            fireSlotEvent('slotRequested', slot);
            fireSlotEvent('slotResponseReceived', slot);
            fireSlotEvent('slotOnload', slot);
            fireSlotEvent('impressionViewable', slot);
          };
          var companionAdsService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            enableSyncLoading: noopFunc,
            setRefreshUnfilledSlots: noopFunc,
            getSlots: noopArray
          };
          var contentService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            setContent: noopFunc
          };
          function PassbackSlot() {}
          PassbackSlot.prototype.display = noopFunc;
          PassbackSlot.prototype.get = noopNull;
          PassbackSlot.prototype.set = noopThis;
          PassbackSlot.prototype.setClickUrl = noopThis;
          PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
          PassbackSlot.prototype.setTargeting = noopThis;
          PassbackSlot.prototype.updateTargetingFromMap = noopThis;
          function SizeMappingBuilder() {}
          SizeMappingBuilder.prototype.addSize = noopThis;
          SizeMappingBuilder.prototype.build = noopNull;
          function Slot(adUnitPath, creatives, optDiv) {
            this.adUnitPath = adUnitPath;
            this.creatives = creatives;
            this.optDiv = optDiv;
            if (slotsById.has(optDiv)) {
              var _document$getElementB;
              (_document$getElementB = document.getElementById(optDiv)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
              return slotsById.get(optDiv);
            }
            slotsById.set(optDiv, this);
          }
          Slot.prototype.addService = noopThis;
          Slot.prototype.clearCategoryExclusions = noopThis;
          Slot.prototype.clearTargeting = noopThis;
          Slot.prototype.defineSizeMapping = noopThis;
          Slot.prototype.get = noopNull;
          Slot.prototype.getAdUnitPath = function () {
            return this.adUnitPath;
          };
          Slot.prototype.getAttributeKeys = noopArray;
          Slot.prototype.getCategoryExclusions = noopArray;
          Slot.prototype.getDomId = function () {
            return this.optDiv;
          };
          Slot.prototype.getSlotElementId = function () {
            return this.optDiv;
          };
          Slot.prototype.getSlotId = noopThis;
          Slot.prototype.getSizes = noopArray;
          Slot.prototype.getTargeting = noopArray;
          Slot.prototype.getTargetingKeys = noopArray;
          Slot.prototype.set = noopThis;
          Slot.prototype.setCategoryExclusion = noopThis;
          Slot.prototype.setClickUrl = noopThis;
          Slot.prototype.setCollapseEmptyDiv = noopThis;
          Slot.prototype.setTargeting = noopThis;
          var pubAdsService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            clear: noopFunc,
            clearCategoryExclusions: noopThis,
            clearTagForChildDirectedTreatment: noopThis,
            clearTargeting: noopThis,
            collapseEmptyDivs: noopFunc,
            defineOutOfPagePassback: function defineOutOfPagePassback() {
              return new PassbackSlot();
            },
            definePassback: function definePassback() {
              return new PassbackSlot();
            },
            disableInitialLoad: noopFunc,
            display: noopFunc,
            enableAsyncRendering: noopFunc,
            enableLazyLoad: noopFunc,
            enableSingleRequest: noopFunc,
            enableSyncRendering: noopFunc,
            enableVideoAds: noopFunc,
            get: noopNull,
            getAttributeKeys: noopArray,
            getTargeting: noopArray,
            getTargetingKeys: noopArray,
            getSlots: noopArray,
            isInitialLoadDisabled: trueFunc,
            refresh: noopFunc,
            set: noopThis,
            setCategoryExclusion: noopThis,
            setCentering: noopFunc,
            setCookieOptions: noopThis,
            setForceSafeFrame: noopThis,
            setLocation: noopThis,
            setPublisherProvidedId: noopThis,
            setRequestNonPersonalizedAds: noopThis,
            setSafeFrameConfig: noopThis,
            setTagForChildDirectedTreatment: noopThis,
            setTargeting: noopThis,
            setVideoContent: noopThis,
            updateCorrelator: noopFunc
          };
          var getNewSlot = function getNewSlot(adUnitPath, creatives, optDiv) {
            return new Slot(adUnitPath, creatives, optDiv);
          };
          var _window = window,
              _window$googletag = _window.googletag,
              googletag = _window$googletag === void 0 ? {} : _window$googletag;
          var _googletag$cmd = googletag.cmd,
              cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
          googletag.apiReady = true;
          googletag.cmd = [];
          googletag.cmd.push = function (a) {
            try {
              a();
            } catch (ex) {}
            return 1;
          };
          googletag.companionAds = function () {
            return companionAdsService;
          };
          googletag.content = function () {
            return contentService;
          };
          googletag.defineOutOfPageSlot = getNewSlot;
          googletag.defineSlot = getNewSlot;
          googletag.destroySlots = function () {
            slots.clear();
            slotsById.clear();
          };
          googletag.disablePublisherConsole = noopFunc;
          googletag.display = function (arg) {
            var id;
            if (arg !== null && arg !== void 0 && arg.getSlotElementId) {
              id = arg.getSlotElementId();
            } else if (arg !== null && arg !== void 0 && arg.nodeType) {
              id = arg.id;
            } else {
              id = String(arg);
            }
            displaySlot(slotsById.get(id));
          };
          googletag.enableServices = noopFunc;
          googletag.getVersion = noopStr;
          googletag.pubads = function () {
            return pubAdsService;
          };
          googletag.pubadsReady = true;
          googletag.setAdIframeTitle = noopFunc;
          googletag.sizeMapping = function () {
            return new SizeMappingBuilder();
          };
          window.googletag = googletag;
          while (cmd.length !== 0) {
            googletag.cmd.push(cmd.shift());
          }
          hit(source);
        }
        GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
        GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr, trueFunc];
        function ScoreCardResearchBeacon(source) {
          window.COMSCORE = {
            purge: function purge() {
              window._comscore = [];
            },
            beacon: function beacon() {}
          };
          hit(source);
        }
        ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
        ScoreCardResearchBeacon.injections = [hit];
        function metrikaYandexTag(source) {
          var asyncCallbackFromOptions = function asyncCallbackFromOptions(id, param) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var callback = options.callback;
            var ctx = options.ctx;
            if (typeof callback === 'function') {
              callback = ctx !== undefined ? callback.bind(ctx) : callback;
              setTimeout(function () {
                return callback();
              });
            }
          };
          var addFileExtension = noopFunc;
          var extLink = asyncCallbackFromOptions;
          var file = asyncCallbackFromOptions;
          var getClientID = function getClientID(id, cb) {
            if (!cb) {
              return;
            }
            setTimeout(cb(null));
          };
          var hitFunc = asyncCallbackFromOptions;
          var notBounce = asyncCallbackFromOptions;
          var params = noopFunc;
          var reachGoal = function reachGoal(id, target, params, callback, ctx) {
            asyncCallbackFromOptions(null, null, {
              callback: callback,
              ctx: ctx
            });
          };
          var setUserID = noopFunc;
          var userParams = noopFunc;
          var destruct = noopFunc;
          var api = {
            addFileExtension: addFileExtension,
            extLink: extLink,
            file: file,
            getClientID: getClientID,
            hit: hitFunc,
            notBounce: notBounce,
            params: params,
            reachGoal: reachGoal,
            setUserID: setUserID,
            userParams: userParams,
            destruct: destruct
          };
          function ym(id, funcName) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return api[funcName] && api[funcName].apply(api, [id].concat(args));
          }
          ym.a = [];
          function init(id) {
            window["yaCounter".concat(id)] = api;
            document.dispatchEvent(new Event("yacounter".concat(id, "inited")));
          }
          if (typeof window.ym === 'undefined') {
            window.ym = ym;
          } else if (window.ym && window.ym.a) {
            var counters = window.ym.a;
            window.ym = ym;
            counters.forEach(function (params) {
              var id = params[0];
              init(id);
            });
          }
          hit(source);
        }
        metrikaYandexTag.names = ['metrika-yandex-tag'];
        metrikaYandexTag.injections = [hit, noopFunc];
        function metrikaYandexWatch(source) {
          var cbName = 'yandex_metrika_callbacks';
          var asyncCallbackFromOptions = function asyncCallbackFromOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var callback = options.callback;
            var ctx = options.ctx;
            if (typeof callback === 'function') {
              callback = ctx !== undefined ? callback.bind(ctx) : callback;
              setTimeout(function () {
                return callback();
              });
            }
          };
          function Metrika() {}
          Metrika.counters = noopArray;
          Metrika.prototype.addFileExtension = noopFunc;
          Metrika.prototype.getClientID = noopFunc;
          Metrika.prototype.setUserID = noopFunc;
          Metrika.prototype.userParams = noopFunc;
          Metrika.prototype.params = noopFunc;
          Metrika.prototype.counters = noopArray;
          Metrika.prototype.extLink = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.file = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.hit = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
            asyncCallbackFromOptions({
              callback: cb,
              ctx: ctx
            });
          };
          Metrika.prototype.notBounce = asyncCallbackFromOptions;
          if (window.Ya) {
            window.Ya.Metrika = Metrika;
          } else {
            window.Ya = {
              Metrika: Metrika
            };
          }
          if (window[cbName] && Array.isArray(window[cbName])) {
            window[cbName].forEach(function (func) {
              if (typeof func === 'function') {
                func();
              }
            });
          }
          hit(source);
        }
        metrikaYandexWatch.names = ['metrika-yandex-watch'];
        metrikaYandexWatch.injections = [hit, noopFunc, noopArray];
        function Pardot(source) {
          window.piVersion = '1.0.2';
          window.piScriptNum = 0;
          window.piScriptObj = [];
          window.checkNamespace = noopFunc;
          window.getPardotUrl = noopStr;
          window.piGetParameter = noopNull;
          window.piSetCookie = noopFunc;
          window.piGetCookie = noopStr;
          function piTracker() {
            window.pi = {
              tracker: {
                visitor_id: '',
                visitor_id_sign: '',
                pi_opt_in: '',
                campaign_id: ''
              }
            };
            window.piScriptNum += 1;
          }
          window.piResponse = noopFunc;
          window.piTracker = piTracker;
          piTracker();
          hit(source);
        }
        Pardot.names = ['pardot-1.0'];
        Pardot.injections = [hit, noopFunc, noopStr, noopNull];
        function AmazonApstag(source) {
          var apstagWrapper = {
            fetchBids: function fetchBids(a, b) {
              if (typeof b === 'function') {
                b([]);
              }
            },
            init: noopFunc,
            setDisplayBids: noopFunc,
            targetingKeys: noopFunc
          };
          window.apstag = apstagWrapper;
          hit(source);
        }
        AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
        AmazonApstag.injections = [hit, noopFunc];
        function Matomo(source) {
          var Tracker = function Tracker() {};
          Tracker.prototype.setDoNotTrack = noopFunc;
          Tracker.prototype.setDomains = noopFunc;
          Tracker.prototype.setCustomDimension = noopFunc;
          Tracker.prototype.trackPageView = noopFunc;
          var AsyncTracker = function AsyncTracker() {};
          AsyncTracker.prototype.addListener = noopFunc;
          var matomoWrapper = {
            getTracker: function getTracker() {
              return new Tracker();
            },
            getAsyncTracker: function getAsyncTracker() {
              return new AsyncTracker();
            }
          };
          window.Piwik = matomoWrapper;
          hit(source);
        }
        Matomo.names = ['matomo'];
        Matomo.injections = [hit, noopFunc];
        function Fingerprintjs2(source) {
          var browserId = '';
          for (var i = 0; i < 8; i += 1) {
            browserId += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
          }
          var Fingerprint2 = function Fingerprint2() {};
          Fingerprint2.get = function (options, callback) {
            if (!callback) {
              callback = options;
            }
            setTimeout(function () {
              if (callback) {
                callback(browserId, []);
              }
            }, 1);
          };
          Fingerprint2.prototype = {
            get: Fingerprint2.get
          };
          window.Fingerprint2 = Fingerprint2;
          hit(source);
        }
        Fingerprintjs2.names = ['fingerprintjs2',
        'ubo-fingerprint2.js',
        'fingerprint2.js'];
        Fingerprintjs2.injections = [hit];
        function Fingerprintjs3(source) {
          var visitorId = function () {
            var id = '';
            for (var i = 0; i < 8; i += 1) {
              id += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
            }
            return id;
          }();
          var FingerprintJS = function FingerprintJS() {};
          FingerprintJS.prototype = {
            load: function load() {
              return Promise.resolve(new FingerprintJS());
            },
            get: function get() {
              return Promise.resolve({
                visitorId: visitorId
              });
            },
            hashComponents: noopStr
          };
          window.FingerprintJS = new FingerprintJS();
          hit(source);
        }
        Fingerprintjs3.names = ['fingerprintjs3',
        'ubo-fingerprint3.js',
        'fingerprint3.js'];
        Fingerprintjs3.injections = [hit, noopStr];
        function Gemius(source) {
          var GemiusPlayer = function GemiusPlayer() {};
          GemiusPlayer.prototype = {
            setVideoObject: noopFunc,
            newProgram: noopFunc,
            programEvent: noopFunc,
            newAd: noopFunc,
            adEvent: noopFunc
          };
          window.GemiusPlayer = GemiusPlayer;
          hit(source);
        }
        Gemius.names = ['gemius'];
        Gemius.injections = [hit, noopFunc];
        function ATInternetSmartTag(source) {
          var setNoopFuncWrapper = {
            set: noopFunc
          };
          var sendNoopFuncWrapper = {
            send: noopFunc
          };
          var ecommerceWrapper = {
            displayCart: {
              products: setNoopFuncWrapper,
              cart: setNoopFuncWrapper
            },
            updateCart: {
              cart: setNoopFuncWrapper
            },
            displayProduct: {
              products: setNoopFuncWrapper
            },
            displayPageProduct: {
              products: setNoopFuncWrapper
            },
            addProduct: {
              products: setNoopFuncWrapper
            },
            removeProduct: {
              products: setNoopFuncWrapper
            }
          };
          var tag = function tag() {};
          tag.prototype = {
            setConfig: noopFunc,
            setParam: noopFunc,
            dispatch: noopFunc,
            customVars: setNoopFuncWrapper,
            publisher: setNoopFuncWrapper,
            order: setNoopFuncWrapper,
            click: sendNoopFuncWrapper,
            clickListener: sendNoopFuncWrapper,
            internalSearch: {
              set: noopFunc,
              send: noopFunc
            },
            ecommerce: ecommerceWrapper,
            identifiedVisitor: {
              unset: noopFunc
            },
            page: {
              set: noopFunc,
              send: noopFunc
            },
            selfPromotion: {
              add: noopFunc,
              send: noopFunc
            },
            privacy: {
              setVisitorMode: noopFunc,
              getVisitorMode: noopFunc,
              hit: noopFunc
            },
            richMedia: {
              add: noopFunc,
              send: noopFunc,
              remove: noopFunc,
              removeAll: noopFunc
            }
          };
          var smartTagWrapper = {
            Tracker: {
              Tag: function Tag() {
                return new tag();
              }
            }
          };
          window.ATInternet = smartTagWrapper;
          hit(source);
        }
        ATInternetSmartTag.names = ['ati-smarttag'];
        ATInternetSmartTag.injections = [hit, noopFunc];
        function preventBab2(source) {
          var script = document.currentScript;
          if (script === null) {
            return;
          }
          var url = script.src;
          if (typeof url !== 'string') {
            return;
          }
          var domainsStr = ['adclixx\\.net', 'adnetasia\\.com', 'adtrackers\\.net', 'bannertrack\\.net'].join('|');
          var matchStr = "^https?://[\\w-]+\\.(".concat(domainsStr, ")/.");
          var domainsRegex = new RegExp(matchStr);
          if (domainsRegex.test(url) === false) {
            return;
          }
          window.nH7eXzOsG = 858;
          hit(source);
        }
        preventBab2.names = ['prevent-bab2',
        'nobab2.js'];
        preventBab2.injections = [hit];
        function GoogleIma3(source) {
          var VERSION = '3.453.0';
          var ima = {};
          var AdDisplayContainer = function AdDisplayContainer() {};
          AdDisplayContainer.prototype.destroy = noopFunc;
          AdDisplayContainer.prototype.initialize = noopFunc;
          var ImaSdkSettings = function ImaSdkSettings() {};
          ImaSdkSettings.CompanionBackfillMode = {
            ALWAYS: 'always',
            ON_MASTER_AD: 'on_master_ad'
          };
          ImaSdkSettings.VpaidMode = {
            DISABLED: 0,
            ENABLED: 1,
            INSECURE: 2
          };
          ImaSdkSettings.prototype = {
            c: true,
            f: {},
            i: false,
            l: '',
            p: '',
            r: 0,
            t: '',
            v: '',
            getCompanionBackfill: noopFunc,
            getDisableCustomPlaybackForIOS10Plus: function getDisableCustomPlaybackForIOS10Plus() {
              return this.i;
            },
            getDisabledFlashAds: function getDisabledFlashAds() {
              return true;
            },
            getFeatureFlags: function getFeatureFlags() {
              return this.f;
            },
            getLocale: function getLocale() {
              return this.l;
            },
            getNumRedirects: function getNumRedirects() {
              return this.r;
            },
            getPlayerType: function getPlayerType() {
              return this.t;
            },
            getPlayerVersion: function getPlayerVersion() {
              return this.v;
            },
            getPpid: function getPpid() {
              return this.p;
            },
            getVpaidMode: function getVpaidMode() {
              return this.C;
            },
            isCookiesEnabled: function isCookiesEnabled() {
              return this.c;
            },
            isVpaidAdapter: function isVpaidAdapter() {
              return this.M;
            },
            setCompanionBackfill: noopFunc,
            setAutoPlayAdBreaks: function setAutoPlayAdBreaks(a) {
              this.K = a;
            },
            setCookiesEnabled: function setCookiesEnabled(c) {
              this.c = !!c;
            },
            setDisableCustomPlaybackForIOS10Plus: function setDisableCustomPlaybackForIOS10Plus(i) {
              this.i = !!i;
            },
            setDisableFlashAds: noopFunc,
            setFeatureFlags: function setFeatureFlags(f) {
              this.f = !!f;
            },
            setIsVpaidAdapter: function setIsVpaidAdapter(a) {
              this.M = a;
            },
            setLocale: function setLocale(l) {
              this.l = !!l;
            },
            setNumRedirects: function setNumRedirects(r) {
              this.r = !!r;
            },
            setPageCorrelator: function setPageCorrelator(a) {
              this.R = a;
            },
            setPlayerType: function setPlayerType(t) {
              this.t = !!t;
            },
            setPlayerVersion: function setPlayerVersion(v) {
              this.v = !!v;
            },
            setPpid: function setPpid(p) {
              this.p = !!p;
            },
            setVpaidMode: function setVpaidMode(a) {
              this.C = a;
            },
            setSessionId: noopFunc,
            setStreamCorrelator: noopFunc,
            setVpaidAllowed: noopFunc,
            CompanionBackfillMode: {
              ALWAYS: 'always',
              ON_MASTER_AD: 'on_master_ad'
            },
            VpaidMode: {
              DISABLED: 0,
              ENABLED: 1,
              INSECURE: 2
            }
          };
          var managerLoaded = false;
          var EventHandler = function EventHandler() {
            this.listeners = new Map();
            this._dispatch = function (e) {
              var listeners = this.listeners.get(e.type) || [];
              for (var _i = 0, _Array$from = Array.from(listeners); _i < _Array$from.length; _i++) {
                var listener = _Array$from[_i];
                try {
                  listener(e);
                } catch (r) {
                  console.error(r);
                }
              }
            };
            this.addEventListener = function (t, c) {
              if (!this.listeners.has(t)) {
                this.listeners.set(t, new Set());
              }
              this.listeners.get(t).add(c);
            };
            this.removeEventListener = function (t, c) {
              var _this$listeners$get;
              (_this$listeners$get = this.listeners.get(t)) === null || _this$listeners$get === void 0 ? void 0 : _this$listeners$get.delete(c);
            };
          };
          var AdsManager = new EventHandler();
          AdsManager.volume = 1;
          AdsManager.collapse = noopFunc;
          AdsManager.configureAdsManager = noopFunc;
          AdsManager.destroy = noopFunc;
          AdsManager.discardAdBreak = noopFunc;
          AdsManager.expand = noopFunc;
          AdsManager.focus = noopFunc;
          AdsManager.getAdSkippableState = function () {
            return false;
          };
          AdsManager.getCuePoints = function () {
            return [0];
          };
          AdsManager.getCurrentAd = function () {
            return currentAd;
          };
          AdsManager.getCurrentAdCuePoints = function () {
            return [];
          };
          AdsManager.getRemainingTime = function () {
            return 0;
          };
          AdsManager.getVolume = function () {
            return this.volume;
          };
          AdsManager.init = noopFunc;
          AdsManager.isCustomClickTrackingUsed = function () {
            return false;
          };
          AdsManager.isCustomPlaybackUsed = function () {
            return false;
          };
          AdsManager.pause = noopFunc;
          AdsManager.requestNextAdBreak = noopFunc;
          AdsManager.resize = noopFunc;
          AdsManager.resume = noopFunc;
          AdsManager.setVolume = function (v) {
            this.volume = v;
          };
          AdsManager.skip = noopFunc;
          AdsManager.start = function () {
            for (var _i2 = 0, _arr = [AdEvent.Type.ALL_ADS_COMPLETED, AdEvent.Type.CONTENT_RESUME_REQUESTED]; _i2 < _arr.length; _i2++) {
              var type = _arr[_i2];
              try {
                this._dispatch(new ima.AdEvent(type));
              } catch (e) {
                console.error(e);
              }
            }
          };
          AdsManager.stop = noopFunc;
          AdsManager.updateAdsRenderingSettings = noopFunc;
          var manager = Object.create(AdsManager);
          var AdsManagerLoadedEvent = function AdsManagerLoadedEvent(type, adsRequest, userRequestContext) {
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
          };
          AdsManagerLoadedEvent.prototype = {
            getAdsManager: function getAdsManager() {
              return manager;
            },
            getUserRequestContext: function getUserRequestContext() {
              if (this.userRequestContext) {
                return this.userRequestContext;
              }
              return {};
            }
          };
          AdsManagerLoadedEvent.Type = {
            ADS_MANAGER_LOADED: 'adsManagerLoaded'
          };
          var AdsLoader = EventHandler;
          AdsLoader.prototype.settings = new ImaSdkSettings();
          AdsLoader.prototype.contentComplete = noopFunc;
          AdsLoader.prototype.destroy = noopFunc;
          AdsLoader.prototype.getSettings = function () {
            return this.settings;
          };
          AdsLoader.prototype.getVersion = function () {
            return VERSION;
          };
          AdsLoader.prototype.requestAds = function (adsRequest, userRequestContext) {
            var _this = this;
            if (!managerLoaded) {
              managerLoaded = true;
              requestAnimationFrame(function () {
                var ADS_MANAGER_LOADED = AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED;
                _this._dispatch(new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED, adsRequest, userRequestContext));
              });
              var e = new ima.AdError('adPlayError', 1205, 1205, 'The browser prevented playback initiated without user interaction.', adsRequest, userRequestContext);
              requestAnimationFrame(function () {
                _this._dispatch(new ima.AdErrorEvent(e));
              });
            }
          };
          var AdsRenderingSettings = noopFunc;
          var AdsRequest = function AdsRequest() {};
          AdsRequest.prototype = {
            setAdWillAutoPlay: noopFunc,
            setAdWillPlayMuted: noopFunc,
            setContinuousPlayback: noopFunc
          };
          var AdPodInfo = function AdPodInfo() {};
          AdPodInfo.prototype = {
            getAdPosition: function getAdPosition() {
              return 1;
            },
            getIsBumper: function getIsBumper() {
              return false;
            },
            getMaxDuration: function getMaxDuration() {
              return -1;
            },
            getPodIndex: function getPodIndex() {
              return 1;
            },
            getTimeOffset: function getTimeOffset() {
              return 0;
            },
            getTotalAds: function getTotalAds() {
              return 1;
            }
          };
          var Ad = function Ad() {};
          Ad.prototype = {
            pi: new AdPodInfo(),
            getAdId: function getAdId() {
              return '';
            },
            getAdPodInfo: function getAdPodInfo() {
              return this.pi;
            },
            getAdSystem: function getAdSystem() {
              return '';
            },
            getAdvertiserName: function getAdvertiserName() {
              return '';
            },
            getApiFramework: function getApiFramework() {
              return null;
            },
            getCompanionAds: function getCompanionAds() {
              return [];
            },
            getContentType: function getContentType() {
              return '';
            },
            getCreativeAdId: function getCreativeAdId() {
              return '';
            },
            getDealId: function getDealId() {
              return '';
            },
            getDescription: function getDescription() {
              return '';
            },
            getDuration: function getDuration() {
              return 8.5;
            },
            getHeight: function getHeight() {
              return 0;
            },
            getMediaUrl: function getMediaUrl() {
              return null;
            },
            getMinSuggestedDuration: function getMinSuggestedDuration() {
              return -2;
            },
            getSkipTimeOffset: function getSkipTimeOffset() {
              return -1;
            },
            getSurveyUrl: function getSurveyUrl() {
              return null;
            },
            getTitle: function getTitle() {
              return '';
            },
            getTraffickingParametersString: function getTraffickingParametersString() {
              return '';
            },
            getUiElements: function getUiElements() {
              return [''];
            },
            getUniversalAdIdRegistry: function getUniversalAdIdRegistry() {
              return 'unknown';
            },
            getUniversalAdIds: function getUniversalAdIds() {
              return [''];
            },
            getUniversalAdIdValue: function getUniversalAdIdValue() {
              return 'unknown';
            },
            getVastMediaBitrate: function getVastMediaBitrate() {
              return 0;
            },
            getVastMediaHeight: function getVastMediaHeight() {
              return 0;
            },
            getVastMediaWidth: function getVastMediaWidth() {
              return 0;
            },
            getWidth: function getWidth() {
              return 0;
            },
            getWrapperAdIds: function getWrapperAdIds() {
              return [''];
            },
            getWrapperAdSystems: function getWrapperAdSystems() {
              return [''];
            },
            getWrapperCreativeIds: function getWrapperCreativeIds() {
              return [''];
            },
            isLinear: function isLinear() {
              return true;
            },
            isSkippable: function isSkippable() {
              return true;
            }
          };
          var CompanionAd = function CompanionAd() {};
          CompanionAd.prototype = {
            getAdSlotId: function getAdSlotId() {
              return '';
            },
            getContent: function getContent() {
              return '';
            },
            getContentType: function getContentType() {
              return '';
            },
            getHeight: function getHeight() {
              return 1;
            },
            getWidth: function getWidth() {
              return 1;
            }
          };
          var AdError = function AdError(type, code, vast, message, adsRequest, userRequestContext) {
            this.errorCode = code;
            this.message = message;
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
            this.getErrorCode = function () {
              return this.errorCode;
            };
            this.getInnerError = function () {};
            this.getMessage = function () {
              return this.message;
            };
            this.getType = function () {
              return this.type;
            };
            this.getVastErrorCode = function () {
              return this.vastErrorCode;
            };
            this.toString = function () {
              return "AdError ".concat(this.errorCode, ": ").concat(this.message);
            };
          };
          AdError.ErrorCode = {};
          AdError.Type = {};
          var isEngadget = function isEngadget() {
            try {
              for (var _i3 = 0, _Object$values = Object.values(window.vidible._getContexts()); _i3 < _Object$values.length; _i3++) {
                var _ctx$getPlayer, _ctx$getPlayer$div;
                var ctx = _Object$values[_i3];
                if ((_ctx$getPlayer = ctx.getPlayer()) !== null && _ctx$getPlayer !== void 0 && (_ctx$getPlayer$div = _ctx$getPlayer.div) !== null && _ctx$getPlayer$div !== void 0 && _ctx$getPlayer$div.innerHTML.includes('www.engadget.com')) {
                  return true;
                }
              }
            } catch (e) {}
            return false;
          };
          var currentAd = isEngadget() ? undefined : new Ad();
          var AdEvent = function AdEvent(type) {
            this.type = type;
          };
          AdEvent.prototype = {
            getAd: function getAd() {
              return currentAd;
            },
            getAdData: function getAdData() {}
          };
          AdEvent.Type = {
            AD_BREAK_READY: 'adBreakReady',
            AD_BUFFERING: 'adBuffering',
            AD_CAN_PLAY: 'adCanPlay',
            AD_METADATA: 'adMetadata',
            AD_PROGRESS: 'adProgress',
            ALL_ADS_COMPLETED: 'allAdsCompleted',
            CLICK: 'click',
            COMPLETE: 'complete',
            CONTENT_PAUSE_REQUESTED: 'contentPauseRequested',
            CONTENT_RESUME_REQUESTED: 'contentResumeRequested',
            DURATION_CHANGE: 'durationChange',
            EXPANDED_CHANGED: 'expandedChanged',
            FIRST_QUARTILE: 'firstQuartile',
            IMPRESSION: 'impression',
            INTERACTION: 'interaction',
            LINEAR_CHANGE: 'linearChange',
            LINEAR_CHANGED: 'linearChanged',
            LOADED: 'loaded',
            LOG: 'log',
            MIDPOINT: 'midpoint',
            PAUSED: 'pause',
            RESUMED: 'resume',
            SKIPPABLE_STATE_CHANGED: 'skippableStateChanged',
            SKIPPED: 'skip',
            STARTED: 'start',
            THIRD_QUARTILE: 'thirdQuartile',
            USER_CLOSE: 'userClose',
            VIDEO_CLICKED: 'videoClicked',
            VIDEO_ICON_CLICKED: 'videoIconClicked',
            VIEWABLE_IMPRESSION: 'viewable_impression',
            VOLUME_CHANGED: 'volumeChange',
            VOLUME_MUTED: 'mute'
          };
          var AdErrorEvent = function AdErrorEvent(error) {
            this.error = error;
            this.type = 'adError';
            this.getError = function () {
              return this.error;
            };
            this.getUserRequestContext = function () {
              var _this$error;
              if ((_this$error = this.error) !== null && _this$error !== void 0 && _this$error.userRequestContext) {
                return this.error.userRequestContext;
              }
              return {};
            };
          };
          AdErrorEvent.Type = {
            AD_ERROR: 'adError'
          };
          var CustomContentLoadedEvent = function CustomContentLoadedEvent() {};
          CustomContentLoadedEvent.Type = {
            CUSTOM_CONTENT_LOADED: 'deprecated-event'
          };
          var CompanionAdSelectionSettings = function CompanionAdSelectionSettings() {};
          CompanionAdSelectionSettings.CreativeType = {
            ALL: 'All',
            FLASH: 'Flash',
            IMAGE: 'Image'
          };
          CompanionAdSelectionSettings.ResourceType = {
            ALL: 'All',
            HTML: 'Html',
            IFRAME: 'IFrame',
            STATIC: 'Static'
          };
          CompanionAdSelectionSettings.SizeCriteria = {
            IGNORE: 'IgnoreSize',
            SELECT_EXACT_MATCH: 'SelectExactMatch',
            SELECT_NEAR_MATCH: 'SelectNearMatch'
          };
          var AdCuePoints = function AdCuePoints() {};
          AdCuePoints.prototype = {
            getCuePoints: function getCuePoints() {
              return [];
            },
            getAdIdRegistry: function getAdIdRegistry() {
              return '';
            },
            getAdIsValue: function getAdIsValue() {
              return '';
            }
          };
          var AdProgressData = noopFunc;
          var UniversalAdIdInfo = function UniversalAdIdInfo() {};
          Object.assign(ima, {
            AdCuePoints: AdCuePoints,
            AdDisplayContainer: AdDisplayContainer,
            AdError: AdError,
            AdErrorEvent: AdErrorEvent,
            AdEvent: AdEvent,
            AdPodInfo: AdPodInfo,
            AdProgressData: AdProgressData,
            AdsLoader: AdsLoader,
            AdsManager: manager,
            AdsManagerLoadedEvent: AdsManagerLoadedEvent,
            AdsRenderingSettings: AdsRenderingSettings,
            AdsRequest: AdsRequest,
            CompanionAd: CompanionAd,
            CompanionAdSelectionSettings: CompanionAdSelectionSettings,
            CustomContentLoadedEvent: CustomContentLoadedEvent,
            gptProxyInstance: {},
            ImaSdkSettings: ImaSdkSettings,
            OmidAccessMode: {
              DOMAIN: 'domain',
              FULL: 'full',
              LIMITED: 'limited'
            },
            settings: new ImaSdkSettings(),
            UiElements: {
              AD_ATTRIBUTION: 'adAttribution',
              COUNTDOWN: 'countdown'
            },
            UniversalAdIdInfo: UniversalAdIdInfo,
            VERSION: VERSION,
            ViewMode: {
              FULLSCREEN: 'fullscreen',
              NORMAL: 'normal'
            }
          });
          if (!window.google) {
            window.google = {};
          }
          window.google.ima = ima;
          hit(source);
        }
        GoogleIma3.names = ['google-ima3'];
        GoogleIma3.injections = [hit, noopFunc];
        function DidomiLoader(source) {
          function UserConsentStatusForVendorSubscribe() {}
          UserConsentStatusForVendorSubscribe.prototype.filter = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendorSubscribe.prototype.subscribe = noopFunc;
          function UserConsentStatusForVendor() {}
          UserConsentStatusForVendor.prototype.first = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendor.prototype.filter = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendor.prototype.subscribe = noopFunc;
          var DidomiWrapper = {
            isConsentRequired: falseFunc,
            getUserConsentStatusForPurpose: trueFunc,
            getUserConsentStatus: trueFunc,
            getUserStatus: noopFunc,
            getRequiredPurposes: noopArray,
            getUserConsentStatusForVendor: trueFunc,
            Purposes: {
              Cookies: 'cookies'
            },
            notice: {
              configure: noopFunc,
              hide: noopFunc,
              isVisible: falseFunc,
              show: noopFunc,
              showDataProcessing: trueFunc
            },
            isUserConsentStatusPartial: falseFunc,
            on: function on() {
              return {
                actions: {},
                emitter: {},
                services: {},
                store: {}
              };
            },
            shouldConsentBeCollected: falseFunc,
            getUserConsentStatusForAll: noopFunc,
            getObservableOnUserConsentStatusForVendor: function getObservableOnUserConsentStatusForVendor() {
              return new UserConsentStatusForVendor();
            }
          };
          window.Didomi = DidomiWrapper;
          var didomiStateWrapper = {
            didomiExperimentId: '',
            didomiExperimentUserGroup: '',
            didomiGDPRApplies: 1,
            didomiIABConsent: '',
            didomiPurposesConsent: '',
            didomiPurposesConsentDenied: '',
            didomiPurposesConsentUnknown: '',
            didomiVendorsConsent: '',
            didomiVendorsConsentDenied: '',
            didomiVendorsConsentUnknown: '',
            didomiVendorsRawConsent: '',
            didomiVendorsRawConsentDenied: '',
            didomiVendorsRawConsentUnknown: ''
          };
          window.didomiState = didomiStateWrapper;
          var tcData = {
            eventStatus: 'tcloaded',
            gdprApplies: false,
            listenerId: noopFunc,
            vendor: {
              consents: []
            },
            purpose: {
              consents: []
            }
          };
          var __tcfapiWrapper = function __tcfapiWrapper(command, version, callback) {
            if (typeof callback !== 'function' || command === 'removeEventListener') {
              return;
            }
            callback(tcData, true);
          };
          window.__tcfapi = __tcfapiWrapper;
          var didomiEventListenersWrapper = {
            stub: true,
            push: noopFunc
          };
          window.didomiEventListeners = didomiEventListenersWrapper;
          var didomiOnReadyWrapper = {
            stub: true,
            push: function push(arg) {
              if (typeof arg !== 'function') {
                return;
              }
              if (document.readyState !== 'complete') {
                window.addEventListener('load', function () {
                  setTimeout(arg(window.Didomi));
                });
              } else {
                setTimeout(arg(window.Didomi));
              }
            }
          };
          window.didomiOnReady = window.didomiOnReady || didomiOnReadyWrapper;
          if (Array.isArray(window.didomiOnReady)) {
            window.didomiOnReady.forEach(function (arg) {
              if (typeof arg === 'function') {
                try {
                  setTimeout(arg(window.Didomi));
                } catch (e) {
                }
              }
            });
          }
          hit(source);
        }
        DidomiLoader.names = ['didomi-loader'];
        DidomiLoader.injections = [hit, noopFunc, noopArray, trueFunc, falseFunc];
        function Prebid(source) {
          var pushFunction = function pushFunction(arg) {
            if (typeof arg === 'function') {
              try {
                arg.call();
              } catch (ex) {
              }
            }
          };
          var pbjsWrapper = {
            addAdUnits: function addAdUnits() {},
            adServers: {
              dfp: {
                buildVideoUrl: noopStr
              }
            },
            adUnits: [],
            aliasBidder: function aliasBidder() {},
            cmd: [],
            enableAnalytics: function enableAnalytics() {},
            getHighestCpmBids: noopArray,
            libLoaded: true,
            que: [],
            requestBids: function requestBids(arg) {
              if (arg instanceof Object && arg.bidsBackHandler) {
                try {
                  arg.bidsBackHandler.call();
                } catch (ex) {
                }
              }
            },
            removeAdUnit: function removeAdUnit() {},
            setBidderConfig: function setBidderConfig() {},
            setConfig: function setConfig() {},
            setTargetingForGPTAsync: function setTargetingForGPTAsync() {}
          };
          pbjsWrapper.cmd.push = pushFunction;
          pbjsWrapper.que.push = pushFunction;
          window.pbjs = pbjsWrapper;
          hit(source);
        }
        Prebid.names = ['prebid'];
        Prebid.injections = [hit, noopFunc, noopStr, noopArray];
        function prebidAds(source) {
          window.canRunAds = true;
          window.isAdBlockActive = false;
          hit(source);
        }
        prebidAds.names = ['prebid-ads', 'ubo-prebid-ads.js', 'prebid-ads.js'];
        prebidAds.injections = [hit];
        function NaverWcslog(source) {
          window.wcs_add = {};
          window.wcs_do = noopFunc;
          window.wcs = {
            inflow: noopFunc
          };
          hit(source);
        }
        NaverWcslog.names = ['naver-wcslog'];
        NaverWcslog.injections = [hit, noopFunc];
        var redirectsList = Object.freeze({
            __proto__: null,
            noeval: noeval$1,
            GoogleAnalytics: GoogleAnalytics,
            GoogleAnalyticsGa: GoogleAnalyticsGa,
            GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
            GoogleTagServicesGpt: GoogleTagServicesGpt,
            ScoreCardResearchBeacon: ScoreCardResearchBeacon,
            metrikaYandexTag: metrikaYandexTag,
            metrikaYandexWatch: metrikaYandexWatch,
            Pardot: Pardot,
            preventFab: preventFab$1,
            preventBab: preventBab$1,
            setPopadsDummy: setPopadsDummy$1,
            preventPopadsNet: preventPopadsNet$1,
            AmazonApstag: AmazonApstag,
            Matomo: Matomo,
            Fingerprintjs2: Fingerprintjs2,
            Fingerprintjs3: Fingerprintjs3,
            Gemius: Gemius,
            ATInternetSmartTag: ATInternetSmartTag,
            preventBab2: preventBab2,
            GoogleIma3: GoogleIma3,
            DidomiLoader: DidomiLoader,
            Prebid: Prebid,
            prebidAds: prebidAds,
            NaverWcslog: NaverWcslog
        });
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var classCallCheck = _classCallCheck;
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var createClass = _createClass;
        function isNothing(subject) {
          return typeof subject === 'undefined' || subject === null;
        }
        function isObject(subject) {
          return typeof subject === 'object' && subject !== null;
        }
        function toArray(sequence) {
          if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
          return [sequence];
        }
        function extend(target, source) {
          var index, length, key, sourceKeys;
          if (source) {
            sourceKeys = Object.keys(source);
            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }
          return target;
        }
        function repeat(string, count) {
          var result = '',
              cycle;
          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }
          return result;
        }
        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }
        var isNothing_1 = isNothing;
        var isObject_1 = isObject;
        var toArray_1 = toArray;
        var repeat_1 = repeat;
        var isNegativeZero_1 = isNegativeZero;
        var extend_1 = extend;
        var common = {
          isNothing: isNothing_1,
          isObject: isObject_1,
          toArray: toArray_1,
          repeat: repeat_1,
          isNegativeZero: isNegativeZero_1,
          extend: extend_1
        };
        function YAMLException$1(reason, mark) {
          Error.call(this);
          this.name = 'YAMLException';
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error().stack || '';
          }
        }
        YAMLException$1.prototype = Object.create(Error.prototype);
        YAMLException$1.prototype.constructor = YAMLException$1;
        YAMLException$1.prototype.toString = function toString(compact) {
          var result = this.name + ': ';
          result += this.reason || '(unknown reason)';
          if (!compact && this.mark) {
            result += ' ' + this.mark.toString();
          }
          return result;
        };
        var exception = YAMLException$1;
        function Mark(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }
        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;
          if (!this.buffer) return null;
          indent = indent || 4;
          maxLength = maxLength || 75;
          head = '';
          start = this.position;
          while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = ' ... ';
              start += 5;
              break;
            }
          }
          tail = '';
          end = this.position;
          while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = ' ... ';
              end -= 5;
              break;
            }
          }
          snippet = this.buffer.slice(start, end);
          return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
        };
        Mark.prototype.toString = function toString(compact) {
          var snippet,
              where = '';
          if (this.name) {
            where += 'in "' + this.name + '" ';
          }
          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
          if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
              where += ':\n' + snippet;
            }
          }
          return where;
        };
        var mark = Mark;
        var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
        var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
        function compileStyleAliases(map) {
          var result = {};
          if (map !== null) {
            Object.keys(map).forEach(function (style) {
              map[style].forEach(function (alias) {
                result[String(alias)] = style;
              });
            });
          }
          return result;
        }
        function Type$1(tag, options) {
          options = options || {};
          Object.keys(options).forEach(function (name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });
          this.tag = tag;
          this.kind = options['kind'] || null;
          this.resolve = options['resolve'] || function () {
            return true;
          };
          this.construct = options['construct'] || function (data) {
            return data;
          };
          this.instanceOf = options['instanceOf'] || null;
          this.predicate = options['predicate'] || null;
          this.represent = options['represent'] || null;
          this.defaultStyle = options['defaultStyle'] || null;
          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }
        var type = Type$1;
        function compileList(schema, name, result) {
          var exclude = [];
          schema.include.forEach(function (includedSchema) {
            result = compileList(includedSchema, name, result);
          });
          schema[name].forEach(function (currentType) {
            result.forEach(function (previousType, previousIndex) {
              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
              }
            });
            result.push(currentType);
          });
          return result.filter(function (type, index) {
            return exclude.indexOf(index) === -1;
          });
        }
        function compileMap()
        {
          var result = {
            scalar: {},
            sequence: {},
            mapping: {},
            fallback: {}
          },
              index,
              length;
          function collectType(type) {
            result[type.kind][type.tag] = result['fallback'][type.tag] = type;
          }
          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }
        function Schema$1(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];
          this.implicit.forEach(function (type) {
            if (type.loadKind && type.loadKind !== 'scalar') {
              throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
            }
          });
          this.compiledImplicit = compileList(this, 'implicit', []);
          this.compiledExplicit = compileList(this, 'explicit', []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }
        Schema$1.DEFAULT = null;
        Schema$1.create = function createSchema() {
          var schemas, types;
          switch (arguments.length) {
            case 1:
              schemas = Schema$1.DEFAULT;
              types = arguments[0];
              break;
            case 2:
              schemas = arguments[0];
              types = arguments[1];
              break;
            default:
              throw new exception('Wrong number of arguments for Schema.create function');
          }
          schemas = common.toArray(schemas);
          types = common.toArray(types);
          if (!schemas.every(function (schema) {
            return schema instanceof Schema$1;
          })) {
            throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
          }
          if (!types.every(function (type$1) {
            return type$1 instanceof type;
          })) {
            throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
          }
          return new Schema$1({
            include: schemas,
            explicit: types
          });
        };
        var schema = Schema$1;
        var str = new type('tag:yaml.org,2002:str', {
          kind: 'scalar',
          construct: function construct(data) {
            return data !== null ? data : '';
          }
        });
        var seq = new type('tag:yaml.org,2002:seq', {
          kind: 'sequence',
          construct: function construct(data) {
            return data !== null ? data : [];
          }
        });
        var map = new type('tag:yaml.org,2002:map', {
          kind: 'mapping',
          construct: function construct(data) {
            return data !== null ? data : {};
          }
        });
        var failsafe = new schema({
          explicit: [str, seq, map]
        });
        function resolveYamlNull(data) {
          if (data === null) return true;
          var max = data.length;
          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
        }
        function constructYamlNull() {
          return null;
        }
        function isNull(object) {
          return object === null;
        }
        var _null = new type('tag:yaml.org,2002:null', {
          kind: 'scalar',
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function canonical() {
              return '~';
            },
            lowercase: function lowercase() {
              return 'null';
            },
            uppercase: function uppercase() {
              return 'NULL';
            },
            camelcase: function camelcase() {
              return 'Null';
            }
          },
          defaultStyle: 'lowercase'
        });
        function resolveYamlBoolean(data) {
          if (data === null) return false;
          var max = data.length;
          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
        }
        function constructYamlBoolean(data) {
          return data === 'true' || data === 'True' || data === 'TRUE';
        }
        function isBoolean(object) {
          return Object.prototype.toString.call(object) === '[object Boolean]';
        }
        var bool = new type('tag:yaml.org,2002:bool', {
          kind: 'scalar',
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function lowercase(object) {
              return object ? 'true' : 'false';
            },
            uppercase: function uppercase(object) {
              return object ? 'TRUE' : 'FALSE';
            },
            camelcase: function camelcase(object) {
              return object ? 'True' : 'False';
            }
          },
          defaultStyle: 'lowercase'
        });
        function isHexCode(c) {
          return 0x30
          <= c && c <= 0x39
          || 0x41
          <= c && c <= 0x46
          || 0x61
          <= c && c <= 0x66
          ;
        }
        function isOctCode(c) {
          return 0x30
          <= c && c <= 0x37
          ;
        }
        function isDecCode(c) {
          return 0x30
          <= c && c <= 0x39
          ;
        }
        function resolveYamlInteger(data) {
          if (data === null) return false;
          var max = data.length,
              index = 0,
              hasDigits = false,
              ch;
          if (!max) return false;
          ch = data[index];
          if (ch === '-' || ch === '+') {
            ch = data[++index];
          }
          if (ch === '0') {
            if (index + 1 === max) return true;
            ch = data[++index];
            if (ch === 'b') {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') continue;
                if (ch !== '0' && ch !== '1') return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            if (ch === 'x') {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            for (; index < max; index++) {
              ch = data[index];
              if (ch === '_') continue;
              if (!isOctCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== '_';
          }
          if (ch === '_') return false;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (ch === ':') break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }
          if (!hasDigits || ch === '_') return false;
          if (ch !== ':') return true;
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }
        function constructYamlInteger(data) {
          var value = data,
              sign = 1,
              ch,
              base,
              digits = [];
          if (value.indexOf('_') !== -1) {
            value = value.replace(/_/g, '');
          }
          ch = value[0];
          if (ch === '-' || ch === '+') {
            if (ch === '-') sign = -1;
            value = value.slice(1);
            ch = value[0];
          }
          if (value === '0') return 0;
          if (ch === '0') {
            if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
            if (value[1] === 'x') return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }
          if (value.indexOf(':') !== -1) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseInt(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseInt(value, 10);
        }
        function isInteger(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
        }
        var int = new type('tag:yaml.org,2002:int', {
          kind: 'scalar',
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger,
          represent: {
            binary: function binary(obj) {
              return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
            },
            octal: function octal(obj) {
              return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
            },
            decimal: function decimal(obj) {
              return obj.toString(10);
            },
            hexadecimal: function hexadecimal(obj) {
              return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
            }
          },
          defaultStyle: 'decimal',
          styleAliases: {
            binary: [2, 'bin'],
            octal: [8, 'oct'],
            decimal: [10, 'dec'],
            hexadecimal: [16, 'hex']
          }
        });
        var YAML_FLOAT_PATTERN = new RegExp(
        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
        '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
        '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
        '|[-+]?\\.(?:inf|Inf|INF)' +
        '|\\.(?:nan|NaN|NAN))$');
        function resolveYamlFloat(data) {
          if (data === null) return false;
          if (!YAML_FLOAT_PATTERN.test(data) ||
          data[data.length - 1] === '_') {
            return false;
          }
          return true;
        }
        function constructYamlFloat(data) {
          var value, sign, base, digits;
          value = data.replace(/_/g, '').toLowerCase();
          sign = value[0] === '-' ? -1 : 1;
          digits = [];
          if ('+-'.indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }
          if (value === '.inf') {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === '.nan') {
            return NaN;
          } else if (value.indexOf(':') >= 0) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseFloat(v, 10));
            });
            value = 0.0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
          var res;
          if (isNaN(object)) {
            switch (style) {
              case 'lowercase':
                return '.nan';
              case 'uppercase':
                return '.NAN';
              case 'camelcase':
                return '.NaN';
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
              case 'lowercase':
                return '.inf';
              case 'uppercase':
                return '.INF';
              case 'camelcase':
                return '.Inf';
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
              case 'lowercase':
                return '-.inf';
              case 'uppercase':
                return '-.INF';
              case 'camelcase':
                return '-.Inf';
            }
          } else if (common.isNegativeZero(object)) {
            return '-0.0';
          }
          res = object.toString(10);
          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
        }
        function isFloat(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
        }
        var float = new type('tag:yaml.org,2002:float', {
          kind: 'scalar',
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat,
          represent: representYamlFloat,
          defaultStyle: 'lowercase'
        });
        var json = new schema({
          include: [failsafe],
          implicit: [_null, bool, int, float]
        });
        var core = new schema({
          include: [json]
        });
        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
        '-([0-9][0-9])' +
        '-([0-9][0-9])$');
        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
        '-([0-9][0-9]?)' +
        '-([0-9][0-9]?)' +
        '(?:[Tt]|[ \\t]+)' +
        '([0-9][0-9]?)' +
        ':([0-9][0-9])' +
        ':([0-9][0-9])' +
        '(?:\\.([0-9]*))?' +
        '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
        '(?::([0-9][0-9]))?))?$');
        function resolveYamlTimestamp(data) {
          if (data === null) return false;
          if (YAML_DATE_REGEXP.exec(data) !== null) return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
          return false;
        }
        function constructYamlTimestamp(data) {
          var match,
              year,
              month,
              day,
              hour,
              minute,
              second,
              fraction = 0,
              delta = null,
              tz_hour,
              tz_minute,
              date;
          match = YAML_DATE_REGEXP.exec(data);
          if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
          if (match === null) throw new Error('Date resolve error');
          year = +match[1];
          month = +match[2] - 1;
          day = +match[3];
          if (!match[4]) {
            return new Date(Date.UTC(year, month, day));
          }
          hour = +match[4];
          minute = +match[5];
          second = +match[6];
          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              fraction += '0';
            }
            fraction = +fraction;
          }
          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 60000;
            if (match[9] === '-') delta = -delta;
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (delta) date.setTime(date.getTime() - delta);
          return date;
        }
        function representYamlTimestamp(object
        ) {
          return object.toISOString();
        }
        var timestamp = new type('tag:yaml.org,2002:timestamp', {
          kind: 'scalar',
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp
        });
        function resolveYamlMerge(data) {
          return data === '<<' || data === null;
        }
        var merge = new type('tag:yaml.org,2002:merge', {
          kind: 'scalar',
          resolve: resolveYamlMerge
        });
        function commonjsRequire (target) {
        	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
        }
        var NodeBuffer;
        try {
          var _require$1 = commonjsRequire;
          NodeBuffer = _require$1('buffer').Buffer;
        } catch (__) {}
        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
        function resolveYamlBinary(data) {
          if (data === null) return false;
          var code,
              idx,
              bitlen = 0,
              max = data.length,
              map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));
            if (code > 64) continue;
            if (code < 0) return false;
            bitlen += 6;
          }
          return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
          var idx,
              tailbits,
              input = data.replace(/[\r\n=]/g, ''),
          max = input.length,
              map = BASE64_MAP,
              bits = 0,
              result = [];
          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push(bits >> 16 & 0xFF);
              result.push(bits >> 8 & 0xFF);
              result.push(bits & 0xFF);
            }
            bits = bits << 6 | map.indexOf(input.charAt(idx));
          }
          tailbits = max % 4 * 6;
          if (tailbits === 0) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
          } else if (tailbits === 18) {
            result.push(bits >> 10 & 0xFF);
            result.push(bits >> 2 & 0xFF);
          } else if (tailbits === 12) {
            result.push(bits >> 4 & 0xFF);
          }
          if (NodeBuffer) {
            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
          }
          return result;
        }
        function representYamlBinary(object
        ) {
          var result = '',
              bits = 0,
              idx,
              tail,
              max = object.length,
              map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[bits >> 18 & 0x3F];
              result += map[bits >> 12 & 0x3F];
              result += map[bits >> 6 & 0x3F];
              result += map[bits & 0x3F];
            }
            bits = (bits << 8) + object[idx];
          }
          tail = max % 3;
          if (tail === 0) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
          } else if (tail === 2) {
            result += map[bits >> 10 & 0x3F];
            result += map[bits >> 4 & 0x3F];
            result += map[bits << 2 & 0x3F];
            result += map[64];
          } else if (tail === 1) {
            result += map[bits >> 2 & 0x3F];
            result += map[bits << 4 & 0x3F];
            result += map[64];
            result += map[64];
          }
          return result;
        }
        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }
        var binary = new type('tag:yaml.org,2002:binary', {
          kind: 'scalar',
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary
        });
        var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
        var _toString$2 = Object.prototype.toString;
        function resolveYamlOmap(data) {
          if (data === null) return true;
          var objectKeys = [],
              index,
              length,
              pair,
              pairKey,
              pairHasKey,
              object = data;
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;
            if (_toString$2.call(pair) !== '[object Object]') return false;
            for (pairKey in pair) {
              if (_hasOwnProperty$3.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;else return false;
              }
            }
            if (!pairHasKey) return false;
            if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
          }
          return true;
        }
        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }
        var omap = new type('tag:yaml.org,2002:omap', {
          kind: 'sequence',
          resolve: resolveYamlOmap,
          construct: constructYamlOmap
        });
        var _toString$1 = Object.prototype.toString;
        function resolveYamlPairs(data) {
          if (data === null) return true;
          var index,
              length,
              pair,
              keys,
              result,
              object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            if (_toString$1.call(pair) !== '[object Object]') return false;
            keys = Object.keys(pair);
            if (keys.length !== 1) return false;
            result[index] = [keys[0], pair[keys[0]]];
          }
          return true;
        }
        function constructYamlPairs(data) {
          if (data === null) return [];
          var index,
              length,
              pair,
              keys,
              result,
              object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            keys = Object.keys(pair);
            result[index] = [keys[0], pair[keys[0]]];
          }
          return result;
        }
        var pairs = new type('tag:yaml.org,2002:pairs', {
          kind: 'sequence',
          resolve: resolveYamlPairs,
          construct: constructYamlPairs
        });
        var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
          if (data === null) return true;
          var key,
              object = data;
          for (key in object) {
            if (_hasOwnProperty$2.call(object, key)) {
              if (object[key] !== null) return false;
            }
          }
          return true;
        }
        function constructYamlSet(data) {
          return data !== null ? data : {};
        }
        var set = new type('tag:yaml.org,2002:set', {
          kind: 'mapping',
          resolve: resolveYamlSet,
          construct: constructYamlSet
        });
        var default_safe = new schema({
          include: [core],
          implicit: [timestamp, merge],
          explicit: [binary, omap, pairs, set]
        });
        function resolveJavascriptUndefined() {
          return true;
        }
        function constructJavascriptUndefined() {
          return undefined;
        }
        function representJavascriptUndefined() {
          return '';
        }
        function isUndefined(object) {
          return typeof object === 'undefined';
        }
        var _undefined = new type('tag:yaml.org,2002:js/undefined', {
          kind: 'scalar',
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined
        });
        function resolveJavascriptRegExp(data) {
          if (data === null) return false;
          if (data.length === 0) return false;
          var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = '';
          if (regexp[0] === '/') {
            if (tail) modifiers = tail[1];
            if (modifiers.length > 3) return false;
            if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
          }
          return true;
        }
        function constructJavascriptRegExp(data) {
          var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = '';
          if (regexp[0] === '/') {
            if (tail) modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }
          return new RegExp(regexp, modifiers);
        }
        function representJavascriptRegExp(object
        ) {
          var result = '/' + object.source + '/';
          if (object.global) result += 'g';
          if (object.multiline) result += 'm';
          if (object.ignoreCase) result += 'i';
          return result;
        }
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === '[object RegExp]';
        }
        var regexp = new type('tag:yaml.org,2002:js/regexp', {
          kind: 'scalar',
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp
        });
        var esprima;
        try {
          var _require = commonjsRequire;
          esprima = _require('esprima');
        } catch (_) {
          if (typeof window !== 'undefined') esprima = window.esprima;
        }
        function resolveJavascriptFunction(data) {
          if (data === null) return false;
          try {
            var source = '(' + data + ')',
                ast = esprima.parse(source, {
              range: true
            });
            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        function constructJavascriptFunction(data) {
          var source = '(' + data + ')',
              ast = esprima.parse(source, {
            range: true
          }),
              params = [],
              body;
          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
            throw new Error('Failed to resolve function');
          }
          ast.body[0].expression.params.forEach(function (param) {
            params.push(param.name);
          });
          body = ast.body[0].expression.body.range;
          if (ast.body[0].expression.body.type === 'BlockStatement') {
            return new Function(params, source.slice(body[0] + 1, body[1] - 1));
          }
          return new Function(params, 'return ' + source.slice(body[0], body[1]));
        }
        function representJavascriptFunction(object
        ) {
          return object.toString();
        }
        function isFunction(object) {
          return Object.prototype.toString.call(object) === '[object Function]';
        }
        var _function = new type('tag:yaml.org,2002:js/function', {
          kind: 'scalar',
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction
        });
        var default_full = schema.DEFAULT = new schema({
          include: [default_safe],
          explicit: [_undefined, regexp, _function]
        });
        var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function _class(obj) {
          return Object.prototype.toString.call(obj);
        }
        function is_EOL(c) {
          return c === 0x0A
          || c === 0x0D
          ;
        }
        function is_WHITE_SPACE(c) {
          return c === 0x09
          || c === 0x20
          ;
        }
        function is_WS_OR_EOL(c) {
          return c === 0x09
          || c === 0x20
          || c === 0x0A
          || c === 0x0D
          ;
        }
        function is_FLOW_INDICATOR(c) {
          return c === 0x2C
          || c === 0x5B
          || c === 0x5D
          || c === 0x7B
          || c === 0x7D
          ;
        }
        function fromHexCode(c) {
          var lc;
          if (0x30
          <= c && c <= 0x39
          ) {
            return c - 0x30;
          }
          lc = c | 0x20;
          if (0x61
          <= lc && lc <= 0x66
          ) {
            return lc - 0x61 + 10;
          }
          return -1;
        }
        function escapedHexLen(c) {
          if (c === 0x78
          ) {
              return 2;
            }
          if (c === 0x75
          ) {
              return 4;
            }
          if (c === 0x55
          ) {
              return 8;
            }
          return 0;
        }
        function fromDecimalCode(c) {
          if (0x30
          <= c && c <= 0x39
          ) {
            return c - 0x30;
          }
          return -1;
        }
        function simpleEscapeSequence(c) {
          return c === 0x30
          ? '\x00' : c === 0x61
          ? '\x07' : c === 0x62
          ? '\x08' : c === 0x74
          ? '\x09' : c === 0x09
          ? '\x09' : c === 0x6E
          ? '\x0A' : c === 0x76
          ? '\x0B' : c === 0x66
          ? '\x0C' : c === 0x72
          ? '\x0D' : c === 0x65
          ? '\x1B' : c === 0x20
          ? ' ' : c === 0x22
          ? '\x22' : c === 0x2F
          ? '/' : c === 0x5C
          ? '\x5C' : c === 0x4E
          ? '\x85' : c === 0x5F
          ? '\xA0' : c === 0x4C
          ? "\u2028" : c === 0x50
          ? "\u2029" : '';
        }
        function charFromCodepoint(c) {
          if (c <= 0xFFFF) {
            return String.fromCharCode(c);
          }
          return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
        }
        var simpleEscapeCheck = new Array(256);
        var simpleEscapeMap = new Array(256);
        for (var i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        function State$1(input, options) {
          this.input = input;
          this.filename = options['filename'] || null;
          this.schema = options['schema'] || default_full;
          this.onWarning = options['onWarning'] || null;
          this.legacy = options['legacy'] || false;
          this.json = options['json'] || false;
          this.listener = options['listener'] || null;
          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;
          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;
          this.documents = [];
        }
        function generateError(state, message) {
          return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
        }
        function throwError(state, message) {
          throw generateError(state, message);
        }
        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }
        var directiveHandlers = {
          YAML: function handleYamlDirective(state, name, args) {
            var match, major, minor;
            if (state.version !== null) {
              throwError(state, 'duplication of %YAML directive');
            }
            if (args.length !== 1) {
              throwError(state, 'YAML directive accepts exactly one argument');
            }
            match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
            if (match === null) {
              throwError(state, 'ill-formed argument of the YAML directive');
            }
            major = parseInt(match[1], 10);
            minor = parseInt(match[2], 10);
            if (major !== 1) {
              throwError(state, 'unacceptable YAML version of the document');
            }
            state.version = args[0];
            state.checkLineBreaks = minor < 2;
            if (minor !== 1 && minor !== 2) {
              throwWarning(state, 'unsupported YAML version of the document');
            }
          },
          TAG: function handleTagDirective(state, name, args) {
            var handle, prefix;
            if (args.length !== 2) {
              throwError(state, 'TAG directive accepts exactly two arguments');
            }
            handle = args[0];
            prefix = args[1];
            if (!PATTERN_TAG_HANDLE.test(handle)) {
              throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
            }
            if (_hasOwnProperty$1.call(state.tagMap, handle)) {
              throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
            }
            if (!PATTERN_TAG_URI.test(prefix)) {
              throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
            }
            state.tagMap[handle] = prefix;
          }
        };
        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;
          if (start < end) {
            _result = state.input.slice(start, end);
            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
                  throwError(state, 'expected valid JSON character');
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, 'the stream contains non-printable characters');
            }
            state.result += _result;
          }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;
          if (!common.isObject(source)) {
            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
          }
          sourceKeys = Object.keys(source);
          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];
            if (!_hasOwnProperty$1.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
          var index, quantity;
          if (Array.isArray(keyNode)) {
            keyNode = Array.prototype.slice.call(keyNode);
            for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
              if (Array.isArray(keyNode[index])) {
                throwError(state, 'nested arrays are not supported inside keys');
              }
              if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
                keyNode[index] = '[object Object]';
              }
            }
          }
          if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
            keyNode = '[object Object]';
          }
          keyNode = String(keyNode);
          if (_result === null) {
            _result = {};
          }
          if (keyTag === 'tag:yaml.org,2002:merge') {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
              state.line = startLine || state.line;
              state.position = startPos || state.position;
              throwError(state, 'duplicated mapping key');
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }
          return _result;
        }
        function readLineBreak(state) {
          var ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x0A
          ) {
              state.position++;
            } else if (ch === 0x0D
          ) {
              state.position++;
              if (state.input.charCodeAt(state.position) === 0x0A
              ) {
                  state.position++;
                }
            } else {
            throwError(state, 'a line break is expected');
          }
          state.line += 1;
          state.lineStart = state.position;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0,
              ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (allowComments && ch === 0x23
            ) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0x0A
                && ch !== 0x0D
                && ch !== 0);
              }
            if (is_EOL(ch)) {
              readLineBreak(state);
              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;
              while (ch === 0x20
              ) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }
          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, 'deficient indentation');
          }
          return lineBreaks;
        }
        function testDocumentSeparator(state) {
          var _position = state.position,
              ch;
          ch = state.input.charCodeAt(_position);
          if ((ch === 0x2D
          || ch === 0x2E
          ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
            _position += 3;
            ch = state.input.charCodeAt(_position);
            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }
          return false;
        }
        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += ' ';
          } else if (count > 1) {
            state.result += common.repeat('\n', count - 1);
          }
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding,
              following,
              captureStart,
              captureEnd,
              hasPendingContent,
              _line,
              _lineStart,
              _lineIndent,
              _kind = state.kind,
              _result = state.result,
              ch;
          ch = state.input.charCodeAt(state.position);
          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23
          || ch === 0x26
          || ch === 0x2A
          || ch === 0x21
          || ch === 0x7C
          || ch === 0x3E
          || ch === 0x27
          || ch === 0x22
          || ch === 0x25
          || ch === 0x40
          || ch === 0x60
          ) {
              return false;
            }
          if (ch === 0x3F
          || ch === 0x2D
          ) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                return false;
              }
            }
          state.kind = 'scalar';
          state.result = '';
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
          while (ch !== 0) {
            if (ch === 0x3A
            ) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                  break;
                }
              } else if (ch === 0x23
            ) {
                preceding = state.input.charCodeAt(state.position - 1);
                if (is_WS_OR_EOL(preceding)) {
                  break;
                }
              } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);
              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }
            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }
            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, captureEnd, false);
          if (state.result) {
            return true;
          }
          state.kind = _kind;
          state.result = _result;
          return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x27
          ) {
              return false;
            }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x27
            ) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (ch === 0x27
                ) {
                    captureStart = state.position;
                    state.position++;
                    captureEnd = state.position;
                  } else {
                  return true;
                }
              } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a single quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a single quoted scalar');
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x22
          ) {
              return false;
            }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x22
            ) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                return true;
              } else if (ch === 0x5C
            ) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) {
                  skipSeparationSpace(state, false, nodeIndent);
                } else if (ch < 256 && simpleEscapeCheck[ch]) {
                  state.result += simpleEscapeMap[ch];
                  state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                  hexLength = tmp;
                  hexResult = 0;
                  for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                      hexResult = (hexResult << 4) + tmp;
                    } else {
                      throwError(state, 'expected hexadecimal character');
                    }
                  }
                  state.result += charFromCodepoint(hexResult);
                  state.position++;
                } else {
                  throwError(state, 'unknown escape sequence');
                }
                captureStart = captureEnd = state.position;
              } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a double quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a double quoted scalar');
        }
        function readFlowCollection(state, nodeIndent) {
          var readNext = true,
              _line,
              _tag = state.tag,
              _result,
              _anchor = state.anchor,
              following,
              terminator,
              isPair,
              isExplicitPair,
              isMapping,
              overridableKeys = {},
              keyNode,
              keyTag,
              valueNode,
              ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x5B
          ) {
              terminator = 0x5D;
              isMapping = false;
              _result = [];
            } else if (ch === 0x7B
          ) {
              terminator = 0x7D;
              isMapping = true;
              _result = {};
            } else {
            return false;
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(++state.position);
          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? 'mapping' : 'sequence';
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, 'missed comma between flow collection entries');
            }
            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;
            if (ch === 0x3F
            ) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following)) {
                  isPair = isExplicitPair = true;
                  state.position++;
                  skipSeparationSpace(state, true, nodeIndent);
                }
              }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if ((isExplicitPair || state.line === _line) && ch === 0x3A
            ) {
                isPair = true;
                ch = state.input.charCodeAt(++state.position);
                skipSeparationSpace(state, true, nodeIndent);
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                valueNode = state.result;
              }
            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x2C
            ) {
                readNext = true;
                ch = state.input.charCodeAt(++state.position);
              } else {
              readNext = false;
            }
          }
          throwError(state, 'unexpected end of the stream within a flow collection');
        }
        function readBlockScalar(state, nodeIndent) {
          var captureStart,
              folding,
              chomping = CHOMPING_CLIP,
              didReadContent = false,
              detectedIndent = false,
              textIndent = nodeIndent,
              emptyLines = 0,
              atMoreIndented = false,
              tmp,
              ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x7C
          ) {
              folding = false;
            } else if (ch === 0x3E
          ) {
              folding = true;
            } else {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x2B
            || ch === 0x2D
            ) {
                if (CHOMPING_CLIP === chomping) {
                  chomping = ch === 0x2B
                  ? CHOMPING_KEEP : CHOMPING_STRIP;
                } else {
                  throwError(state, 'repeat of a chomping mode identifier');
                }
              } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, 'repeat of an indentation width identifier');
              }
            } else {
              break;
            }
          }
          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));
            if (ch === 0x23
            ) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (!is_EOL(ch) && ch !== 0);
              }
          }
          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;
            ch = state.input.charCodeAt(state.position);
            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20
            ) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }
            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }
            if (state.lineIndent < textIndent) {
              if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  state.result += '\n';
                }
              }
              break;
            }
            if (folding) {
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat('\n', emptyLines + 1);
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  state.result += ' ';
                }
              } else {
                state.result += common.repeat('\n', emptyLines);
              }
            } else {
              state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            }
            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;
            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, state.position, false);
          }
          return true;
        }
        function readBlockSequence(state, nodeIndent) {
          var _line,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = [],
              following,
              detected = false,
              ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            if (ch !== 0x2D
            ) {
                break;
              }
            following = state.input.charCodeAt(state.position + 1);
            if (!is_WS_OR_EOL(following)) {
              break;
            }
            detected = true;
            state.position++;
            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, 'bad indentation of a sequence entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'sequence';
            state.result = _result;
            return true;
          }
          return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following,
              allowCompact,
              _line,
              _pos,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = {},
              overridableKeys = {},
              keyTag = null,
              keyNode = null,
              valueNode = null,
              atExplicitKey = false,
              detected = false,
              ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line;
            _pos = state.position;
            if ((ch === 0x3F
            || ch === 0x3A
            ) && is_WS_OR_EOL(following)) {
              if (ch === 0x3F
              ) {
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = true;
                  allowCompact = true;
                } else if (atExplicitKey) {
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
              }
              state.position += 1;
              ch = following;
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x3A
                ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                      throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                    }
                    if (atExplicitKey) {
                      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                  } else if (detected) {
                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;
                }
              } else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;
              }
            } else {
                break;
              }
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }
              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }
            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, 'bad indentation of a mapping entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'mapping';
            state.result = _result;
          }
          return detected;
        }
        function readTagProperty(state) {
          var _position,
              isVerbatim = false,
              isNamed = false,
              tagHandle,
              tagName,
              ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x21
          ) return false;
          if (state.tag !== null) {
            throwError(state, 'duplication of a tag property');
          }
          ch = state.input.charCodeAt(++state.position);
          if (ch === 0x3C
          ) {
              isVerbatim = true;
              ch = state.input.charCodeAt(++state.position);
            } else if (ch === 0x21
          ) {
              isNamed = true;
              tagHandle = '!!';
              ch = state.input.charCodeAt(++state.position);
            } else {
            tagHandle = '!';
          }
          _position = state.position;
          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 0x3E
            );
            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, 'unexpected end of the stream within a verbatim tag');
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 0x21
              ) {
                  if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                      throwError(state, 'named tag handle cannot contain such characters');
                    }
                    isNamed = true;
                    _position = state.position + 1;
                  } else {
                    throwError(state, 'tag suffix cannot contain exclamation marks');
                  }
                }
              ch = state.input.charCodeAt(++state.position);
            }
            tagName = state.input.slice(_position, state.position);
            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, 'tag suffix cannot contain flow indicator characters');
            }
          }
          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, 'tag name cannot contain such characters: ' + tagName);
          }
          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === '!') {
            state.tag = '!' + tagName;
          } else if (tagHandle === '!!') {
            state.tag = 'tag:yaml.org,2002:' + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }
          return true;
        }
        function readAnchorProperty(state) {
          var _position, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x26
          ) return false;
          if (state.anchor !== null) {
            throwError(state, 'duplication of an anchor property');
          }
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an anchor node must contain at least one character');
          }
          state.anchor = state.input.slice(_position, state.position);
          return true;
        }
        function readAlias(state) {
          var _position, alias, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x2A
          ) return false;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an alias node must contain at least one character');
          }
          alias = state.input.slice(_position, state.position);
          if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }
          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles,
              allowBlockScalars,
              allowBlockCollections,
              indentStatus = 1,
          atNewLine = false,
              hasContent = false,
              typeIndex,
              typeQuantity,
              type,
              flowIndent,
              blockIndent;
          if (state.listener !== null) {
            state.listener('open', state);
          }
          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;
          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }
          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }
          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }
          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }
            blockIndent = state.position - state.lineStart;
            if (indentStatus === 1) {
              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
              } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;
                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, 'alias node should not have any properties');
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;
                  if (state.tag === null) {
                    state.tag = '?';
                  }
                }
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }
          if (state.tag !== null && state.tag !== '!') {
            if (state.tag === '?') {
              if (state.result !== null && state.kind !== 'scalar') {
                throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
              }
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
              type = state.typeMap[state.kind || 'fallback'][state.tag];
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result)) {
                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, 'unknown tag !<' + state.tag + '>');
            }
          }
          if (state.listener !== null) {
            state.listener('close', state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }
        function readDocument(state) {
          var documentStart = state.position,
              _position,
              directiveName,
              directiveArgs,
              hasDirectives = false,
              ch;
          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if (state.lineIndent > 0 || ch !== 0x25
            ) {
                break;
              }
            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];
            if (directiveName.length < 1) {
              throwError(state, 'directive name must not be less than one character in length');
            }
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 0x23
              ) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 0 && !is_EOL(ch));
                  break;
                }
              if (is_EOL(ch)) break;
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveArgs.push(state.input.slice(_position, state.position));
            }
            if (ch !== 0) readLineBreak(state);
            if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }
          skipSeparationSpace(state, true, -1);
          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D
          && state.input.charCodeAt(state.position + 1) === 0x2D
          && state.input.charCodeAt(state.position + 2) === 0x2D
          ) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) {
            throwError(state, 'directives end mark is expected');
          }
          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);
          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
            throwWarning(state, 'non-ASCII line breaks are interpreted as content');
          }
          state.documents.push(state.result);
          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 0x2E
            ) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              }
            return;
          }
          if (state.position < state.length - 1) {
            throwError(state, 'end of the stream or a document separator is expected');
          } else {
            return;
          }
        }
        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};
          if (input.length !== 0) {
            if (input.charCodeAt(input.length - 1) !== 0x0A
            && input.charCodeAt(input.length - 1) !== 0x0D
            ) {
                input += '\n';
              }
            if (input.charCodeAt(0) === 0xFEFF) {
              input = input.slice(1);
            }
          }
          var state = new State$1(input, options);
          var nullpos = input.indexOf('\0');
          if (nullpos !== -1) {
            state.position = nullpos;
            throwError(state, 'null byte is not allowed in input');
          }
          state.input += '\0';
          while (state.input.charCodeAt(state.position) === 0x20
          ) {
            state.lineIndent += 1;
            state.position += 1;
          }
          while (state.position < state.length - 1) {
            readDocument(state);
          }
          return state.documents;
        }
        function loadAll$1(input, iterator, options) {
          if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
            options = iterator;
            iterator = null;
          }
          var documents = loadDocuments(input, options);
          if (typeof iterator !== 'function') {
            return documents;
          }
          for (var index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }
        function load$1(input, options) {
          var documents = loadDocuments(input, options);
          if (documents.length === 0) {
            return undefined;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new exception('expected a single document in the stream, but found more');
        }
        function safeLoadAll$1(input, iterator, options) {
          if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
            options = iterator;
            iterator = null;
          }
          return loadAll$1(input, iterator, common.extend({
            schema: default_safe
          }, options));
        }
        function safeLoad$1(input, options) {
          return load$1(input, common.extend({
            schema: default_safe
          }, options));
        }
        var loadAll_1 = loadAll$1;
        var load_1 = load$1;
        var safeLoadAll_1 = safeLoadAll$1;
        var safeLoad_1 = safeLoad$1;
        var loader = {
          loadAll: loadAll_1,
          load: load_1,
          safeLoadAll: safeLoadAll_1,
          safeLoad: safeLoad_1
        };
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_TAB = 0x09;
        var CHAR_LINE_FEED = 0x0A;
        var CHAR_CARRIAGE_RETURN = 0x0D;
        var CHAR_SPACE = 0x20;
        var CHAR_EXCLAMATION = 0x21;
        var CHAR_DOUBLE_QUOTE = 0x22;
        var CHAR_SHARP = 0x23;
        var CHAR_PERCENT = 0x25;
        var CHAR_AMPERSAND = 0x26;
        var CHAR_SINGLE_QUOTE = 0x27;
        var CHAR_ASTERISK = 0x2A;
        var CHAR_COMMA = 0x2C;
        var CHAR_MINUS = 0x2D;
        var CHAR_COLON = 0x3A;
        var CHAR_EQUALS = 0x3D;
        var CHAR_GREATER_THAN = 0x3E;
        var CHAR_QUESTION = 0x3F;
        var CHAR_COMMERCIAL_AT = 0x40;
        var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
        var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
        var CHAR_GRAVE_ACCENT = 0x60;
        var CHAR_LEFT_CURLY_BRACKET = 0x7B;
        var CHAR_VERTICAL_LINE = 0x7C;
        var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0x00] = '\\0';
        ESCAPE_SEQUENCES[0x07] = '\\a';
        ESCAPE_SEQUENCES[0x08] = '\\b';
        ESCAPE_SEQUENCES[0x09] = '\\t';
        ESCAPE_SEQUENCES[0x0A] = '\\n';
        ESCAPE_SEQUENCES[0x0B] = '\\v';
        ESCAPE_SEQUENCES[0x0C] = '\\f';
        ESCAPE_SEQUENCES[0x0D] = '\\r';
        ESCAPE_SEQUENCES[0x1B] = '\\e';
        ESCAPE_SEQUENCES[0x22] = '\\"';
        ESCAPE_SEQUENCES[0x5C] = '\\\\';
        ESCAPE_SEQUENCES[0x85] = '\\N';
        ESCAPE_SEQUENCES[0xA0] = '\\_';
        ESCAPE_SEQUENCES[0x2028] = '\\L';
        ESCAPE_SEQUENCES[0x2029] = '\\P';
        var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;
          if (map === null) return {};
          result = {};
          keys = Object.keys(map);
          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);
            if (tag.slice(0, 2) === '!!') {
              tag = 'tag:yaml.org,2002:' + tag.slice(2);
            }
            type = schema.compiledTypeMap['fallback'][tag];
            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }
            result[tag] = style;
          }
          return result;
        }
        function encodeHex(character) {
          var string, handle, length;
          string = character.toString(16).toUpperCase();
          if (character <= 0xFF) {
            handle = 'x';
            length = 2;
          } else if (character <= 0xFFFF) {
            handle = 'u';
            length = 4;
          } else if (character <= 0xFFFFFFFF) {
            handle = 'U';
            length = 8;
          } else {
            throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
          }
          return '\\' + handle + common.repeat('0', length - string.length) + string;
        }
        function State(options) {
          this.schema = options['schema'] || default_full;
          this.indent = Math.max(1, options['indent'] || 2);
          this.noArrayIndent = options['noArrayIndent'] || false;
          this.skipInvalid = options['skipInvalid'] || false;
          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
          this.sortKeys = options['sortKeys'] || false;
          this.lineWidth = options['lineWidth'] || 80;
          this.noRefs = options['noRefs'] || false;
          this.noCompatMode = options['noCompatMode'] || false;
          this.condenseFlow = options['condenseFlow'] || false;
          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;
          this.tag = null;
          this.result = '';
          this.duplicates = [];
          this.usedDuplicates = null;
        }
        function indentString(string, spaces) {
          var ind = common.repeat(' ', spaces),
              position = 0,
              next = -1,
              result = '',
              line,
              length = string.length;
          while (position < length) {
            next = string.indexOf('\n', position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }
            if (line.length && line !== '\n') result += ind;
            result += line;
          }
          return result;
        }
        function generateNextLine(state, level) {
          return '\n' + common.repeat(' ', state.indent * level);
        }
        function testImplicitResolving(state, str) {
          var index, length, type;
          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];
            if (type.resolve(str)) {
              return true;
            }
          }
          return false;
        }
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }
        function isPrintable(c) {
          return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF
          || 0x10000 <= c && c <= 0x10FFFF;
        }
        function isNsChar(c) {
          return isPrintable(c) && !isWhitespace(c)
          && c !== 0xFEFF
          && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
        }
        function isPlainSafe(c, prev) {
          return isPrintable(c) && c !== 0xFEFF
          && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
          && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
        }
        function isPlainSafeFirst(c) {
          return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c)
          && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
          && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
          && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        function needIndentIndicator(string) {
          var leadingSpaceRe = /^\n* /;
          return leadingSpaceRe.test(string);
        }
        var STYLE_PLAIN = 1,
            STYLE_SINGLE = 2,
            STYLE_LITERAL = 3,
            STYLE_FOLDED = 4,
            STYLE_DOUBLE = 5;
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char, prev_char;
          var hasLineBreak = false;
          var hasFoldableLine = false;
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1;
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
          if (singleLineOnly) {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
          } else {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                if (shouldTrackWidth) {
                  hasFoldableLine = hasFoldableLine ||
                  i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
            hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          }
          if (!hasLineBreak && !hasFoldableLine) {
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          if (indentPerLevel > 9 && needIndentIndicator(string)) {
            return STYLE_DOUBLE;
          }
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        function writeScalar(state, string, level, iskey) {
          state.dump = function () {
            if (string.length === 0) {
              return "''";
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return "'" + string + "'";
            }
            var indent = state.indent * Math.max(1, level);
            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
            var singleLineOnly = iskey
            || state.flowLevel > -1 && level >= state.flowLevel;
            function testAmbiguity(string) {
              return testImplicitResolving(state, string);
            }
            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
              case STYLE_PLAIN:
                return string;
              case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
              case STYLE_LITERAL:
                return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
              case STYLE_FOLDED:
                return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
              case STYLE_DOUBLE:
                return '"' + escapeString(string) + '"';
              default:
                throw new exception('impossible error: invalid scalar style');
            }
          }();
        }
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
          var clip = string[string.length - 1] === '\n';
          var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
          var chomp = keep ? '+' : clip ? '' : '-';
          return indentIndicator + chomp + '\n';
        }
        function dropEndingNewline(string) {
          return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
        }
        function foldString(string, width) {
          var lineRe = /(\n+)([^\n]*)/g;
          var result = function () {
            var nextLF = string.indexOf('\n');
            nextLF = nextLF !== -1 ? nextLF : string.length;
            lineRe.lastIndex = nextLF;
            return foldLine(string.slice(0, nextLF), width);
          }();
          var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
          var moreIndented;
          var match;
          while (match = lineRe.exec(string)) {
            var prefix = match[1],
                line = match[2];
            moreIndented = line[0] === ' ';
            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }
          return result;
        }
        function foldLine(line, width) {
          if (line === '' || line[0] === ' ') return line;
          var breakRe = / [^ ]/g;
          var match;
          var start = 0,
              end,
              curr = 0,
              next = 0;
          var result = '';
          while (match = breakRe.exec(line)) {
            next = match.index;
            if (next - start > width) {
              end = curr > start ? curr : next;
              result += '\n' + line.slice(start, end);
              start = end + 1;
            }
            curr = next;
          }
          result += '\n';
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }
          return result.slice(1);
        }
        function escapeString(string) {
          var result = '';
          var char, nextChar;
          var escapeSeq;
          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (char >= 0xD800 && char <= 0xDBFF
            ) {
                nextChar = string.charCodeAt(i + 1);
                if (nextChar >= 0xDC00 && nextChar <= 0xDFFF
                ) {
                    result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                    i++;
                    continue;
                  }
              }
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }
          return result;
        }
        function writeFlowSequence(state, level, object) {
          var _result = '',
              _tag = state.tag,
              index,
              length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = '[' + _result + ']';
        }
        function writeBlockSequence(state, level, object, compact) {
          var _result = '',
              _tag = state.tag,
              index,
              length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += '-';
              } else {
                _result += '- ';
              }
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = _result || '[]';
        }
        function writeFlowMapping(state, level, object) {
          var _result = '',
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              pairBuffer;
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (index !== 0) pairBuffer += ', ';
            if (state.condenseFlow) pairBuffer += '"';
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level, objectKey, false, false)) {
              continue;
            }
            if (state.dump.length > 1024) pairBuffer += '? ';
            pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
            if (!writeNode(state, level, objectValue, false, false)) {
              continue;
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = '{' + _result + '}';
        }
        function writeBlockMapping(state, level, object, compact) {
          var _result = '',
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              explicitPair,
              pairBuffer;
          if (state.sortKeys === true) {
            objectKeyList.sort();
          } else if (typeof state.sortKeys === 'function') {
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            throw new exception('sortKeys must be a boolean or a function');
          }
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue;
            }
            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
              } else {
                pairBuffer += '? ';
              }
            }
            pairBuffer += state.dump;
            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }
            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue;
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ':';
            } else {
              pairBuffer += ': ';
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = _result || '{}';
        }
        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;
          typeList = explicit ? state.explicitTypes : state.implicitTypes;
          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];
            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
              state.tag = explicit ? type.tag : '?';
              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === '[object Function]') {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
              }
              return true;
            }
          }
          return false;
        }
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;
          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }
          var type = _toString.call(state.dump);
          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }
          var objectOrArray = type === '[object Object]' || type === '[object Array]',
              duplicateIndex,
              duplicate;
          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }
          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
            compact = false;
          }
          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = '*ref_' + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === '[object Object]') {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object Array]') {
              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object String]') {
              if (state.tag !== '?') {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid) return false;
              throw new exception('unacceptable kind of an object to dump ' + type);
            }
            if (state.tag !== null && state.tag !== '?') {
              state.dump = '!<' + state.tag + '> ' + state.dump;
            }
          }
          return true;
        }
        function getDuplicateReferences(object, state) {
          var objects = [],
              duplicatesIndexes = [],
              index,
              length;
          inspectNode(object, objects, duplicatesIndexes);
          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;
          if (object !== null && typeof object === 'object') {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);
              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }
        function dump$1(input, options) {
          options = options || {};
          var state = new State(options);
          if (!state.noRefs) getDuplicateReferences(input, state);
          if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
          return '';
        }
        function safeDump$1(input, options) {
          return dump$1(input, common.extend({
            schema: default_safe
          }, options));
        }
        var dump_1 = dump$1;
        var safeDump_1 = safeDump$1;
        var dumper = {
          dump: dump_1,
          safeDump: safeDump_1
        };
        function deprecated(name) {
          return function () {
            throw new Error('Function ' + name + ' is deprecated and cannot be used.');
          };
        }
        var Type = type;
        var Schema = schema;
        var FAILSAFE_SCHEMA = failsafe;
        var JSON_SCHEMA = json;
        var CORE_SCHEMA = core;
        var DEFAULT_SAFE_SCHEMA = default_safe;
        var DEFAULT_FULL_SCHEMA = default_full;
        var load = loader.load;
        var loadAll = loader.loadAll;
        var safeLoad = loader.safeLoad;
        var safeLoadAll = loader.safeLoadAll;
        var dump = dumper.dump;
        var safeDump = dumper.safeDump;
        var YAMLException = exception;
        var MINIMAL_SCHEMA = failsafe;
        var SAFE_SCHEMA = default_safe;
        var DEFAULT_SCHEMA = default_full;
        var scan = deprecated('scan');
        var parse = deprecated('parse');
        var compose = deprecated('compose');
        var addConstructor = deprecated('addConstructor');
        var jsYaml$1 = {
          Type: Type,
          Schema: Schema,
          FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
          JSON_SCHEMA: JSON_SCHEMA,
          CORE_SCHEMA: CORE_SCHEMA,
          DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
          DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
          load: load,
          loadAll: loadAll,
          safeLoad: safeLoad,
          safeLoadAll: safeLoadAll,
          dump: dump,
          safeDump: safeDump,
          YAMLException: YAMLException,
          MINIMAL_SCHEMA: MINIMAL_SCHEMA,
          SAFE_SCHEMA: SAFE_SCHEMA,
          DEFAULT_SCHEMA: DEFAULT_SCHEMA,
          scan: scan,
          parse: parse,
          compose: compose,
          addConstructor: addConstructor
        };
        var jsYaml = jsYaml$1;
        function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
        function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
        var Redirects = function () {
          function Redirects(rawYaml) {
            classCallCheck(this, Redirects);
            try {
              var arrOfRedirects = jsYaml.safeLoad(rawYaml);
              this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
                return _objectSpread(_objectSpread({}, acc), {}, defineProperty({}, redirect.title, redirect));
              }, {});
            } catch (e) {
              console.log("Was unable to load YAML into JS due to: ".concat(e.message));
              throw e;
            }
          }
          createClass(Redirects, [{
            key: "getRedirect",
            value: function getRedirect(title) {
              var _this = this;
              if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
                return this.redirects[title];
              }
              var values = Object.keys(this.redirects).map(function (key) {
                return _this.redirects[key];
              });
              return values.find(function (redirect) {
                var aliases = redirect.aliases;
                if (!aliases) {
                  return false;
                }
                return aliases.indexOf(title) > -1;
              });
            }
          }]);
          return Redirects;
        }();
        var redirectsMap = {
          "1x1-transparent.gif": "1x1-transparent.gif",
          "1x1.gif": "1x1-transparent.gif",
          "1x1-transparent-gif": "1x1-transparent.gif",
          "2x2-transparent.png": "2x2-transparent.png",
          "2x2.png": "2x2-transparent.png",
          "2x2-transparent-png": "2x2-transparent.png",
          "3x2-transparent.png": "3x2-transparent.png",
          "3x2.png": "3x2-transparent.png",
          "3x2-transparent-png": "3x2-transparent.png",
          "32x32-transparent.png": "32x32-transparent.png",
          "32x32.png": "32x32-transparent.png",
          "32x32-transparent-png": "32x32-transparent.png",
          noopframe: "noopframe.html",
          "noop.html": "noopframe.html",
          "blank-html": "noopframe.html",
          noopcss: "noopcss.css",
          "blank-css": "noopcss.css",
          noopjs: "noopjs.js",
          "noop.js": "noopjs.js",
          "blank-js": "noopjs.js",
          noopjson: "noopjson.json",
          nooptext: "nooptext.js",
          "noop.txt": "nooptext.js",
          "blank-text": "nooptext.js",
          empty: "nooptext.js",
          "noopvmap-1.0": "noopvmap01.xml",
          "noop-vmap1.0.xml": "noopvmap01.xml",
          "noopvast-2.0": "noopvast02.xml",
          "noopvast-3.0": "noopvast03.xml",
          "noopvast-4.0": "noopvast04.xml",
          "noopmp3-0.1s": "noopmp3.mp3",
          "blank-mp3": "noopmp3.mp3",
          "noopmp4-1s": "noopmp4.mp4",
          "noop-1s.mp4": "noopmp4.mp4",
          "blank-mp4": "noopmp4.mp4",
          "click2load.html": "click2load.html",
          "ubo-click2load.html": "click2load.html",
          "amazon-apstag": "amazon-apstag.js",
          "ubo-amazon_apstag.js": "amazon-apstag.js",
          "amazon_apstag.js": "amazon-apstag.js",
          "ati-smarttag": "ati-smarttag.js",
          "didomi-loader": "didomi-loader.js",
          fingerprintjs2: "fingerprintjs2.js",
          "ubo-fingerprint2.js": "fingerprintjs2.js",
          "fingerprint2.js": "fingerprintjs2.js",
          fingerprintjs3: "fingerprintjs3.js",
          "ubo-fingerprint3.js": "fingerprintjs3.js",
          "fingerprint3.js": "fingerprintjs3.js",
          gemius: "gemius.js",
          "google-analytics-ga": "google-analytics-ga.js",
          "ubo-google-analytics_ga.js": "google-analytics-ga.js",
          "google-analytics_ga.js": "google-analytics-ga.js",
          "google-analytics": "google-analytics.js",
          "ubo-google-analytics_analytics.js": "google-analytics.js",
          "google-analytics_analytics.js": "google-analytics.js",
          "googletagmanager-gtm": "google-analytics.js",
          "ubo-googletagmanager_gtm.js": "google-analytics.js",
          "googletagmanager_gtm.js": "google-analytics.js",
          "google-ima3": "google-ima3.js",
          "googlesyndication-adsbygoogle": "googlesyndication-adsbygoogle.js",
          "ubo-googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
          "googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
          "googletagservices-gpt": "googletagservices-gpt.js",
          "ubo-googletagservices_gpt.js": "googletagservices-gpt.js",
          "googletagservices_gpt.js": "googletagservices-gpt.js",
          matomo: "matomo.js",
          "metrika-yandex-tag": "metrika-yandex-tag.js",
          "metrika-yandex-watch": "metrika-yandex-watch.js",
          "naver-wcslog": "naver-wcslog.js",
          noeval: "noeval.js",
          "noeval.js": "noeval.js",
          "silent-noeval.js": "noeval.js",
          "ubo-noeval.js": "noeval.js",
          "ubo-silent-noeval.js": "noeval.js",
          "ubo-noeval": "noeval.js",
          "ubo-silent-noeval": "noeval.js",
          "pardot-1.0": "pardot-1.0.js",
          "prebid-ads": "prebid-ads.js",
          "ubo-prebid-ads.js": "prebid-ads.js",
          "prebid-ads.js": "prebid-ads.js",
          prebid: "prebid.js",
          "prevent-bab": "prevent-bab.js",
          "nobab.js": "prevent-bab.js",
          "ubo-nobab.js": "prevent-bab.js",
          "bab-defuser.js": "prevent-bab.js",
          "ubo-bab-defuser.js": "prevent-bab.js",
          "ubo-nobab": "prevent-bab.js",
          "ubo-bab-defuser": "prevent-bab.js",
          "prevent-bab2": "prevent-bab2.js",
          "nobab2.js": "prevent-bab2.js",
          "prevent-fab-3.2.0": "prevent-fab-3.2.0.js",
          "nofab.js": "prevent-fab-3.2.0.js",
          "ubo-nofab.js": "prevent-fab-3.2.0.js",
          "fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
          "ubo-fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
          "ubo-nofab": "prevent-fab-3.2.0.js",
          "prevent-popads-net": "prevent-popads-net.js",
          "popads.net.js": "prevent-popads-net.js",
          "ubo-popads.net.js": "prevent-popads-net.js",
          "ubo-popads.net": "prevent-popads-net.js",
          "scorecardresearch-beacon": "scorecardresearch-beacon.js",
          "ubo-scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
          "scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
          "set-popads-dummy": "set-popads-dummy.js",
          "popads-dummy.js": "set-popads-dummy.js",
          "ubo-popads-dummy.js": "set-popads-dummy.js",
          "ubo-popads-dummy": "set-popads-dummy.js"
        };
        var getRedirectByName = function getRedirectByName(name) {
          var redirects = Object.keys(redirectsList).map(function (key) {
            return redirectsList[key];
          });
          return redirects.find(function (r) {
            return r.names && r.names.indexOf(name) > -1;
          });
        };
        var getRedirectCode = function getRedirectCode(source) {
          var redirect = getRedirectByName(source.name);
          var result = attachDependencies(redirect);
          result = addCall(redirect, result);
          result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result, true);
          return result;
        };
        var getRedirectFilename = function getRedirectFilename(name) {
          return redirectsMap[name];
        };
        var redirects = {
          Redirects: Redirects,
          getRedirectFilename: getRedirectFilename,
          getCode: getRedirectCode,
          isAdgRedirectRule: validator.isAdgRedirectRule,
          isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
          isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
          isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
          isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
          convertUboRedirectToAdg: convertUboRedirectToAdg,
          convertAbpRedirectToAdg: convertAbpRedirectToAdg,
          convertRedirectToAdg: convertRedirectToAdg,
          convertAdgRedirectToUbo: convertAdgRedirectToUbo
        };
        function abortCurrentInlineScript(source, args) {
          function abortCurrentInlineScript(source, property, search) {
            var searchRegexp = toRegExp(search);
            var rid = randomId();
            var SRC_DATA_MARKER = "data:text/javascript;base64,";
            var getCurrentScript = function getCurrentScript() {
              if ("currentScript" in document) {
                return document.currentScript;
              }
              var scripts = document.getElementsByTagName("script");
              return scripts[scripts.length - 1];
            };
            var ourScript = getCurrentScript();
            var abort = function abort() {
              var scriptEl = getCurrentScript();
              if (!scriptEl) {
                return;
              }
              var content = scriptEl.textContent;
              try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
              } catch (e) {}
              if (content.length === 0 && typeof scriptEl.src !== "undefined" && startsWith(scriptEl.src, SRC_DATA_MARKER)) {
                var encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
                content = window.atob(encodedContent);
              }
              if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                throw new ReferenceError(rid);
              }
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded."));
                return;
              }
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var currentValue = base[prop];
              var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
              if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
                currentValue = base[prop];
                origDescriptor = undefined;
              }
              var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                currentValue: currentValue,
                get: function get() {
                  if (!this.isAbortingSuspended) {
                    this.isolateCallback(abort);
                  }
                  if (origDescriptor instanceof Object) {
                    return origDescriptor.get.call(base);
                  }
                  return this.currentValue;
                },
                set: function set(newValue) {
                  if (!this.isAbortingSuspended) {
                    this.isolateCallback(abort);
                  }
                  if (origDescriptor instanceof Object) {
                    origDescriptor.set.call(base, newValue);
                  } else {
                    this.currentValue = newValue;
                  }
                }
              });
              setPropertyAccess(base, prop, {
                get: function get() {
                  return descriptorWrapper.get.call(descriptorWrapper);
                },
                set: function set(newValue) {
                  descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function startsWith(str, prefix) {
            return !!str && str.indexOf(prefix) === 0;
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function getDescriptorAddon() {
            return {
              isAbortingSuspended: false,
              isolateCallback: function isolateCallback(cb) {
                this.isAbortingSuspended = true;
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var result = cb.apply(void 0, args);
                this.isAbortingSuspended = false;
                return result;
              }
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortCurrentInlineScript.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnPropertyRead(source, args) {
          function abortOnPropertyRead(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                get: abort,
                set: function set() {}
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnPropertyRead.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnPropertyWrite(source, args) {
          function abortOnPropertyWrite(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                set: abort
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnPropertyWrite.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnStackTrace(source, args) {
          function abortOnStackTrace(source, property, stack) {
            if (!property || !stack) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              if (!isValidStrPattern(stack)) {
                console.log("Invalid parameter: ".concat(stack));
                return;
              }
              var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                value: base[prop],
                get: function get() {
                  if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                    abort();
                  }
                  return this.value;
                },
                set: function set(newValue) {
                  if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                    abort();
                  }
                  this.value = newValue;
                }
              });
              setPropertyAccess(base, prop, {
                get: function get() {
                  return descriptorWrapper.get.call(descriptorWrapper);
                },
                set: function set(newValue) {
                  descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getDescriptorAddon() {
            return {
              isAbortingSuspended: false,
              isolateCallback: function isolateCallback(cb) {
                this.isAbortingSuspended = true;
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var result = cb.apply(void 0, args);
                this.isAbortingSuspended = false;
                return result;
              }
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getNativeRegexpTest() {
            return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnStackTrace.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function adjustSetInterval(source, args) {
          function adjustSetInterval(source, matchCallback, matchDelay, boost) {
            var nativeSetInterval = window.setInterval;
            var matchRegexp = toRegExp(matchCallback);
            var intervalWrapper = function intervalWrapper(callback, delay) {
              if (!isValidCallback(callback)) {
                if (source.verbose) {
                  console.log("Scriptlet adjust-setInterval can not be applied because of invalid callback: '".concat(String(callback), "'."));
                }
              } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeSetInterval.apply(window, [callback, delay].concat(args));
            };
            window.setInterval = intervalWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getBoostMultiplier(boost) {
            var DEFAULT_MULTIPLIER = .05;
            var MIN_MULTIPLIER = .02;
            var MAX_MULTIPLIER = 50;
            var parsedBoost = parseFloat(boost);
            var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
            if (boostMultiplier < MIN_MULTIPLIER) {
              boostMultiplier = MIN_MULTIPLIER;
            }
            if (boostMultiplier > MAX_MULTIPLIER) {
              boostMultiplier = MAX_MULTIPLIER;
            }
            return boostMultiplier;
          }
          function isDelayMatched(inputDelay, realDelay) {
            return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function getMatchDelay(delay) {
            var DEFAULT_DELAY = 1e3;
            var parsedDelay = parseInt(delay, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
            return delayMatch;
          }
          function getWildcardSymbol() {
            return "*";
          }
          function shouldMatchAnyDelay(delay) {
            return delay === getWildcardSymbol();
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            adjustSetInterval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function adjustSetTimeout(source, args) {
          function adjustSetTimeout(source, matchCallback, matchDelay, boost) {
            var nativeSetTimeout = window.setTimeout;
            var matchRegexp = toRegExp(matchCallback);
            var timeoutWrapper = function timeoutWrapper(callback, delay) {
              if (!isValidCallback(callback)) {
                if (source.verbose) {
                  console.log("Scriptlet adjust-setTimeout can not be applied because of invalid callback: '".concat(String(callback), "'."));
                }
              } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeSetTimeout.apply(window, [callback, delay].concat(args));
            };
            window.setTimeout = timeoutWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getBoostMultiplier(boost) {
            var DEFAULT_MULTIPLIER = .05;
            var MIN_MULTIPLIER = .02;
            var MAX_MULTIPLIER = 50;
            var parsedBoost = parseFloat(boost);
            var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
            if (boostMultiplier < MIN_MULTIPLIER) {
              boostMultiplier = MIN_MULTIPLIER;
            }
            if (boostMultiplier > MAX_MULTIPLIER) {
              boostMultiplier = MAX_MULTIPLIER;
            }
            return boostMultiplier;
          }
          function isDelayMatched(inputDelay, realDelay) {
            return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function getMatchDelay(delay) {
            var DEFAULT_DELAY = 1e3;
            var parsedDelay = parseInt(delay, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
            return delayMatch;
          }
          function getWildcardSymbol() {
            return "*";
          }
          function shouldMatchAnyDelay(delay) {
            return delay === getWildcardSymbol();
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            adjustSetTimeout.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugCurrentInlineScript(source, args) {
          function debugCurrentInlineScript(source, property, search) {
            var searchRegexp = toRegExp(search);
            var rid = randomId();
            var getCurrentScript = function getCurrentScript() {
              if ("currentScript" in document) {
                return document.currentScript;
              }
              var scripts = document.getElementsByTagName("script");
              return scripts[scripts.length - 1];
            };
            var ourScript = getCurrentScript();
            var abort = function abort() {
              var scriptEl = getCurrentScript();
              if (!scriptEl) {
                return;
              }
              var content = scriptEl.textContent;
              try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
              } catch (e) {}
              if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                debugger;
              }
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded."));
                return;
              }
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var currentValue = base[prop];
              setPropertyAccess(base, prop, {
                set: function set(value) {
                  abort();
                  currentValue = value;
                },
                get: function get() {
                  abort();
                  return currentValue;
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugCurrentInlineScript.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugOnPropertyRead(source, args) {
          function debugOnPropertyRead(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              debugger;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                get: abort,
                set: noopFunc
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugOnPropertyRead.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugOnPropertyWrite(source, args) {
          function debugOnPropertyWrite(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              debugger;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                set: abort
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugOnPropertyWrite.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function dirString(source, args) {
          function dirString(source, times) {
            var _console = console,
                dir = _console.dir;
            times = parseInt(times, 10);
            function dirWrapper(object) {
              var temp;
              for (var i = 0; i < times; i += 1) {
                temp = "".concat(object);
              }
              if (typeof dir === "function") {
                dir.call(this, object);
              }
              hit(source, temp);
            }
            console.dir = dirWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            dirString.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function disableNewtabLinks(source, args) {
          function disableNewtabLinks(source) {
            document.addEventListener("click", function (ev) {
              var target = ev.target;
              while (target !== null) {
                if (target.localName === "a" && target.hasAttribute("target")) {
                  ev.stopPropagation();
                  ev.preventDefault();
                  hit(source);
                  break;
                }
                target = target.parentNode;
              }
            });
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            disableNewtabLinks.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function forceWindowClose(source, args) {
          function forceWindowClose(source) {
            var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var log = console.log.bind(console);
            if (typeof window.close !== "function") {
              if (source.verbose) {
                log("window.close() is not a function so 'close-window' scriptlet is unavailable");
              }
              return;
            }
            var closeImmediately = function closeImmediately() {
              try {
                hit(source);
                window.close();
              } catch (e) {
                log(e);
              }
            };
            var closeByExtension = function closeByExtension() {
              var extCall = function extCall() {
                dispatchEvent(new Event("adguard:scriptlet-close-window"));
              };
              window.addEventListener("adguard:subscribed-to-close-window", extCall, {
                once: true
              });
              setTimeout(function () {
                window.removeEventListener("adguard:subscribed-to-close-window", extCall, {
                  once: true
                });
              }, 5e3);
            };
            var shouldClose = function shouldClose() {
              if (path === "") {
                return true;
              }
              var pathRegexp = toRegExp(path);
              var currentPath = "".concat(window.location.pathname).concat(window.location.search);
              return pathRegexp.test(currentPath);
            };
            if (shouldClose()) {
              closeImmediately();
              if (navigator.userAgent.indexOf("Chrome") > -1) {
                closeByExtension();
              }
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            forceWindowClose.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function hideInShadowDom(source, args) {
          function hideInShadowDom(source, selector, baseSelector) {
            if (!Element.prototype.attachShadow) {
              return;
            }
            var hideElement = function hideElement(targetElement) {
              var DISPLAY_NONE_CSS = "display:none!important;";
              targetElement.style.cssText = DISPLAY_NONE_CSS;
            };
            var hideHandler = function hideHandler() {
              var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
              while (hostElements.length !== 0) {
                var isHidden = false;
                var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                    targets = _pierceShadowDom.targets,
                    innerHosts = _pierceShadowDom.innerHosts;
                targets.forEach(function (targetEl) {
                  hideElement(targetEl);
                  isHidden = true;
                });
                if (isHidden) {
                  hit(source);
                }
                hostElements = innerHosts;
              }
            };
            hideHandler();
            observeDOMChanges(hideHandler, true);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var throttle = function throttle(method, delay) {
              var wait = false;
              var savedArgs;
              var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (wait) {
                  savedArgs = args;
                  return;
                }
                method.apply(void 0, args);
                wait = true;
                setTimeout(function () {
                  wait = false;
                  if (savedArgs) {
                    wrapper(savedArgs);
                    savedArgs = null;
                  }
                }, delay);
              };
              return wrapper;
            };
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function flatten(input) {
            var stack = [];
            input.forEach(function (el) {
              return stack.push(el);
            });
            var res = [];
            while (stack.length) {
              var next = stack.pop();
              if (Array.isArray(next)) {
                next.forEach(function (el) {
                  return stack.push(el);
                });
              } else {
                res.push(next);
              }
            }
            return res.reverse();
          }
          function findHostElements(rootElement) {
            var hosts = [];
            var domElems = rootElement.querySelectorAll("*");
            domElems.forEach(function (el) {
              if (el.shadowRoot) {
                hosts.push(el);
              }
            });
            return hosts;
          }
          function pierceShadowDom(selector, hostElements) {
            var targets = [];
            var innerHostsAcc = [];
            hostElements.forEach(function (host) {
              var simpleElems = host.querySelectorAll(selector);
              targets = targets.concat([].slice.call(simpleElems));
              var shadowRootElem = host.shadowRoot;
              var shadowChildren = shadowRootElem.querySelectorAll(selector);
              targets = targets.concat([].slice.call(shadowChildren));
              innerHostsAcc.push(findHostElements(shadowRootElem));
            });
            var innerHosts = flatten(innerHostsAcc);
            return {
              targets: targets,
              innerHosts: innerHosts
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            hideInShadowDom.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function jsonPrune(source, args) {
          function jsonPrune(source, propsToRemove, requiredInitialProps, stack) {
            if (!!stack && !matchStackTrace(stack, new Error().stack)) {
              return;
            }
            var log = console.log.bind(console);
            var prunePaths = propsToRemove !== undefined && propsToRemove !== "" ? propsToRemove.split(/ +/) : [];
            var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== "" ? requiredInitialProps.split(/ +/) : [];
            function isPruningNeeded(root) {
              if (!root) {
                return false;
              }
              var shouldProcess;
              if (prunePaths.length === 0 && requiredPaths.length > 0) {
                var rootString = JSON.stringify(root);
                var matchRegex = toRegExp(requiredPaths.join(""));
                var shouldLog = matchRegex.test(rootString);
                if (shouldLog) {
                  log(window.location.hostname, root);
                  shouldProcess = false;
                  return shouldProcess;
                }
              }
              for (var i = 0; i < requiredPaths.length; i += 1) {
                var requiredPath = requiredPaths[i];
                var lastNestedPropName = requiredPath.split(".").pop();
                var hasWildcard = requiredPath.indexOf(".*.") > -1 || requiredPath.indexOf("*.") > -1 || requiredPath.indexOf(".*") > -1 || requiredPath.indexOf(".[].") > -1 || requiredPath.indexOf("[].") > -1 || requiredPath.indexOf(".[]") > -1;
                var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
                shouldProcess = !hasWildcard;
                for (var _i = 0; _i < details.length; _i += 1) {
                  if (hasWildcard) {
                    shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;
                  } else {
                    shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;
                  }
                }
              }
              return shouldProcess;
            }
            var jsonPruner = function jsonPruner(root) {
              if (prunePaths.length === 0 && requiredPaths.length === 0) {
                log(window.location.hostname, root);
                return root;
              }
              try {
                if (isPruningNeeded(root) === false) {
                  return root;
                }
                prunePaths.forEach(function (path) {
                  var ownerObjArr = getWildcardPropertyInChain(root, path, true);
                  ownerObjArr.forEach(function (ownerObj) {
                    if (ownerObj !== undefined && ownerObj.base) {
                      delete ownerObj.base[ownerObj.prop];
                      hit(source);
                    }
                  });
                });
              } catch (e) {
                log(e.toString());
              }
              return root;
            };
            var nativeJSONParse = JSON.parse;
            var jsonParseWrapper = function jsonParseWrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var root = nativeJSONParse.apply(JSON, args);
              return jsonPruner(root);
            };
            jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
            JSON.parse = jsonParseWrapper;
            var nativeResponseJson = Response.prototype.json;
            var responseJsonWrapper = function responseJsonWrapper() {
              var promise = nativeResponseJson.apply(this);
              return promise.then(function (obj) {
                return jsonPruner(obj);
              });
            };
            if (typeof Response === "undefined") {
              return;
            }
            Response.prototype.json = responseJsonWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getWildcardPropertyInChain(base, chain) {
            var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var pos = chain.indexOf(".");
            if (pos === -1) {
              if (chain === getWildcardSymbol() || chain === "[]") {
                for (var key in base) {
                  if (Object.prototype.hasOwnProperty.call(base, key)) {
                    output.push({
                      base: base,
                      prop: key
                    });
                  }
                }
              } else {
                output.push({
                  base: base,
                  prop: chain
                });
              }
              return output;
            }
            var prop = chain.slice(0, pos);
            var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === getWildcardSymbol() && base instanceof Object;
            if (shouldLookThrough) {
              var nextProp = chain.slice(pos + 1);
              var baseKeys = Object.keys(base);
              baseKeys.forEach(function (key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output);
              });
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
            }
            return output;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getWildcardSymbol() {
            return "*";
          }
          function getNativeRegexpTest() {
            return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            jsonPrune.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function log(source, args) {
          function log() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            console.log(args);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            log.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logAddEventListener(source, args) {
          function logAddEventListener(source) {
            var log = console.log.bind(console);
            var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
            function addEventListenerWrapper(type, listener) {
              if (validateType(type) && validateListener(listener)) {
                var logMessage = 'addEventListener("'.concat(type, '", ').concat(listenerToString(listener), ")");
                log(logMessage);
                hit(source);
              } else if (source.verbose) {
                var _logMessage = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
                log(_logMessage);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeAddEventListener.apply(this, [type, listener].concat(args));
            }
            window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function validateType(type) {
            return typeof type !== "undefined";
          }
          function validateListener(listener) {
            return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
          }
          function listenerToString(listener) {
            return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
          }
          function convertTypeToString(value) {
            var output;
            if (typeof value === "undefined") {
              output = "undefined";
            } else if (typeof value === "object") {
              if (value === null) {
                output = "null";
              } else {
                output = objectToString(value);
              }
            } else {
              output = value.toString();
            }
            return output;
          }
          function objectToString(obj) {
            return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0;
          }
          function getObjectEntries(object) {
            var keys = Object.keys(object);
            var entries = [];
            keys.forEach(function (key) {
              return entries.push([key, object[key]]);
            });
            return entries;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logAddEventListener.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logEval(source, args) {
          function logEval(source) {
            var log = console.log.bind(console);
            var nativeEval = window.eval;
            function evalWrapper(str) {
              hit(source);
              log('eval("'.concat(str, '")'));
              return nativeEval(str);
            }
            window.eval = evalWrapper;
            var nativeFunction = window.Function;
            function FunctionWrapper() {
              hit(source);
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              log("new Function(".concat(args.join(", "), ")"));
              return nativeFunction.apply(this, [].concat(args));
            }
            FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
            FunctionWrapper.prototype.constructor = FunctionWrapper;
            window.Function = FunctionWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logEval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logOnStacktrace(source, args) {
          function logOnStacktrace(source, property) {
            if (!property) {
              return;
            }
            var refineStackTrace = function refineStackTrace(stackString) {
              var stackSteps = stackString.split("\n").slice(2).map(function (line) {
                return line.replace(/ {4}at /, "");
              });
              var logInfoArray = stackSteps.map(function (line) {
                var funcName;
                var funcFullPath;
                var reg = /\(([^\)]+)\)/;
                if (line.match(reg)) {
                  funcName = line.split(" ").slice(0, -1).join(" ");
                  funcFullPath = line.match(reg)[1];
                } else {
                  funcName = "function name is not available";
                  funcFullPath = line;
                }
                return [funcName, funcFullPath];
              });
              var logInfoObject = {};
              logInfoArray.forEach(function (pair) {
                logInfoObject[pair[0]] = pair[1];
              });
              return logInfoObject;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var value = base[prop];
              setPropertyAccess(base, prop, {
                get: function get() {
                  hit(source);
                  console.log("%cGet %c".concat(prop), "color:red;", "color:green;");
                  console.table(refineStackTrace(new Error().stack));
                  return value;
                },
                set: function set(newValue) {
                  hit(source);
                  console.log("%cSet %c".concat(prop), "color:red;", "color:green;");
                  console.table(refineStackTrace(new Error().stack));
                  value = newValue;
                }
              });
            };
            setChainPropAccess(window, property);
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logOnStacktrace.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function noTopics(source, args) {
          function noTopics(source) {
            var TOPICS_PROPERTY_NAME = "browsingTopics";
            if (Document instanceof Object === false) {
              return;
            }
            if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
              return;
            }
            Document.prototype[TOPICS_PROPERTY_NAME] = function () {
              return noopPromiseResolve("[]");
            };
            hit(source);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            return Promise.resolve(response);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            noTopics.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function noeval(source, args) {
          function noeval(source) {
            window.eval = function evalWrapper(s) {
              hit(source, "AdGuard has prevented eval:\n".concat(s));
            }.bind();
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            noeval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function nowebrtc(source, args) {
          function nowebrtc(source) {
            var propertyName = "";
            if (window.RTCPeerConnection) {
              propertyName = "RTCPeerConnection";
            } else if (window.webkitRTCPeerConnection) {
              propertyName = "webkitRTCPeerConnection";
            }
            if (propertyName === "") {
              return;
            }
            var rtcReplacement = function rtcReplacement(config) {
              hit(source, "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config)));
            };
            rtcReplacement.prototype = {
              close: noopFunc,
              createDataChannel: noopFunc,
              createOffer: noopFunc,
              setRemoteDescription: noopFunc
            };
            var rtc = window[propertyName];
            window[propertyName] = rtcReplacement;
            if (rtc.prototype) {
              rtc.prototype.createDataChannel = function (a, b) {
                return {
                  close: noopFunc,
                  send: noopFunc
                };
              }.bind(null);
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function convertRtcConfigToString(config) {
            var UNDEF_STR = "undefined";
            var str = UNDEF_STR;
            if (config === null) {
              str = "null";
            } else if (config instanceof Object) {
              var SERVERS_PROP_NAME = "iceServers";
              var URLS_PROP_NAME = "urls";
              if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
                str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
              }
            }
            return str;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            nowebrtc.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventAddEventListener(source, args) {
          function preventAddEventListener(source, typeSearch, listenerSearch) {
            var typeSearchRegexp = toRegExp(typeSearch);
            var listenerSearchRegexp = toRegExp(listenerSearch);
            var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
            function addEventListenerWrapper(type, listener) {
              var shouldPrevent = false;
              if (validateType(type) && validateListener(listener)) {
                shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
              }
              if (shouldPrevent) {
                hit(source);
                return undefined;
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeAddEventListener.apply(this, [type, listener].concat(args));
            }
            window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
            window.addEventListener = addEventListenerWrapper;
            document.addEventListener = addEventListenerWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function validateType(type) {
            return typeof type !== "undefined";
          }
          function validateListener(listener) {
            return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
          }
          function listenerToString(listener) {
            return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventAddEventListener.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventAdfly(source, args) {
          function preventAdfly(source) {
            var isDigit = function isDigit(data) {
              return /^\d$/.test(data);
            };
            var handler = function handler(encodedURL) {
              var evenChars = "";
              var oddChars = "";
              for (var i = 0; i < encodedURL.length; i += 1) {
                if (i % 2 === 0) {
                  evenChars += encodedURL.charAt(i);
                } else {
                  oddChars = encodedURL.charAt(i) + oddChars;
                }
              }
              var data = (evenChars + oddChars).split("");
              for (var _i = 0; _i < data.length; _i += 1) {
                if (isDigit(data[_i])) {
                  for (var ii = _i + 1; ii < data.length; ii += 1) {
                    if (isDigit(data[ii])) {
                      var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);
                      if (temp < 10) {
                        data[_i] = temp.toString();
                      }
                      _i = ii;
                      break;
                    }
                  }
                }
              }
              data = data.join("");
              var decodedURL = window.atob(data).slice(16, -16);
              if (window.stop) {
                window.stop();
              }
              window.onbeforeunload = null;
              window.location.href = decodedURL;
            };
            var val;
            var applyHandler = true;
            var result = setPropertyAccess(window, "ysmm", {
              configurable: false,
              set: function set(value) {
                if (applyHandler) {
                  applyHandler = false;
                  try {
                    if (typeof value === "string") {
                      handler(value);
                    }
                  } catch (err) {}
                }
                val = value;
              },
              get: function get() {
                return val;
              }
            });
            if (result) {
              hit(source);
            } else {
              window.console.error("Failed to set up prevent-adfly scriptlet");
            }
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventAdfly.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventBab(source, args) {
          function preventBab(source) {
            var nativeSetTimeout = window.setTimeout;
            var babRegex = /\.bab_elementid.$/;
            var timeoutWrapper = function timeoutWrapper(callback) {
              if (typeof callback !== "string" || !babRegex.test(callback)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeSetTimeout.apply(window, [callback].concat(args));
              }
              hit(source);
            };
            window.setTimeout = timeoutWrapper;
            var signatures = [["blockadblock"], ["babasbm"], [/getItem\('babn'\)/], ["getElementById", "String.fromCharCode", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "charAt", "DOMContentLoaded", "AdBlock", "addEventListener", "doScroll", "fromCharCode", "<<2|r>>4", "sessionStorage", "clientWidth", "localStorage", "Math", "random"]];
            var check = function check(str) {
              if (typeof str !== "string") {
                return false;
              }
              for (var i = 0; i < signatures.length; i += 1) {
                var tokens = signatures[i];
                var match = 0;
                for (var j = 0; j < tokens.length; j += 1) {
                  var token = tokens[j];
                  var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
                  if (found) {
                    match += 1;
                  }
                }
                if (match / tokens.length >= .8) {
                  return true;
                }
              }
              return false;
            };
            var nativeEval = window.eval;
            var evalWrapper = function evalWrapper(str) {
              if (!check(str)) {
                return nativeEval(str);
              }
              hit(source);
              var bodyEl = document.body;
              if (bodyEl) {
                bodyEl.style.removeProperty("visibility");
              }
              var el = document.getElementById("babasbmsgx");
              if (el) {
                el.parentNode.removeChild(el);
              }
            };
            window.eval = evalWrapper.bind(window);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventBab.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventElementSrcLoading(source, args) {
          function preventElementSrcLoading(source, tagName, match) {
            if (typeof Proxy === "undefined" || typeof Reflect === "undefined") {
              return;
            }
            var srcMockData = {
              script: "data:text/javascript;base64,KCk9Pnt9",
              img: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              iframe: "data:text/html;base64, PGRpdj48L2Rpdj4="
            };
            var instance;
            if (tagName === "script") {
              instance = HTMLScriptElement;
            } else if (tagName === "img") {
              instance = HTMLImageElement;
            } else if (tagName === "iframe") {
              instance = HTMLIFrameElement;
            } else {
              return;
            }
            var hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === "function";
            var policy;
            if (hasTrustedTypes) {
              policy = window.trustedTypes.createPolicy("mock", {
                createScriptURL: function createScriptURL(arg) {
                  return arg;
                }
              });
            }
            var SOURCE_PROPERTY_NAME = "src";
            var searchRegexp = toRegExp(match);
            var setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
              if (!args[0] || !args[1]) {
                return Reflect.apply(target, thisArg, args);
              }
              var nodeName = thisArg.nodeName.toLowerCase();
              var attrName = args[0].toLowerCase();
              var attrValue = args[1];
              var isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
              if (!isMatched) {
                return Reflect.apply(target, thisArg, args);
              }
              hit(source);
              return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
            };
            var setAttributeHandler = {
              apply: setAttributeWrapper
            };
            instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
            var origDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
            if (!origDescriptor) {
              return;
            }
            Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
              enumerable: true,
              configurable: true,
              get: function get() {
                return origDescriptor.get.call(this);
              },
              set: function set(urlValue) {
                var nodeName = this.nodeName.toLowerCase();
                var isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
                if (!isMatched) {
                  origDescriptor.set.call(this, urlValue);
                  return;
                }
                if (policy && urlValue instanceof TrustedScriptURL) {
                  var trustedSrc = policy.createScriptURL(urlValue);
                  origDescriptor.set.call(this, trustedSrc);
                  hit(source);
                  return;
                }
                origDescriptor.set.call(this, srcMockData[nodeName]);
                hit(source);
              }
            });
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function safeGetDescriptor(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            if (descriptor && descriptor.configurable) {
              return descriptor;
            }
            return null;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventElementSrcLoading.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventEvalIf(source, args) {
          function preventEvalIf(source, search) {
            var searchRegexp = toRegExp(search);
            var nativeEval = window.eval;
            window.eval = function (payload) {
              if (!searchRegexp.test(payload.toString())) {
                return nativeEval.call(window, payload);
              }
              hit(source, payload);
              return undefined;
            }.bind(window);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventEvalIf.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventFab(source, args) {
          function preventFab(source) {
            hit(source);
            var Fab = function Fab() {};
            Fab.prototype.check = noopFunc;
            Fab.prototype.clearEvent = noopFunc;
            Fab.prototype.emitEvent = noopFunc;
            Fab.prototype.on = function (a, b) {
              if (!a) {
                b();
              }
              return this;
            };
            Fab.prototype.onDetected = noopThis;
            Fab.prototype.onNotDetected = function (a) {
              a();
              return this;
            };
            Fab.prototype.setOption = noopFunc;
            Fab.prototype.options = {
              set: noopFunc,
              get: noopFunc
            };
            var fab = new Fab();
            var getSetFab = {
              get: function get() {
                return Fab;
              },
              set: function set() {}
            };
            var getsetfab = {
              get: function get() {
                return fab;
              },
              set: function set() {}
            };
            if (Object.prototype.hasOwnProperty.call(window, "FuckAdBlock")) {
              window.FuckAdBlock = Fab;
            } else {
              Object.defineProperty(window, "FuckAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "BlockAdBlock")) {
              window.BlockAdBlock = Fab;
            } else {
              Object.defineProperty(window, "BlockAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "SniffAdBlock")) {
              window.SniffAdBlock = Fab;
            } else {
              Object.defineProperty(window, "SniffAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "fuckAdBlock")) {
              window.fuckAdBlock = fab;
            } else {
              Object.defineProperty(window, "fuckAdBlock", getsetfab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "blockAdBlock")) {
              window.blockAdBlock = fab;
            } else {
              Object.defineProperty(window, "blockAdBlock", getsetfab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "sniffAdBlock")) {
              window.sniffAdBlock = fab;
            } else {
              Object.defineProperty(window, "sniffAdBlock", getsetfab);
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function noopThis() {
            return this;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventFab.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventFetch(source, args) {
          function preventFetch(source, propsToMatch) {
            var responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "emptyObj";
            if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
              return;
            }
            var strResponseBody;
            if (responseBody === "emptyObj") {
              strResponseBody = "{}";
            } else if (responseBody === "emptyArr") {
              strResponseBody = "[]";
            } else {
              return;
            }
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var shouldPrevent = false;
              var fetchData = getFetchData(args);
              if (typeof propsToMatch === "undefined") {
                var logMessage = "log: fetch( ".concat(objectToString(fetchData), " )");
                hit(source, logMessage);
              } else if (propsToMatch === "" || propsToMatch === getWildcardSymbol()) {
                shouldPrevent = true;
              } else {
                var parsedData = parseMatchProps(propsToMatch);
                if (!validateParsedData(parsedData)) {
                  console.log("Invalid parameter: ".concat(propsToMatch));
                  shouldPrevent = false;
                } else {
                  var matchData = getMatchPropsData(parsedData);
                  shouldPrevent = Object.keys(matchData).every(function (matchKey) {
                    var matchValue = matchData[matchKey];
                    return Object.prototype.hasOwnProperty.call(fetchData, matchKey) && matchValue.test(fetchData[matchKey]);
                  });
                }
              }
              if (shouldPrevent) {
                hit(source);
                return noopPromiseResolve(strResponseBody);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var fetchHandler = {
              apply: handlerWrapper
            };
            fetch = new Proxy(fetch, fetchHandler);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function getFetchData(args) {
            var fetchPropsObj = {};
            var fetchUrl;
            var fetchInit;
            if (args[0] instanceof Request) {
              var requestData = getRequestData(args[0]);
              fetchUrl = requestData.url;
              fetchInit = requestData;
            } else {
              fetchUrl = args[0];
              fetchInit = args[1];
            }
            fetchPropsObj.url = fetchUrl;
            if (fetchInit instanceof Object) {
              Object.keys(fetchInit).forEach(function (prop) {
                fetchPropsObj[prop] = fetchInit[prop];
              });
            }
            return fetchPropsObj;
          }
          function objectToString(obj) {
            return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              if (dividerInd === -1) {
                propsObj.url = prop;
              } else {
                var key = prop.slice(0, dividerInd);
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              }
            });
            return propsObj;
          }
          function validateParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function getMatchPropsData(data) {
            var matchData = {};
            Object.keys(data).forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            return Promise.resolve(response);
          }
          function getWildcardSymbol() {
            return "*";
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0;
          }
          function getRequestData(request) {
            var REQUEST_INIT_OPTIONS = ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "integrity"];
            var entries = REQUEST_INIT_OPTIONS.map(function (key) {
              var value = request[key];
              return [key, value];
            });
            return getObjectFromEntries(entries);
          }
          function getObjectEntries(object) {
            var keys = Object.keys(object);
            var entries = [];
            keys.forEach(function (key) {
              return entries.push([key, object[key]]);
            });
            return entries;
          }
          function getObjectFromEntries(entries) {
            var output = entries.reduce(function (acc, el) {
              var key = el[0];
              var value = el[1];
              acc[key] = value;
              return acc;
            }, {});
            return output;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventFetch.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventPopadsNet(source, args) {
          function preventPopadsNet(source) {
            var rid = randomId();
            var throwError = function throwError() {
              throw new ReferenceError(rid);
            };
            delete window.PopAds;
            delete window.popns;
            Object.defineProperties(window, {
              PopAds: {
                set: throwError
              },
              popns: {
                set: throwError
              }
            });
            window.onerror = createOnErrorHandler(rid).bind();
            hit(source);
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.indexOf(rid) !== -1) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(this, [error].concat(args));
              }
              return false;
            };
          }
          function randomId() {
            return Math.random().toString(36).substr(2, 9);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventPopadsNet.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventRefresh(source, args) {
          function preventRefresh(source, delaySec) {
            var getMetaElements = function getMetaElements() {
              var metaNodes = [];
              try {
                metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
              } catch (e) {
                try {
                  metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
                } catch (e) {
                  if (source.verbose) {
                    console.log(e);
                  }
                }
              }
              return Array.from(metaNodes);
            };
            var getMetaContentDelay = function getMetaContentDelay(metaElements) {
              var delays = metaElements.map(function (meta) {
                var contentString = meta.getAttribute("content");
                if (contentString.length === 0) {
                  return null;
                }
                var contentDelay;
                var limiterIndex = contentString.indexOf(";");
                if (limiterIndex !== -1) {
                  var delaySubstring = contentString.substring(0, limiterIndex);
                  contentDelay = getNumberFromString(delaySubstring);
                } else {
                  contentDelay = getNumberFromString(contentString);
                }
                return contentDelay;
              }).filter(function (delay) {
                return delay !== null;
              });
              if (!delays.length) {
                return null;
              }
              var minDelay = delays.reduce(function (a, b) {
                return Math.min(a, b);
              });
              return minDelay;
            };
            var stop = function stop() {
              var metaElements = getMetaElements();
              if (metaElements.length === 0) {
                return;
              }
              var secondsToRun = getNumberFromString(delaySec);
              if (secondsToRun === null) {
                secondsToRun = getMetaContentDelay(metaElements);
              }
              if (secondsToRun === null) {
                return;
              }
              var delayMs = secondsToRun * 1e3;
              setTimeout(function () {
                window.stop();
                hit(source);
              }, delayMs);
            };
            if (document.readyState === "loading") {
              document.addEventListener("DOMContentLoaded", stop, {
                once: true
              });
            } else {
              stop();
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function getNumberFromString(rawString) {
            var parsedDelay = parseInt(rawString, 10);
            var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return validDelay;
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventRefresh.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventRequestAnimationFrame(source, args) {
          function preventRequestAnimationFrame(source, match) {
            var nativeRequestAnimationFrame = window.requestAnimationFrame;
            var log = console.log.bind(console);
            var shouldLog = typeof match === "undefined";
            var _parseMatchArg = parseMatchArg(match),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchRegexp = _parseMatchArg.matchRegexp;
            var rafWrapper = function rafWrapper(callback) {
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                log("requestAnimationFrame(".concat(String(callback), ")"));
              } else if (isValidCallback(callback) && isValidStrPattern(match)) {
                shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
              }
              if (shouldPrevent) {
                hit(source);
                return nativeRequestAnimationFrame(noopFunc);
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeRequestAnimationFrame.apply(window, [callback].concat(args));
            };
            window.requestAnimationFrame = rafWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = startsWith(match, INVERT_MARKER);
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp
            };
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function startsWith(str, prefix) {
            return !!str && str.indexOf(prefix) === 0;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventRequestAnimationFrame.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventSetInterval(source, args) {
          function preventSetInterval(source, matchCallback, matchDelay) {
            var isProxySupported = typeof Proxy !== "undefined";
            var nativeInterval = window.setInterval;
            var log = console.log.bind(console);
            var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
            var legacyIntervalWrapper = function legacyIntervalWrapper(callback, delay) {
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                log("setInterval(".concat(String(callback), ", ").concat(delay, ")"));
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                return nativeInterval(noopFunc, delay);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeInterval.apply(window, [callback, delay].concat(args));
            };
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var callback = args[0];
              var delay = args[1];
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                log("setInterval(".concat(String(callback), ", ").concat(delay, ")"));
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
              }
              return target.apply(thisArg, args);
            };
            var setIntervalHandler = {
              apply: handlerWrapper
            };
            window.setInterval = isProxySupported ? new Proxy(window.setInterval, setIntervalHandler) : legacyIntervalWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function isPreventionNeeded(_ref) {
            var callback = _ref.callback,
                delay = _ref.delay,
                matchCallback = _ref.matchCallback,
                matchDelay = _ref.matchDelay;
            if (!isValidCallback(callback)) {
              return false;
            }
            if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
              return false;
            }
            var _parseMatchArg = parseMatchArg(matchCallback),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchRegexp = _parseMatchArg.matchRegexp;
            var _parseDelayArg = parseDelayArg(matchDelay),
                isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
                delayMatch = _parseDelayArg.delayMatch;
            var shouldPrevent = false;
            var callbackStr = String(callback);
            if (delayMatch === null) {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
            } else if (!matchCallback) {
              shouldPrevent = delay === delayMatch !== isInvertedDelayMatch;
            } else {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && delay === delayMatch !== isInvertedDelayMatch;
            }
            return shouldPrevent;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function startsWith(str, prefix) {
            return !!str && str.indexOf(prefix) === 0;
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = startsWith(match, INVERT_MARKER);
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp
            };
          }
          function parseDelayArg(delay) {
            var INVERT_MARKER = "!";
            var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
            var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
            delayValue = parseInt(delayValue, 10);
            var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
            return {
              isInvertedDelayMatch: isInvertedDelayMatch,
              delayMatch: delayMatch
            };
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (startsWith(match, INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function isValidMatchNumber(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (startsWith(match, INVERT_MARKER)) {
              str = match.slice(1);
            }
            var num = parseFloat(str);
            return !nativeIsNaN(num) && nativeIsFinite(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventSetInterval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventSetTimeout(source, args) {
          function preventSetTimeout(source, matchCallback, matchDelay) {
            var isProxySupported = typeof Proxy !== "undefined";
            var nativeTimeout = window.setTimeout;
            var log = console.log.bind(console);
            var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
            var legacyTimeoutWrapper = function legacyTimeoutWrapper(callback, delay) {
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                log("setTimeout(".concat(String(callback), ", ").concat(delay, ")"));
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                return nativeTimeout(noopFunc, delay);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeTimeout.apply(window, [callback, delay].concat(args));
            };
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var callback = args[0];
              var delay = args[1];
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                log("setTimeout(".concat(String(callback), ", ").concat(delay, ")"));
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
              }
              return target.apply(thisArg, args);
            };
            var setTimeoutHandler = {
              apply: handlerWrapper
            };
            window.setTimeout = isProxySupported ? new Proxy(window.setTimeout, setTimeoutHandler) : legacyTimeoutWrapper;
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function isPreventionNeeded(_ref) {
            var callback = _ref.callback,
                delay = _ref.delay,
                matchCallback = _ref.matchCallback,
                matchDelay = _ref.matchDelay;
            if (!isValidCallback(callback)) {
              return false;
            }
            if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
              return false;
            }
            var _parseMatchArg = parseMatchArg(matchCallback),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchRegexp = _parseMatchArg.matchRegexp;
            var _parseDelayArg = parseDelayArg(matchDelay),
                isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
                delayMatch = _parseDelayArg.delayMatch;
            var shouldPrevent = false;
            var callbackStr = String(callback);
            if (delayMatch === null) {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
            } else if (!matchCallback) {
              shouldPrevent = delay === delayMatch !== isInvertedDelayMatch;
            } else {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && delay === delayMatch !== isInvertedDelayMatch;
            }
            return shouldPrevent;
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = startsWith(match, INVERT_MARKER);
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp
            };
          }
          function parseDelayArg(delay) {
            var INVERT_MARKER = "!";
            var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
            var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
            delayValue = parseInt(delayValue, 10);
            var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
            return {
              isInvertedDelayMatch: isInvertedDelayMatch,
              delayMatch: delayMatch
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function startsWith(str, prefix) {
            return !!str && str.indexOf(prefix) === 0;
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (startsWith(match, INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function isValidMatchNumber(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (startsWith(match, INVERT_MARKER)) {
              str = match.slice(1);
            }
            var num = parseFloat(str);
            return !nativeIsNaN(num) && nativeIsFinite(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventSetTimeout.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventWindowOpen(source, args) {
          function preventWindowOpen(source) {
            var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getWildcardSymbol();
            var delay = arguments.length > 2 ? arguments[2] : undefined;
            var replacement = arguments.length > 3 ? arguments[3] : undefined;
            var nativeOpen = window.open;
            var isNewSyntax = match !== "0" && match !== "1";
            var oldOpenWrapper = function oldOpenWrapper(str) {
              match = Number(match) > 0;
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (!isValidStrPattern(delay)) {
                console.log("Invalid parameter: ".concat(delay));
                return nativeOpen.apply(window, [str].concat(args));
              }
              var searchRegexp = toRegExp(delay);
              if (match !== searchRegexp.test(str)) {
                return nativeOpen.apply(window, [str].concat(args));
              }
              hit(source);
              return handleOldReplacement(replacement);
            };
            var newOpenWrapper = function newOpenWrapper(url) {
              var shouldLog = replacement && replacement.indexOf("log") > -1;
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              if (shouldLog) {
                var argsStr = args && args.length > 0 ? ", ".concat(args.join(", ")) : "";
                var logMessage = "log: window-open: ".concat(url).concat(argsStr);
                hit(source, logMessage);
              }
              var shouldPrevent = false;
              if (match === getWildcardSymbol()) {
                shouldPrevent = true;
              } else if (isValidMatchStr(match)) {
                var _parseMatchArg = parseMatchArg(match),
                    isInvertedMatch = _parseMatchArg.isInvertedMatch,
                    matchRegexp = _parseMatchArg.matchRegexp;
                shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
              } else {
                console.log("Invalid parameter: ".concat(match));
                shouldPrevent = false;
              }
              if (shouldPrevent) {
                var parsedDelay = parseInt(delay, 10);
                var result;
                if (nativeIsNaN(parsedDelay)) {
                  result = noopNull();
                } else {
                  var decoyArgs = {
                    replacement: replacement,
                    url: url,
                    delay: parsedDelay
                  };
                  var decoy = createDecoy(decoyArgs);
                  var popup = decoy.contentWindow;
                  if (typeof popup === "object" && popup !== null) {
                    Object.defineProperty(popup, "closed", {
                      value: false
                    });
                    Object.defineProperty(popup, "opener", {
                      value: window
                    });
                    Object.defineProperty(popup, "frameElement", {
                      value: null
                    });
                  } else {
                    var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                    Object.defineProperty(decoy, "contentWindow", {
                      get: getPreventGetter(nativeGetter)
                    });
                    popup = decoy.contentWindow;
                  }
                  result = popup;
                }
                hit(source);
                return result;
              }
              return nativeOpen.apply(window, [url].concat(args));
            };
            window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
            window.open.toString = nativeOpen.toString.bind(nativeOpen);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (startsWith(match, INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = startsWith(match, INVERT_MARKER);
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp
            };
          }
          function handleOldReplacement(replacement) {
            var result;
            if (!replacement) {
              result = noopFunc;
            } else if (replacement === "trueFunc") {
              result = trueFunc;
            } else if (replacement.indexOf("=") > -1) {
              var isProp = startsWith(replacement, "{") && endsWith(replacement, "}");
              if (isProp) {
                var propertyPart = replacement.slice(1, -1);
                var propertyName = substringBefore(propertyPart, "=");
                var propertyValue = substringAfter(propertyPart, "=");
                if (propertyValue === "noopFunc") {
                  result = {};
                  result[propertyName] = noopFunc;
                }
              }
            }
            return result;
          }
          function createDecoy(args) {
            var OBJECT_TAG_NAME = "object";
            var OBJECT_URL_PROP_NAME = "data";
            var IFRAME_TAG_NAME = "iframe";
            var IFRAME_URL_PROP_NAME = "src";
            var replacement = args.replacement,
                url = args.url,
                delay = args.delay;
            var tag;
            var urlProp;
            if (replacement === "obj") {
              tag = OBJECT_TAG_NAME;
              urlProp = OBJECT_URL_PROP_NAME;
            } else {
              tag = IFRAME_TAG_NAME;
              urlProp = IFRAME_URL_PROP_NAME;
            }
            var decoy = document.createElement(tag);
            decoy[urlProp] = url;
            decoy.style.setProperty("height", "1px", "important");
            decoy.style.setProperty("position", "fixed", "important");
            decoy.style.setProperty("top", "-1px", "important");
            decoy.style.setProperty("width", "1px", "important");
            document.body.appendChild(decoy);
            setTimeout(function () {
              return decoy.remove();
            }, delay * 1e3);
            return decoy;
          }
          function getPreventGetter(nativeGetter) {
            var preventGetter = function preventGetter(target, prop) {
              if (prop && prop === "closed") {
                return false;
              }
              if (typeof nativeGetter === "function") {
                return noopFunc;
              }
              return prop && target[prop];
            };
            return preventGetter;
          }
          function noopNull() {
            return null;
          }
          function getWildcardSymbol() {
            return "*";
          }
          function noopFunc() {}
          function trueFunc() {
            return true;
          }
          function startsWith(str, prefix) {
            return !!str && str.indexOf(prefix) === 0;
          }
          function endsWith(str, ending) {
            return !!str && str.indexOf(ending) === str.length - ending.length;
          }
          function substringBefore(str, separator) {
            if (!str || !separator) {
              return str;
            }
            var index = str.indexOf(separator);
            return index < 0 ? str : str.substring(0, index);
          }
          function substringAfter(str, separator) {
            if (!str) {
              return str;
            }
            var index = str.indexOf(separator);
            return index < 0 ? "" : str.substring(index + separator.length);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventWindowOpen.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventXHR(source, args) {
          function preventXHR(source, propsToMatch, customResponseText) {
            if (typeof Proxy === "undefined") {
              return;
            }
            var shouldPrevent = false;
            var response = "";
            var responseText = "";
            var responseUrl;
            var openWrapper = function openWrapper(target, thisArg, args) {
              var xhrData = {
                method: args[0],
                url: args[1]
              };
              responseUrl = xhrData.url;
              if (typeof propsToMatch === "undefined") {
                var logMessage = "log: xhr( ".concat(objectToString(xhrData), " )");
                hit(source, logMessage);
              } else if (propsToMatch === "" || propsToMatch === getWildcardSymbol()) {
                shouldPrevent = true;
              } else {
                var parsedData = parseMatchProps(propsToMatch);
                if (!validateParsedData(parsedData)) {
                  console.log("Invalid parameter: ".concat(propsToMatch));
                  shouldPrevent = false;
                } else {
                  var matchData = getMatchPropsData(parsedData);
                  shouldPrevent = Object.keys(matchData).every(function (matchKey) {
                    var matchValue = matchData[matchKey];
                    return Object.prototype.hasOwnProperty.call(xhrData, matchKey) && matchValue.test(xhrData[matchKey]);
                  });
                }
              }
              return Reflect.apply(target, thisArg, args);
            };
            var sendWrapper = function sendWrapper(target, thisArg, args) {
              if (!shouldPrevent) {
                return Reflect.apply(target, thisArg, args);
              }
              if (thisArg.responseType === "blob") {
                response = new Blob();
              }
              if (thisArg.responseType === "arraybuffer") {
                response = new ArrayBuffer();
              }
              if (customResponseText) {
                var randomText = generateRandomResponse(customResponseText);
                if (randomText) {
                  responseText = randomText;
                } else {
                  console.log("Invalid range: ".concat(customResponseText));
                }
              }
              Object.defineProperties(thisArg, {
                readyState: {
                  value: 4,
                  writable: false
                },
                response: {
                  value: response,
                  writable: false
                },
                responseText: {
                  value: responseText,
                  writable: false
                },
                responseURL: {
                  value: responseUrl,
                  writable: false
                },
                responseXML: {
                  value: "",
                  writable: false
                },
                status: {
                  value: 200,
                  writable: false
                },
                statusText: {
                  value: "OK",
                  writable: false
                }
              });
              setTimeout(function () {
                var stateEvent = new Event("readystatechange");
                thisArg.dispatchEvent(stateEvent);
                var loadEvent = new Event("load");
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new Event("loadend");
                thisArg.dispatchEvent(loadEndEvent);
              }, 1);
              hit(source);
              return undefined;
            };
            var openHandler = {
              apply: openWrapper
            };
            var sendHandler = {
              apply: sendWrapper
            };
            XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
            XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function objectToString(obj) {
            return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function getWildcardSymbol() {
            return "*";
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              if (dividerInd === -1) {
                propsObj.url = prop;
              } else {
                var key = prop.slice(0, dividerInd);
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              }
            });
            return propsObj;
          }
          function validateParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function getMatchPropsData(data) {
            var matchData = {};
            Object.keys(data).forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1) + min);
          }
          function getRandomStrByLength(length) {
            var result = "";
            var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~";
            var charactersLength = characters.length;
            for (var i = 0; i < length; i += 1) {
              result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
          }
          function generateRandomResponse(customResponseText) {
            var customResponse = customResponseText;
            if (customResponse === "true") {
              customResponse = Math.random().toString(36).slice(-10);
              return customResponse;
            }
            customResponse = customResponse.replace("length:", "");
            var rangeRegex = /^\d+-\d+$/;
            if (!rangeRegex.test(customResponse)) {
              return null;
            }
            var rangeMin = getNumberFromString(customResponse.split("-")[0]);
            var rangeMax = getNumberFromString(customResponse.split("-")[1]);
            if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
              return null;
            }
            if (rangeMin > rangeMax) {
              var temp = rangeMin;
              rangeMin = rangeMax;
              rangeMax = temp;
            }
            var LENGTH_RANGE_LIMIT = 500 * 1e3;
            if (rangeMax > LENGTH_RANGE_LIMIT) {
              return null;
            }
            var length = getRandomIntInclusive(rangeMin, rangeMax);
            customResponse = getRandomStrByLength(length);
            return customResponse;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0;
          }
          function getObjectEntries(object) {
            var keys = Object.keys(object);
            var entries = [];
            keys.forEach(function (key) {
              return entries.push([key, object[key]]);
            });
            return entries;
          }
          function getNumberFromString(rawString) {
            var parsedDelay = parseInt(rawString, 10);
            var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return validDelay;
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventXHR.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeAttr(source, args) {
          function removeAttr(source, attrs, selector) {
            var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
            if (!attrs) {
              return;
            }
            attrs = attrs.split(/\s*\|\s*/);
            if (!selector) {
              selector = "[".concat(attrs.join("],["), "]");
            }
            var rmattr = function rmattr() {
              var nodes = [];
              try {
                nodes = [].slice.call(document.querySelectorAll(selector));
              } catch (e) {
                console.log("Invalid remove-attr selector arg: '".concat(selector, "'"));
              }
              var removed = false;
              nodes.forEach(function (node) {
                attrs.forEach(function (attr) {
                  node.removeAttribute(attr);
                  removed = true;
                });
              });
              if (removed) {
                hit(source);
              }
            };
            var flags = parseFlags(applying);
            var run = function run() {
              rmattr();
              if (!flags.hasFlag(flags.STAY)) {
                return;
              }
              observeDOMChanges(rmattr, true);
            };
            if (flags.hasFlag(flags.ASAP)) {
              if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", rmattr, {
                  once: true
                });
              } else {
                rmattr();
              }
            }
            if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
              window.addEventListener("load", run, {
                once: true
              });
            } else if (flags.hasFlag(flags.STAY)) {
              if (!applying.indexOf(" ") !== -1) {
                rmattr();
              }
              observeDOMChanges(rmattr, true);
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var throttle = function throttle(method, delay) {
              var wait = false;
              var savedArgs;
              var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (wait) {
                  savedArgs = args;
                  return;
                }
                method.apply(void 0, args);
                wait = true;
                setTimeout(function () {
                  wait = false;
                  if (savedArgs) {
                    wrapper(savedArgs);
                    savedArgs = null;
                  }
                }, delay);
              };
              return wrapper;
            };
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function parseFlags(flags) {
            var FLAGS_DIVIDER = " ";
            var ASAP_FLAG = "asap";
            var COMPLETE_FLAG = "complete";
            var STAY_FLAG = "stay";
            var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
            var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
              return VALID_FLAGS.indexOf(f) !== -1;
            });
            return {
              ASAP: ASAP_FLAG,
              COMPLETE: COMPLETE_FLAG,
              STAY: STAY_FLAG,
              hasFlag: function hasFlag(flag) {
                return passedFlags.indexOf(flag) !== -1;
              }
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeAttr.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeClass(source, args) {
          function removeClass(source, classNames, selector) {
            var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
            if (!classNames) {
              return;
            }
            classNames = classNames.split(/\s*\|\s*/);
            var selectors = [];
            if (!selector) {
              selectors = classNames.map(function (className) {
                return ".".concat(className);
              });
            }
            var removeClassHandler = function removeClassHandler() {
              var nodes = new Set();
              if (selector) {
                var foundNodes = [];
                try {
                  foundNodes = [].slice.call(document.querySelectorAll(selector));
                } catch (e) {
                  console.log("Invalid remove-class selector arg: '".concat(selector, "'"));
                }
                foundNodes.forEach(function (n) {
                  return nodes.add(n);
                });
              } else if (selectors.length > 0) {
                selectors.forEach(function (s) {
                  var elements = document.querySelectorAll(s);
                  for (var i = 0; i < elements.length; i += 1) {
                    var element = elements[i];
                    nodes.add(element);
                  }
                });
              }
              var removed = false;
              nodes.forEach(function (node) {
                classNames.forEach(function (className) {
                  if (node.classList.contains(className)) {
                    node.classList.remove(className);
                    removed = true;
                  }
                });
              });
              if (removed) {
                hit(source);
              }
            };
            var CLASS_ATTR_NAME = ["class"];
            var flags = parseFlags(applying);
            var run = function run() {
              removeClassHandler();
              if (!flags.hasFlag(flags.STAY)) {
                return;
              }
              observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
            };
            if (flags.hasFlag(flags.ASAP)) {
              if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", removeClassHandler, {
                  once: true
                });
              } else {
                removeClassHandler();
              }
            }
            if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
              window.addEventListener("load", run, {
                once: true
              });
            } else if (flags.hasFlag(flags.STAY)) {
              if (!applying.indexOf(" ") !== -1) {
                removeClassHandler();
              }
              observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var throttle = function throttle(method, delay) {
              var wait = false;
              var savedArgs;
              var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (wait) {
                  savedArgs = args;
                  return;
                }
                method.apply(void 0, args);
                wait = true;
                setTimeout(function () {
                  wait = false;
                  if (savedArgs) {
                    wrapper(savedArgs);
                    savedArgs = null;
                  }
                }, delay);
              };
              return wrapper;
            };
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function parseFlags(flags) {
            var FLAGS_DIVIDER = " ";
            var ASAP_FLAG = "asap";
            var COMPLETE_FLAG = "complete";
            var STAY_FLAG = "stay";
            var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
            var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
              return VALID_FLAGS.indexOf(f) !== -1;
            });
            return {
              ASAP: ASAP_FLAG,
              COMPLETE: COMPLETE_FLAG,
              STAY: STAY_FLAG,
              hasFlag: function hasFlag(flag) {
                return passedFlags.indexOf(flag) !== -1;
              }
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeClass.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeCookie(source, args) {
          function removeCookie(source, match) {
            var matchRegexp = toRegExp(match);
            var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
              var cookieSpec = "".concat(cookieName, "=");
              var domain1 = "; domain=".concat(hostName);
              var domain2 = "; domain=.".concat(hostName);
              var path = "; path=/";
              var expiration = "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
              document.cookie = cookieSpec + expiration;
              document.cookie = cookieSpec + domain1 + expiration;
              document.cookie = cookieSpec + domain2 + expiration;
              document.cookie = cookieSpec + path + expiration;
              document.cookie = cookieSpec + domain1 + path + expiration;
              document.cookie = cookieSpec + domain2 + path + expiration;
              hit(source);
            };
            var rmCookie = function rmCookie() {
              document.cookie.split(";").forEach(function (cookieStr) {
                var pos = cookieStr.indexOf("=");
                if (pos === -1) {
                  return;
                }
                var cookieName = cookieStr.slice(0, pos).trim();
                if (!matchRegexp.test(cookieName)) {
                  return;
                }
                var hostParts = document.location.hostname.split(".");
                for (var i = 0; i <= hostParts.length - 1; i += 1) {
                  var hostName = hostParts.slice(i).join(".");
                  if (hostName) {
                    removeCookieFromHost(cookieName, hostName);
                  }
                }
              });
            };
            rmCookie();
            window.addEventListener("beforeunload", rmCookie);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeCookie.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeInShadowDom(source, args) {
          function removeInShadowDom(source, selector, baseSelector) {
            if (!Element.prototype.attachShadow) {
              return;
            }
            var removeElement = function removeElement(targetElement) {
              targetElement.remove();
            };
            var removeHandler = function removeHandler() {
              var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
              while (hostElements.length !== 0) {
                var isRemoved = false;
                var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                    targets = _pierceShadowDom.targets,
                    innerHosts = _pierceShadowDom.innerHosts;
                targets.forEach(function (targetEl) {
                  removeElement(targetEl);
                  isRemoved = true;
                });
                if (isRemoved) {
                  hit(source);
                }
                hostElements = innerHosts;
              }
            };
            removeHandler();
            observeDOMChanges(removeHandler, true);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var throttle = function throttle(method, delay) {
              var wait = false;
              var savedArgs;
              var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (wait) {
                  savedArgs = args;
                  return;
                }
                method.apply(void 0, args);
                wait = true;
                setTimeout(function () {
                  wait = false;
                  if (savedArgs) {
                    wrapper(savedArgs);
                    savedArgs = null;
                  }
                }, delay);
              };
              return wrapper;
            };
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function flatten(input) {
            var stack = [];
            input.forEach(function (el) {
              return stack.push(el);
            });
            var res = [];
            while (stack.length) {
              var next = stack.pop();
              if (Array.isArray(next)) {
                next.forEach(function (el) {
                  return stack.push(el);
                });
              } else {
                res.push(next);
              }
            }
            return res.reverse();
          }
          function findHostElements(rootElement) {
            var hosts = [];
            var domElems = rootElement.querySelectorAll("*");
            domElems.forEach(function (el) {
              if (el.shadowRoot) {
                hosts.push(el);
              }
            });
            return hosts;
          }
          function pierceShadowDom(selector, hostElements) {
            var targets = [];
            var innerHostsAcc = [];
            hostElements.forEach(function (host) {
              var simpleElems = host.querySelectorAll(selector);
              targets = targets.concat([].slice.call(simpleElems));
              var shadowRootElem = host.shadowRoot;
              var shadowChildren = shadowRootElem.querySelectorAll(selector);
              targets = targets.concat([].slice.call(shadowChildren));
              innerHostsAcc.push(findHostElements(shadowRootElem));
            });
            var innerHosts = flatten(innerHostsAcc);
            return {
              targets: targets,
              innerHosts: innerHosts
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeInShadowDom.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setAttr(source, args) {
          function setAttr(source, selector, attr) {
            var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (!selector || !attr) {
              return;
            }
            if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767)) {
              return;
            }
            var setAttr = function setAttr() {
              var nodes = [].slice.call(document.querySelectorAll(selector));
              var set = false;
              nodes.forEach(function (node) {
                node.setAttribute(attr, value);
                set = true;
              });
              if (set) {
                hit(source);
              }
            };
            setAttr();
            observeDOMChanges(setAttr, true);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var throttle = function throttle(method, delay) {
              var wait = false;
              var savedArgs;
              var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (wait) {
                  savedArgs = args;
                  return;
                }
                method.apply(void 0, args);
                wait = true;
                setTimeout(function () {
                  wait = false;
                  if (savedArgs) {
                    wrapper(savedArgs);
                    savedArgs = null;
                  }
                }, delay);
              };
              return wrapper;
            };
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setAttr.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setConstant(source, args) {
          function setConstant(source, property, value, stack) {
            if (!property || !matchStackTrace(stack, new Error().stack)) {
              return;
            }
            var log = console.log.bind(console);
            var emptyArr = noopArray();
            var emptyObj = noopObject();
            var constantValue;
            if (value === "undefined") {
              constantValue = undefined;
            } else if (value === "false") {
              constantValue = false;
            } else if (value === "true") {
              constantValue = true;
            } else if (value === "null") {
              constantValue = null;
            } else if (value === "emptyArr") {
              constantValue = emptyArr;
            } else if (value === "emptyObj") {
              constantValue = emptyObj;
            } else if (value === "noopFunc") {
              constantValue = noopFunc;
            } else if (value === "trueFunc") {
              constantValue = trueFunc;
            } else if (value === "falseFunc") {
              constantValue = falseFunc;
            } else if (value === "noopPromiseResolve") {
              constantValue = noopPromiseResolve;
            } else if (value === "noopPromiseReject") {
              constantValue = noopPromiseReject;
            } else if (/^\d+$/.test(value)) {
              constantValue = parseFloat(value);
              if (nativeIsNaN(constantValue)) {
                return;
              }
              if (Math.abs(constantValue) > 32767) {
                return;
              }
            } else if (value === "-1") {
              constantValue = -1;
            } else if (value === "") {
              constantValue = "";
            } else if (value === "yes") {
              constantValue = "yes";
            } else if (value === "no") {
              constantValue = "no";
            } else {
              return;
            }
            var canceled = false;
            var mustCancel = function mustCancel(value) {
              if (canceled) {
                return canceled;
              }
              canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;
              return canceled;
            };
            var trapProp = function trapProp(base, prop, configurable, handler) {
              if (!handler.init(base[prop])) {
                return false;
              }
              var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
              var prevSetter;
              if (origDescriptor instanceof Object) {
                if (!origDescriptor.configurable) {
                  if (source.verbose) {
                    log("set-constant: property '".concat(prop, "' is not configurable"));
                  }
                  return false;
                }
                base[prop] = constantValue;
                if (origDescriptor.set instanceof Function) {
                  prevSetter = origDescriptor.set;
                }
              }
              Object.defineProperty(base, prop, {
                configurable: configurable,
                get: function get() {
                  return handler.get();
                },
                set: function set(a) {
                  if (prevSetter !== undefined) {
                    prevSetter(a);
                  }
                  handler.set(a);
                }
              });
              return true;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                  chain = chainInfo.chain;
              var undefPropHandler = {
                factValue: undefined,
                init: function init(a) {
                  this.factValue = a;
                  return true;
                },
                get: function get() {
                  return this.factValue;
                },
                set: function set(a) {
                  if (this.factValue === a) {
                    return;
                  }
                  this.factValue = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                }
              };
              var endPropHandler = {
                init: function init(a) {
                  if (mustCancel(a)) {
                    return false;
                  }
                  return true;
                },
                get: function get() {
                  return constantValue;
                },
                set: function set(a) {
                  if (!mustCancel(a)) {
                    return;
                  }
                  constantValue = a;
                }
              };
              if (!chain) {
                var isTrapped = trapProp(base, prop, false, endPropHandler);
                if (isTrapped) {
                  hit(source);
                }
                return;
              }
              var propValue = owner[prop];
              if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
                setChainPropAccess(propValue, chain);
              }
              trapProp(base, prop, true, undefPropHandler);
            };
            setChainPropAccess(window, property);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopArray() {
            return [];
          }
          function noopObject() {
            return {};
          }
          function noopFunc() {}
          function trueFunc() {
            return true;
          }
          function falseFunc() {
            return false;
          }
          function noopPromiseReject() {
            return Promise.reject();
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            return Promise.resolve(response);
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              return new RegExp(input.slice(1, -1));
            }
            var escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function getNativeRegexpTest() {
            return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setConstant.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setCookie(source, args) {
          function setCookie(source, name, value) {
            var cookieData = prepareCookie(name, value);
            if (cookieData) {
              hit(source);
              document.cookie = cookieData;
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function prepareCookie(name, value) {
            if (!name || !value) {
              return null;
            }
            var valueToSet;
            if (value === "true") {
              valueToSet = "true";
            } else if (value === "True") {
              valueToSet = "True";
            } else if (value === "false") {
              valueToSet = "false";
            } else if (value === "False") {
              valueToSet = "False";
            } else if (value === "yes") {
              valueToSet = "yes";
            } else if (value === "Yes") {
              valueToSet = "Yes";
            } else if (value === "Y") {
              valueToSet = "Y";
            } else if (value === "no") {
              valueToSet = "no";
            } else if (value === "ok") {
              valueToSet = "ok";
            } else if (value === "OK") {
              valueToSet = "OK";
            } else if (/^\d+$/.test(value)) {
              valueToSet = parseFloat(value);
              if (nativeIsNaN(valueToSet)) {
                return null;
              }
              if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {
                return null;
              }
            } else {
              return null;
            }
            var pathToSet = "path=/;";
            var cookieData = "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(valueToSet), "; ").concat(pathToSet);
            return cookieData;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setCookie.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setCookieReload(source, args) {
          function setCookieReload(source, name, value) {
            var isCookieSetWithValue = function isCookieSetWithValue(name, value) {
              return document.cookie.split(";").some(function (cookieStr) {
                var pos = cookieStr.indexOf("=");
                if (pos === -1) {
                  return false;
                }
                var cookieName = cookieStr.slice(0, pos).trim();
                var cookieValue = cookieStr.slice(pos + 1).trim();
                return name === cookieName && value === cookieValue;
              });
            };
            if (isCookieSetWithValue(name, value)) {
              return;
            }
            var cookieData = prepareCookie(name, value);
            if (cookieData) {
              document.cookie = cookieData;
              hit(source);
              if (isCookieSetWithValue(name, value)) {
                window.location.reload();
              }
            }
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function prepareCookie(name, value) {
            if (!name || !value) {
              return null;
            }
            var valueToSet;
            if (value === "true") {
              valueToSet = "true";
            } else if (value === "True") {
              valueToSet = "True";
            } else if (value === "false") {
              valueToSet = "false";
            } else if (value === "False") {
              valueToSet = "False";
            } else if (value === "yes") {
              valueToSet = "yes";
            } else if (value === "Yes") {
              valueToSet = "Yes";
            } else if (value === "Y") {
              valueToSet = "Y";
            } else if (value === "no") {
              valueToSet = "no";
            } else if (value === "ok") {
              valueToSet = "ok";
            } else if (value === "OK") {
              valueToSet = "OK";
            } else if (/^\d+$/.test(value)) {
              valueToSet = parseFloat(value);
              if (nativeIsNaN(valueToSet)) {
                return null;
              }
              if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {
                return null;
              }
            } else {
              return null;
            }
            var pathToSet = "path=/;";
            var cookieData = "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(valueToSet), "; ").concat(pathToSet);
            return cookieData;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setCookieReload.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setLocalStorageItem(source, args) {
          function setLocalStorageItem(source, key, value) {
            if (!key || !value && value !== "") {
              return;
            }
            var keyValue;
            if (value === "undefined") {
              keyValue = undefined;
            } else if (value === "false") {
              keyValue = false;
            } else if (value === "true") {
              keyValue = true;
            } else if (value === "null") {
              keyValue = null;
            } else if (value === "emptyArr") {
              keyValue = "[]";
            } else if (value === "emptyObj") {
              keyValue = "{}";
            } else if (value === "") {
              keyValue = "";
            } else if (/^\d+$/.test(value)) {
              keyValue = parseFloat(value);
              if (nativeIsNaN(keyValue)) {
                return;
              }
              if (Math.abs(keyValue) > 32767) {
                return;
              }
            } else if (value === "yes") {
              keyValue = "yes";
            } else if (value === "no") {
              keyValue = "no";
            } else {
              return;
            }
            var setItem = function setItem(key, value) {
              var _window = window,
                  localStorage = _window.localStorage;
              try {
                localStorage.setItem(key, value);
                hit(source);
              } catch (e) {
                if (source.verbose) {
                  console.log("Was unable to set localStorage item due to: ".concat(e.message));
                }
              }
            };
            setItem(key, keyValue);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setLocalStorageItem.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setPopadsDummy(source, args) {
          function setPopadsDummy(source) {
            delete window.PopAds;
            delete window.popns;
            Object.defineProperties(window, {
              PopAds: {
                get: function get() {
                  hit(source);
                  return {};
                }
              },
              popns: {
                get: function get() {
                  hit(source);
                  return {};
                }
              }
            });
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setPopadsDummy.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setSessionStorageItem(source, args) {
          function setSessionStorageItem(source, key, value) {
            if (!key || !value && value !== "") {
              return;
            }
            var keyValue;
            if (value === "undefined") {
              keyValue = undefined;
            } else if (value === "false") {
              keyValue = false;
            } else if (value === "true") {
              keyValue = true;
            } else if (value === "null") {
              keyValue = null;
            } else if (value === "emptyArr") {
              keyValue = "[]";
            } else if (value === "emptyObj") {
              keyValue = "{}";
            } else if (value === "") {
              keyValue = "";
            } else if (/^\d+$/.test(value)) {
              keyValue = parseFloat(value);
              if (nativeIsNaN(keyValue)) {
                return;
              }
              if (Math.abs(keyValue) > 32767) {
                return;
              }
            } else if (value === "yes") {
              keyValue = "yes";
            } else if (value === "no") {
              keyValue = "no";
            } else {
              return;
            }
            var setItem = function setItem(key, value) {
              var _window = window,
                  sessionStorage = _window.sessionStorage;
              try {
                sessionStorage.setItem(key, value);
                hit(source);
              } catch (e) {
                if (source.verbose) {
                  console.log("Was unable to set sessionStorage item due to: ".concat(e.message));
                }
              }
            };
            setItem(key, keyValue);
          }
          function hit(source, message) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              var LOG_MARKER = "log: ";
              if (message) {
                if (message.indexOf(LOG_MARKER) === -1) {
                  log("".concat(prefix, " message:\n").concat(message));
                } else {
                  log(message.slice(LOG_MARKER.length));
                }
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setSessionStorageItem.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        var scriptletsMap = {
          "abort-current-inline-script": abortCurrentInlineScript,
          "abort-current-script.js": abortCurrentInlineScript,
          "ubo-abort-current-script.js": abortCurrentInlineScript,
          "acs.js": abortCurrentInlineScript,
          "ubo-acs.js": abortCurrentInlineScript,
          "ubo-abort-current-script": abortCurrentInlineScript,
          "ubo-acs": abortCurrentInlineScript,
          "abort-current-inline-script.js": abortCurrentInlineScript,
          "ubo-abort-current-inline-script.js": abortCurrentInlineScript,
          "acis.js": abortCurrentInlineScript,
          "ubo-acis.js": abortCurrentInlineScript,
          "ubo-abort-current-inline-script": abortCurrentInlineScript,
          "ubo-acis": abortCurrentInlineScript,
          "abp-abort-current-inline-script": abortCurrentInlineScript,
          "abort-on-property-read": abortOnPropertyRead,
          "abort-on-property-read.js": abortOnPropertyRead,
          "ubo-abort-on-property-read.js": abortOnPropertyRead,
          "aopr.js": abortOnPropertyRead,
          "ubo-aopr.js": abortOnPropertyRead,
          "ubo-abort-on-property-read": abortOnPropertyRead,
          "ubo-aopr": abortOnPropertyRead,
          "abp-abort-on-property-read": abortOnPropertyRead,
          "abort-on-property-write": abortOnPropertyWrite,
          "abort-on-property-write.js": abortOnPropertyWrite,
          "ubo-abort-on-property-write.js": abortOnPropertyWrite,
          "aopw.js": abortOnPropertyWrite,
          "ubo-aopw.js": abortOnPropertyWrite,
          "ubo-abort-on-property-write": abortOnPropertyWrite,
          "ubo-aopw": abortOnPropertyWrite,
          "abp-abort-on-property-write": abortOnPropertyWrite,
          "abort-on-stack-trace": abortOnStackTrace,
          "abort-on-stack-trace.js": abortOnStackTrace,
          "ubo-abort-on-stack-trace.js": abortOnStackTrace,
          "aost.js": abortOnStackTrace,
          "ubo-aost.js": abortOnStackTrace,
          "ubo-abort-on-stack-trace": abortOnStackTrace,
          "ubo-aost": abortOnStackTrace,
          "abp-abort-on-stack-trace": abortOnStackTrace,
          "adjust-setInterval": adjustSetInterval,
          "nano-setInterval-booster.js": adjustSetInterval,
          "ubo-nano-setInterval-booster.js": adjustSetInterval,
          "nano-sib.js": adjustSetInterval,
          "ubo-nano-sib.js": adjustSetInterval,
          "ubo-nano-setInterval-booster": adjustSetInterval,
          "ubo-nano-sib": adjustSetInterval,
          "adjust-setTimeout": adjustSetTimeout,
          "nano-setTimeout-booster.js": adjustSetTimeout,
          "ubo-nano-setTimeout-booster.js": adjustSetTimeout,
          "nano-stb.js": adjustSetTimeout,
          "ubo-nano-stb.js": adjustSetTimeout,
          "ubo-nano-setTimeout-booster": adjustSetTimeout,
          "ubo-nano-stb": adjustSetTimeout,
          "debug-current-inline-script": debugCurrentInlineScript,
          "debug-on-property-read": debugOnPropertyRead,
          "debug-on-property-write": debugOnPropertyWrite,
          "dir-string": dirString,
          "abp-dir-string": dirString,
          "disable-newtab-links": disableNewtabLinks,
          "disable-newtab-links.js": disableNewtabLinks,
          "ubo-disable-newtab-links.js": disableNewtabLinks,
          "ubo-disable-newtab-links": disableNewtabLinks,
          "close-window": forceWindowClose,
          "window-close-if.js": forceWindowClose,
          "ubo-window-close-if.js": forceWindowClose,
          "ubo-window-close-if": forceWindowClose,
          "hide-in-shadow-dom": hideInShadowDom,
          "json-prune": jsonPrune,
          "json-prune.js": jsonPrune,
          "ubo-json-prune.js": jsonPrune,
          "ubo-json-prune": jsonPrune,
          "abp-json-prune": jsonPrune,
          log: log,
          "log-addEventListener": logAddEventListener,
          "addEventListener-logger.js": logAddEventListener,
          "ubo-addEventListener-logger.js": logAddEventListener,
          "aell.js": logAddEventListener,
          "ubo-aell.js": logAddEventListener,
          "ubo-addEventListener-logger": logAddEventListener,
          "ubo-aell": logAddEventListener,
          "log-eval": logEval,
          "log-on-stack-trace": logOnStacktrace,
          "no-topics": noTopics,
          noeval: noeval,
          "noeval.js": noeval,
          "silent-noeval.js": noeval,
          "ubo-noeval.js": noeval,
          "ubo-silent-noeval.js": noeval,
          "ubo-noeval": noeval,
          "ubo-silent-noeval": noeval,
          nowebrtc: nowebrtc,
          "nowebrtc.js": nowebrtc,
          "ubo-nowebrtc.js": nowebrtc,
          "ubo-nowebrtc": nowebrtc,
          "prevent-addEventListener": preventAddEventListener,
          "addEventListener-defuser.js": preventAddEventListener,
          "ubo-addEventListener-defuser.js": preventAddEventListener,
          "aeld.js": preventAddEventListener,
          "ubo-aeld.js": preventAddEventListener,
          "ubo-addEventListener-defuser": preventAddEventListener,
          "ubo-aeld": preventAddEventListener,
          "prevent-adfly": preventAdfly,
          "adfly-defuser.js": preventAdfly,
          "ubo-adfly-defuser.js": preventAdfly,
          "ubo-adfly-defuser": preventAdfly,
          "prevent-bab": preventBab,
          "nobab.js": preventBab,
          "ubo-nobab.js": preventBab,
          "bab-defuser.js": preventBab,
          "ubo-bab-defuser.js": preventBab,
          "ubo-nobab": preventBab,
          "ubo-bab-defuser": preventBab,
          "prevent-element-src-loading": preventElementSrcLoading,
          "prevent-eval-if": preventEvalIf,
          "noeval-if.js": preventEvalIf,
          "ubo-noeval-if.js": preventEvalIf,
          "ubo-noeval-if": preventEvalIf,
          "prevent-fab-3.2.0": preventFab,
          "nofab.js": preventFab,
          "ubo-nofab.js": preventFab,
          "fuckadblock.js-3.2.0": preventFab,
          "ubo-fuckadblock.js-3.2.0": preventFab,
          "ubo-nofab": preventFab,
          "prevent-fetch": preventFetch,
          "no-fetch-if.js": preventFetch,
          "ubo-no-fetch-if.js": preventFetch,
          "ubo-no-fetch-if": preventFetch,
          "prevent-popads-net": preventPopadsNet,
          "popads.net.js": preventPopadsNet,
          "ubo-popads.net.js": preventPopadsNet,
          "ubo-popads.net": preventPopadsNet,
          "prevent-refresh": preventRefresh,
          "refresh-defuser.js": preventRefresh,
          "refresh-defuser": preventRefresh,
          "ubo-refresh-defuser.js": preventRefresh,
          "ubo-refresh-defuser": preventRefresh,
          "prevent-requestAnimationFrame": preventRequestAnimationFrame,
          "no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
          "ubo-no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
          "norafif.js": preventRequestAnimationFrame,
          "ubo-norafif.js": preventRequestAnimationFrame,
          "ubo-no-requestAnimationFrame-if": preventRequestAnimationFrame,
          "ubo-norafif": preventRequestAnimationFrame,
          "prevent-setInterval": preventSetInterval,
          "no-setInterval-if.js": preventSetInterval,
          "ubo-no-setInterval-if.js": preventSetInterval,
          "setInterval-defuser.js": preventSetInterval,
          "ubo-setInterval-defuser.js": preventSetInterval,
          "nosiif.js": preventSetInterval,
          "ubo-nosiif.js": preventSetInterval,
          "sid.js": preventSetInterval,
          "ubo-sid.js": preventSetInterval,
          "ubo-no-setInterval-if": preventSetInterval,
          "ubo-setInterval-defuser": preventSetInterval,
          "ubo-nosiif": preventSetInterval,
          "ubo-sid": preventSetInterval,
          "prevent-setTimeout": preventSetTimeout,
          "no-setTimeout-if.js": preventSetTimeout,
          "ubo-no-setTimeout-if.js": preventSetTimeout,
          "nostif.js": preventSetTimeout,
          "ubo-nostif.js": preventSetTimeout,
          "ubo-no-setTimeout-if": preventSetTimeout,
          "ubo-nostif": preventSetTimeout,
          "setTimeout-defuser.js": preventSetTimeout,
          "ubo-setTimeout-defuser.js": preventSetTimeout,
          "ubo-setTimeout-defuser": preventSetTimeout,
          "std.js": preventSetTimeout,
          "ubo-std.js": preventSetTimeout,
          "ubo-std": preventSetTimeout,
          "prevent-window-open": preventWindowOpen,
          "window.open-defuser.js": preventWindowOpen,
          "ubo-window.open-defuser.js": preventWindowOpen,
          "ubo-window.open-defuser": preventWindowOpen,
          "nowoif.js": preventWindowOpen,
          "ubo-nowoif.js": preventWindowOpen,
          "ubo-nowoif": preventWindowOpen,
          "prevent-xhr": preventXHR,
          "no-xhr-if.js": preventXHR,
          "ubo-no-xhr-if.js": preventXHR,
          "ubo-no-xhr-if": preventXHR,
          "remove-attr": removeAttr,
          "remove-attr.js": removeAttr,
          "ubo-remove-attr.js": removeAttr,
          "ra.js": removeAttr,
          "ubo-ra.js": removeAttr,
          "ubo-remove-attr": removeAttr,
          "ubo-ra": removeAttr,
          "remove-class": removeClass,
          "remove-class.js": removeClass,
          "ubo-remove-class.js": removeClass,
          "rc.js": removeClass,
          "ubo-rc.js": removeClass,
          "ubo-remove-class": removeClass,
          "ubo-rc": removeClass,
          "remove-cookie": removeCookie,
          "cookie-remover.js": removeCookie,
          "ubo-cookie-remover.js": removeCookie,
          "ubo-cookie-remover": removeCookie,
          "remove-in-shadow-dom": removeInShadowDom,
          "set-attr": setAttr,
          "set-constant": setConstant,
          "set-constant.js": setConstant,
          "ubo-set-constant.js": setConstant,
          "set.js": setConstant,
          "ubo-set.js": setConstant,
          "ubo-set-constant": setConstant,
          "ubo-set": setConstant,
          "abp-override-property-read": setConstant,
          "set-cookie": setCookie,
          "set-cookie-reload": setCookieReload,
          "set-local-storage-item": setLocalStorageItem,
          "set-popads-dummy": setPopadsDummy,
          "popads-dummy.js": setPopadsDummy,
          "ubo-popads-dummy.js": setPopadsDummy,
          "ubo-popads-dummy": setPopadsDummy,
          "set-session-storage-item": setSessionStorageItem
        };
        var getScriptletFunction = function getScriptletFunction(name) {
          return scriptletsMap[name];
        };
        function getScriptletCode(source) {
          if (!validator.isValidScriptletName(source.name)) {
            return null;
          }
          var scriptletFunction = getScriptletFunction(source.name).toString();
          var result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(scriptletFunction) : passSourceAndProps(source, scriptletFunction);
          return result;
        }
        var scriptletsObject = function () {
          return {
            invoke: getScriptletCode,
            getScriptletFunction: getScriptletFunction,
            isValidScriptletName: validator.isValidScriptletName,
            isValidScriptletRule: isValidScriptletRule,
            isAdgScriptletRule: validator.isAdgScriptletRule,
            isUboScriptletRule: validator.isUboScriptletRule,
            isAbpSnippetRule: validator.isAbpSnippetRule,
            convertUboToAdg: convertUboScriptletToAdg,
            convertAbpToAdg: convertAbpSnippetToAdg,
            convertScriptletToAdg: convertScriptletToAdg,
            convertAdgToUbo: convertAdgScriptletToUbo,
            redirects: redirects
          };
        }();
        scriptlets_umd.exports = scriptletsObject;
    }));

    var NETWORK_RULE_OPTIONS = {
        THIRD_PARTY: 'third-party',
        FIRST_PARTY: 'first-party',
        MATCH_CASE: 'match-case',
        IMPORTANT: 'important',
        DOMAIN: 'domain',
        DENYALLOW: 'denyallow',
        ELEMHIDE: 'elemhide',
        GENERICHIDE: 'generichide',
        SPECIFICHIDE: 'specifichide',
        GENERICBLOCK: 'genericblock',
        JSINJECT: 'jsinject',
        URLBLOCK: 'urlblock',
        CONTENT: 'content',
        DOCUMENT: 'document',
        DOC: 'doc',
        STEALTH: 'stealth',
        POPUP: 'popup',
        EMPTY: 'empty',
        MP4: 'mp4',
        SCRIPT: 'script',
        STYLESHEET: 'stylesheet',
        SUBDOCUMENT: 'subdocument',
        OBJECT: 'object',
        IMAGE: 'image',
        XMLHTTPREQUEST: 'xmlhttprequest',
        MEDIA: 'media',
        FONT: 'font',
        WEBSOCKET: 'websocket',
        OTHER: 'other',
        PING: 'ping',
        WEBRTC: 'webrtc',
        BADFILTER: 'badfilter',
        CSP: 'csp',
        REPLACE: 'replace',
        COOKIE: 'cookie',
        REDIRECT: 'redirect',
        REDIRECTRULE: 'redirect-rule',
        REMOVEPARAM: 'removeparam',
        REMOVEHEADER: 'removeheader',
        APP: 'app',
        NETWORK: 'network',
        EXTENSION: 'extension',
        NOOP: '_',
        CLIENT: 'client',
        DNSREWRITE: 'dnsrewrite',
        DNSTYPE: 'dnstype',
        CTAG: 'ctag',
    };
    var OPTIONS_DELIMITER = '$';
    var MASK_ALLOWLIST = '@@';
    var NOT_MARK = '~';
    var ESCAPE_CHARACTER = '\\';

    /**
     * Redirect modifier class
     */
    var RedirectModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param ruleText
         * @param isAllowlist
         * @param isRedirectingOnlyBlocked is redirect-rule modifier
         */
        function RedirectModifier(value, ruleText, isAllowlist, isRedirectingOnlyBlocked) {
            if (isRedirectingOnlyBlocked === void 0) { isRedirectingOnlyBlocked = false; }
            /**
             * Is redirecting only blocked requests
             * See $redirect-rule options
             */
            this.isRedirectingOnlyBlocked = false;
            RedirectModifier.validate(ruleText, value, isAllowlist);
            this.redirectTitle = value;
            this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
        }
        /**
         * Redirect title
         */
        RedirectModifier.prototype.getValue = function () {
            return this.redirectTitle;
        };
        /**
         * Validates redirect rule
         *
         * @param ruleText
         * @param redirectTitle
         * @param isAllowlist
         */
        RedirectModifier.validate = function (ruleText, redirectTitle, isAllowlist) {
            if (isAllowlist && !redirectTitle) {
                return;
            }
            if (!redirectTitle) {
                throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
            }
            var redirects = scriptlets_umd.exports.redirects;
            var ruleTextToValidate = ruleText.replace(NETWORK_RULE_OPTIONS.REDIRECTRULE, NETWORK_RULE_OPTIONS.REDIRECT);
            if (!redirects.isAdgRedirectRule(ruleTextToValidate) || !redirects.isValidAdgRedirectRule(ruleTextToValidate)) {
                throw new SyntaxError('$redirect modifier is invalid');
            }
        };
        return RedirectModifier;
    }());

    /**
     * Splits url into parts
     *
     * @param url
     */
    function splitUrl(url) {
        var strippedUrl = url;
        var hash = '';
        var hashIndex = url.indexOf('#');
        if (hashIndex >= 0) {
            hash = url.slice(hashIndex);
            strippedUrl = url.slice(0, hashIndex);
        }
        var query = '';
        var queryIndex = url.indexOf('?');
        if (queryIndex >= 0) {
            query = strippedUrl.slice(queryIndex + 1);
            strippedUrl = strippedUrl.slice(0, queryIndex);
        }
        return {
            path: strippedUrl,
            query: query,
            hash: hash,
        };
    }
    /**
     * Normalizes url query parameters
     *
     * @param query
     */
    function normalizeQuery(query) {
        // Cleanup empty params (p0=0&=2&=3)
        var result = query
            .split('&')
            .filter(function (x) { return x && !x.startsWith('='); })
            .join('&');
        // If we've collapsed the URL to the point where there's an '&' against the '?'
        // then we need to get rid of that.
        while (result.charAt(0) === '&') {
            result = result.substr(1);
        }
        return result;
    }
    /**
     * Removes query params from url by regexp
     *
     * @param url
     * @param regExp
     * @param invert remove every parameter in url except the ones matched regexp
     */
    function cleanUrlParamByRegExp(url, regExp, invert) {
        if (invert === void 0) { invert = false; }
        var searchIndex = url.indexOf('?');
        // If no params, nothing to modify
        if (searchIndex === -1) {
            return url;
        }
        var split = splitUrl(url);
        var modifiedQuery;
        if (invert) {
            modifiedQuery = split.query
                .split('&')
                .filter(function (x) { return x; })
                .filter(function (x) { return x && x.match(regExp); })
                .join('&');
        }
        else {
            modifiedQuery = split.query
                .split('&')
                .filter(function (x) {
                var test = x.includes('=') ? x : "".concat(x, "=");
                return !test.match(regExp);
            })
                .join('&');
        }
        // Do not normalize if regexp is not applied
        if (modifiedQuery === split.query) {
            return url;
        }
        modifiedQuery = normalizeQuery(modifiedQuery);
        var result = split.path;
        if (modifiedQuery) {
            result += "?".concat(modifiedQuery);
        }
        return result + split.hash;
    }
    var DOMAIN_REGEX = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
    /**
     * Check if the string could be a domain name
     *
     * @param text
     */
    var isDomainName = function (text) {
        if (text.indexOf('.') < 0 || text.endsWith('.')) {
            return false;
        }
        return DOMAIN_REGEX.test(text);
    };
    /**
     * Extract relative part from hierarchical structured URL
     * @param url
     */
    var getRelativeUrl = function (url) {
        var i = url.indexOf('/', url.indexOf('://') + 3);
        return i !== -1 ? url.substr(i) : null;
    };

    /**
     * Query parameters filtering modifier class
     * Works with '$removeparam' modifier
     */
    var RemoveParamModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function RemoveParamModifier(value) {
            /**
             * Is modifier valid for MV3 or not
             */
            this.mv3Valid = true;
            this.value = value;
            var rawValue = value;
            // TODO: Seems like negation not using in valueRegExp
            if (value.startsWith('~')) {
                rawValue = value.substring(1);
                this.mv3Valid = false;
            }
            if (rawValue.startsWith('/')) {
                this.valueRegExp = SimpleRegex.patternFromString(rawValue);
                this.mv3Valid = false;
            }
            else {
                if (rawValue.includes('|')) {
                    throw new Error('Unsupported option in $removeparam: multiple values are not allowed');
                }
                this.valueRegExp = new RegExp("((^|&)(".concat(SimpleRegex.escapeRegexSpecials(rawValue), ")=[^&#]*)"), 'g');
            }
        }
        /**
         * Modifier value
         */
        RemoveParamModifier.prototype.getValue = function () {
            return this.value;
        };
        /**
         * Is modifier valid for MV3 or not
         */
        RemoveParamModifier.prototype.getMV3Validity = function () {
            return this.mv3Valid;
        };
        /**
         * Removes query parameters from url
         *
         * @param url
         */
        RemoveParamModifier.prototype.removeParameters = function (url) {
            var sepIndex = url.indexOf('?');
            if (sepIndex < 0) {
                return url;
            }
            if (!this.value) {
                return url.substring(0, sepIndex);
            }
            if (sepIndex === url.length - 1) {
                return url;
            }
            if (this.value.startsWith('~')) {
                return cleanUrlParamByRegExp(url, this.valueRegExp, true);
            }
            return cleanUrlParamByRegExp(url, this.valueRegExp);
        };
        return RemoveParamModifier;
    }());

    /**
     * Headers filtering modifier class.
     * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
     */
    var RemoveHeaderModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param isAllowlist
         */
        function RemoveHeaderModifier(value, isAllowlist) {
            this.value = value.toLowerCase();
            if (!isAllowlist && !this.value) {
                throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
            }
            this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
            var headerName = this.isRequestModifier
                ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length) : this.value;
            this.applicableHeaderName = RemoveHeaderModifier.isAllowedHeader(headerName) ? headerName : null;
        }
        /**
         * Modifier value
         */
        RemoveHeaderModifier.prototype.getValue = function () {
            return this.value;
        };
        /**
         * Returns effective header name to be removed
         *
         * @param isRequestHeaders
         */
        RemoveHeaderModifier.prototype.getApplicableHeaderName = function (isRequestHeaders) {
            if (!this.applicableHeaderName) {
                return null;
            }
            if (isRequestHeaders !== this.isRequestModifier) {
                return null;
            }
            return this.applicableHeaderName;
        };
        /**
         * Some headers are forbidden to remove
         *
         * @param headerName
         */
        RemoveHeaderModifier.isAllowedHeader = function (headerName) {
            return !this.FORBIDDEN_HEADERS.includes(headerName);
        };
        /**
         * List of forbidden headers
         */
        RemoveHeaderModifier.FORBIDDEN_HEADERS = [
            'access-control-allow-origin',
            'access-control-allow-credentials',
            'access-control-allow-headers',
            'access-control-allow-methods',
            'access-control-expose-headers',
            'access-control-max-age',
            'access-control-request-headers',
            'access-control-request-method',
            'origin',
            'timing-allow-origin',
            'allow',
            'cross-origin-embedder-policy',
            'cross-origin-opener-policy',
            'cross-origin-resource-policy',
            'content-security-policy',
            'content-security-policy-report-only',
            'expect-ct',
            'feature-policy',
            'origin-isolation',
            'strict-transport-security',
            'upgrade-insecure-requests',
            'x-content-type-options',
            'x-download-options',
            'x-frame-options',
            'x-permitted-cross-domain-policies',
            'x-powered-by',
            'x-xss-protection',
            'public-key-pins',
            'public-key-pins-report-only',
            'sec-websocket-key',
            'sec-websocket-extensions',
            'sec-websocket-accept',
            'sec-websocket-protocol',
            'sec-websocket-version',
            'p3p',
            'sec-fetch-mode',
            'sec-fetch-dest',
            'sec-fetch-site',
            'sec-fetch-user',
            'referrer-policy',
            'content-type',
            'content-length',
            'accept',
            'accept-encoding',
            'host',
            'connection',
            'transfer-encoding',
            'upgrade',
        ];
        /**
         * Request prefix
         */
        RemoveHeaderModifier.REQUEST_PREFIX = 'request:';
        return RemoveHeaderModifier;
    }());

    /**
     * This is a helper class that is used specifically to work with app restrictions.
     *
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     *
     * Examples:
     * ||baddomain.com^$app=org.example.app
     * ||baddomain.com^$app=org.example.app1|org.example.app2
     */
    var AppModifier = /** @class */ (function () {
        /**
         * Parses the `apps` string
         *
         * @param apps - apps string
         *
         * @throws an error if the app string is empty or invalid
         */
        function AppModifier(apps) {
            /**
             * Separator between apps
             */
            this.APPS_SEPARATOR = '|';
            if (!apps) {
                throw new SyntaxError('$app modifier cannot be empty');
            }
            var permittedApps = [];
            var restrictedApps = [];
            var parts = apps.split(this.APPS_SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var app = parts[i];
                var restricted = false;
                if (app.startsWith('~')) {
                    restricted = true;
                    app = app.substring(1).trim();
                }
                if (app === '') {
                    throw new SyntaxError("Empty app specified in \"".concat(apps, "\""));
                }
                if (restricted) {
                    restrictedApps.push(app);
                }
                else {
                    permittedApps.push(app);
                }
            }
            this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
            this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
        }
        return AppModifier;
    }());

    /**
     * RequestType is the request types enumeration
     */
    exports.RequestType = void 0;
    (function (RequestType) {
        /** main frame */
        RequestType[RequestType["Document"] = 1] = "Document";
        /** (iframe) $subdocument */
        RequestType[RequestType["SubDocument"] = 2] = "SubDocument";
        /** (javascript, etc) $script */
        RequestType[RequestType["Script"] = 4] = "Script";
        /** (css) $stylesheet */
        RequestType[RequestType["Stylesheet"] = 8] = "Stylesheet";
        /** (flash, etc) $object */
        RequestType[RequestType["Object"] = 16] = "Object";
        /** (any image) $image */
        RequestType[RequestType["Image"] = 32] = "Image";
        /** (ajax/fetch) $xmlhttprequest */
        RequestType[RequestType["XmlHttpRequest"] = 64] = "XmlHttpRequest";
        /** (video/music) $media */
        RequestType[RequestType["Media"] = 128] = "Media";
        /** (any custom font) $font */
        RequestType[RequestType["Font"] = 256] = "Font";
        /** (a websocket connection) $websocket */
        RequestType[RequestType["WebSocket"] = 512] = "WebSocket";
        /** (navigator.sendBeacon()) $ping */
        RequestType[RequestType["Ping"] = 1024] = "Ping";
        /** (webrtc, in extension works via wrappers) $webrtc */
        RequestType[RequestType["WebRtc"] = 2048] = "WebRtc";
        /** any other request type */
        RequestType[RequestType["Other"] = 4096] = "Other";
    })(exports.RequestType || (exports.RequestType = {}));

    var isCidr = {exports: {}};

    var cidrRegex = {exports: {}};

    const word = '[a-fA-F\\d:]';
    const b = options => options && options.includeBoundaries ?
    	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
    	'';
    const v4$1 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
    const v6seg = '[a-fA-F\\d]{1,4}';
    const v6$1 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4$1}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4$1}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4$1}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4$1}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4$1}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4$1}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4$1}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
    const v46Exact = new RegExp(`(?:^${v4$1}$)|(?:^${v6$1}$)`);
    const v4exact$1 = new RegExp(`^${v4$1}$`);
    const v6exact$1 = new RegExp(`^${v6$1}$`);
    const ip = options => options && options.exact ?
    	v46Exact :
    	new RegExp(`(?:${b(options)}${v4$1}${b(options)})|(?:${b(options)}${v6$1}${b(options)})`, 'g');
    ip.v4 = options => options && options.exact ? v4exact$1 : new RegExp(`${b(options)}${v4$1}${b(options)}`, 'g');
    ip.v6 = options => options && options.exact ? v6exact$1 : new RegExp(`${b(options)}${v6$1}${b(options)}`, 'g');
    var ipRegex$2 = ip;

    const ipRegex$1 = ipRegex$2;
    const defaultOpts = {exact: false};
    const v4str = `${ipRegex$1.v4().source}\\/(3[0-2]|[12]?[0-9])`;
    const v6str = `${ipRegex$1.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;
    const v4exact = new RegExp(`^${v4str}$`);
    const v6exact = new RegExp(`^${v6str}$`);
    const v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);
    cidrRegex.exports = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g");
    cidrRegex.exports.v4 = ({exact} = defaultOpts) => exact ? v4exact : new RegExp(v4str, "g");
    cidrRegex.exports.v6 = ({exact} = defaultOpts) => exact ? v6exact : new RegExp(v6str, "g");

    const {v4, v6} = cidrRegex.exports;
    const re4 = v4({exact: true});
    const re6 = v6({exact: true});
    isCidr.exports = str => re4.test(str) ? 4 : (re6.test(str) ? 6 : 0);
    isCidr.exports.v4 = str => re4.test(str);
    isCidr.exports.v6 = str => re6.test(str);

    const ipRegex = ipRegex$2;
    const isIp = string => ipRegex({exact: true}).test(string);
    isIp.v4 = string => ipRegex.v4({exact: true}).test(string);
    isIp.v6 = string => ipRegex.v6({exact: true}).test(string);
    isIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;
    var isIp_1 = isIp;

    var Netmask_1;
    (function() {
      var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & (0xff << 24)) >>> 24;
        b = (long & (0xff << 16)) >>> 16;
        c = (long & (0xff << 8)) >>> 8;
        d = long & 0xff;
        return [a, b, c, d].join('.');
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== '.') {
              throw new Error('Invalid IP');
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error('Invalid IP');
        }
        switch (b.length) {
          case 1:
            if (b[0] > 0xFFFFFFFF) {
              throw new Error('Invalid IP');
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 0xFF || b[1] > 0xFFFFFF) {
              throw new Error('Invalid IP');
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {
              throw new Error('Invalid IP');
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {
              throw new Error('Invalid IP');
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error('Invalid IP');
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr('0');
      chra = chr('a');
      chrA = chr('A');
      atob = function(s) {
        var base, dmax, i, n, start;
        n = 0;
        base = 10;
        dmax = '9';
        i = 0;
        if (s.length > 1 && s[i] === '0') {
          if (s[i + 1] === 'x' || s[i + 1] === 'X') {
            i += 2;
            base = 16;
          } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {
            i++;
            base = 8;
            dmax = '7';
          }
        }
        start = i;
        while (i < s.length) {
          if ('0' <= s[i] && s[i] <= dmax) {
            n = (n * base + (chr(s[i]) - chr0)) >>> 0;
          } else if (base === 16) {
            if ('a' <= s[i] && s[i] <= 'f') {
              n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;
            } else if ('A' <= s[i] && s[i] <= 'F') {
              n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 0xFFFFFFFF) {
            throw new Error('too large');
          }
          i++;
        }
        if (i === start) {
          throw new Error('empty octet');
        }
        return [n, i];
      };
      Netmask = (function() {
        function Netmask(net, mask) {
          var i, j, ref;
          if (typeof net !== 'string') {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split('/', 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === 'string' && mask.indexOf('.') > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask.prototype.contains = function(ip) {
          if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {
            ip = new Netmask(ip);
          }
          if (ip instanceof Netmask) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);
        };
        Netmask.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask;
      })();
      Netmask_1 = Netmask;
    }).call(commonjsGlobal);

    var global$2 = (typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    var lookup$1 = [];
    var revLookup$1 = [];
    var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited$1 = false;
    function init$1 () {
      inited$1 = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup$1[i] = code[i];
        revLookup$1[code.charCodeAt(i)] = i;
      }
      revLookup$1['-'.charCodeAt(0)] = 62;
      revLookup$1['_'.charCodeAt(0)] = 63;
    }
    function toByteArray$1 (b64) {
      if (!inited$1) {
        init$1();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
      arr = new Arr$1(len * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? len - 4 : len;
      var L = 0;
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }
      if (placeHolders === 2) {
        tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }
      return arr
    }
    function tripletToBase64$1 (num) {
      return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
    }
    function encodeChunk$1 (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64$1(tmp));
      }
      return output.join('')
    }
    function fromByteArray$1 (uint8) {
      if (!inited$1) {
        init$1();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3;
      var output = '';
      var parts = [];
      var maxChunkLength = 16383;
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup$1[tmp >> 2];
        output += lookup$1[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup$1[tmp >> 10];
        output += lookup$1[(tmp >> 4) & 0x3F];
        output += lookup$1[(tmp << 2) & 0x3F];
        output += '=';
      }
      parts.push(output);
      return parts.join('')
    }

    function read$1 (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    function write$1 (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
      buffer[offset + i - d] |= s * 128;
    }

    var toString$1 = {}.toString;
    var isArray$3 = Array.isArray || function (arr) {
      return toString$1.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES$1 = 50;
    Buffer$1.TYPED_ARRAY_SUPPORT = global$2.TYPED_ARRAY_SUPPORT !== undefined
      ? global$2.TYPED_ARRAY_SUPPORT
      : true;
    kMaxLength$1();
    function kMaxLength$1 () {
      return Buffer$1.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }
    function createBuffer$1 (that, length) {
      if (kMaxLength$1() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        that = new Uint8Array(length);
        that.__proto__ = Buffer$1.prototype;
      } else {
        if (that === null) {
          that = new Buffer$1(length);
        }
        that.length = length;
      }
      return that
    }
    function Buffer$1 (arg, encodingOrOffset, length) {
      if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
        return new Buffer$1(arg, encodingOrOffset, length)
      }
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe$1(this, arg)
      }
      return from$1(this, arg, encodingOrOffset, length)
    }
    Buffer$1.poolSize = 8192;
    Buffer$1._augment = function (arr) {
      arr.__proto__ = Buffer$1.prototype;
      return arr
    };
    function from$1 (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }
      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer$1(that, value, encodingOrOffset, length)
      }
      if (typeof value === 'string') {
        return fromString$1(that, value, encodingOrOffset)
      }
      return fromObject$1(that, value)
    }
    Buffer$1.from = function (value, encodingOrOffset, length) {
      return from$1(null, value, encodingOrOffset, length)
    };
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      Buffer$1.prototype.__proto__ = Uint8Array.prototype;
      Buffer$1.__proto__ = Uint8Array;
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer$1[Symbol.species] === Buffer$1) ;
    }
    function assertSize$1 (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }
    function alloc$1 (that, size, fill, encoding) {
      assertSize$1(size);
      if (size <= 0) {
        return createBuffer$1(that, size)
      }
      if (fill !== undefined) {
        return typeof encoding === 'string'
          ? createBuffer$1(that, size).fill(fill, encoding)
          : createBuffer$1(that, size).fill(fill)
      }
      return createBuffer$1(that, size)
    }
    Buffer$1.alloc = function (size, fill, encoding) {
      return alloc$1(null, size, fill, encoding)
    };
    function allocUnsafe$1 (that, size) {
      assertSize$1(size);
      that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }
    Buffer$1.allocUnsafe = function (size) {
      return allocUnsafe$1(null, size)
    };
    Buffer$1.allocUnsafeSlow = function (size) {
      return allocUnsafe$1(null, size)
    };
    function fromString$1 (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }
      if (!Buffer$1.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }
      var length = byteLength$1(string, encoding) | 0;
      that = createBuffer$1(that, length);
      var actual = that.write(string, encoding);
      if (actual !== length) {
        that = that.slice(0, actual);
      }
      return that
    }
    function fromArrayLike$1 (that, array) {
      var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
      that = createBuffer$1(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }
    function fromArrayBuffer$1 (that, array, byteOffset, length) {
      array.byteLength;
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }
      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        that = array;
        that.__proto__ = Buffer$1.prototype;
      } else {
        that = fromArrayLike$1(that, array);
      }
      return that
    }
    function fromObject$1 (that, obj) {
      if (internalIsBuffer$1(obj)) {
        var len = checked$1(obj.length) | 0;
        that = createBuffer$1(that, len);
        if (that.length === 0) {
          return that
        }
        obj.copy(that, 0, 0, len);
        return that
      }
      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
            return createBuffer$1(that, 0)
          }
          return fromArrayLike$1(that, obj)
        }
        if (obj.type === 'Buffer' && isArray$3(obj.data)) {
          return fromArrayLike$1(that, obj.data)
        }
      }
      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }
    function checked$1 (length) {
      if (length >= kMaxLength$1()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength$1().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer$1.isBuffer = isBuffer$2;
    function internalIsBuffer$1 (b) {
      return !!(b != null && b._isBuffer)
    }
    Buffer$1.compare = function compare (a, b) {
      if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
        throw new TypeError('Arguments must be Buffers')
      }
      if (a === b) return 0
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }
      if (x < y) return -1
      if (y < x) return 1
      return 0
    };
    Buffer$1.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };
    Buffer$1.concat = function concat (list, length) {
      if (!isArray$3(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      if (list.length === 0) {
        return Buffer$1.alloc(0)
      }
      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer$1.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer$1(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };
    function byteLength$1 (string, encoding) {
      if (internalIsBuffer$1(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }
      var len = string.length;
      if (len === 0) return 0
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes$1(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes$1(string).length
          default:
            if (loweredCase) return utf8ToBytes$1(string).length
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$1.byteLength = byteLength$1;
    function slowToString$1 (encoding, start, end) {
      var loweredCase = false;
      if (start === undefined || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return ''
      }
      if (end === undefined || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return ''
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return ''
      }
      if (!encoding) encoding = 'utf8';
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice$1(this, start, end)
          case 'utf8':
          case 'utf-8':
            return utf8Slice$1(this, start, end)
          case 'ascii':
            return asciiSlice$1(this, start, end)
          case 'latin1':
          case 'binary':
            return latin1Slice$1(this, start, end)
          case 'base64':
            return base64Slice$1(this, start, end)
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice$1(this, start, end)
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$1.prototype._isBuffer = true;
    function swap$1 (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer$1.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap$1(this, i, i + 1);
      }
      return this
    };
    Buffer$1.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap$1(this, i, i + 3);
        swap$1(this, i + 1, i + 2);
      }
      return this
    };
    Buffer$1.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap$1(this, i, i + 7);
        swap$1(this, i + 1, i + 6);
        swap$1(this, i + 2, i + 5);
        swap$1(this, i + 3, i + 4);
      }
      return this
    };
    Buffer$1.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice$1(this, 0, length)
      return slowToString$1.apply(this, arguments)
    };
    Buffer$1.prototype.equals = function equals (b) {
      if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer$1.compare(this, b) === 0
    };
    Buffer$1.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES$1;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };
    Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer$1(target)) {
        throw new TypeError('Argument must be a Buffer')
      }
      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }
      if (x < y) return -1
      if (y < x) return 1
      return 0
    };
    function bidirectionalIndexOf$1 (buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;
      if (isNaN(byteOffset)) {
        byteOffset = dir ? 0 : (buffer.length - 1);
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }
      if (typeof val === 'string') {
        val = Buffer$1.from(val, encoding);
      }
      if (internalIsBuffer$1(val)) {
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF;
        if (Buffer$1.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf$1(buffer, [ val ], byteOffset, encoding, dir)
      }
      throw new TypeError('val must be string, number or Buffer')
    }
    function arrayIndexOf$1 (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }
      return -1
    }
    Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };
    Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true)
    };
    Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false)
    };
    function hexWrite$1 (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }
    function utf8Write$1 (buf, string, offset, length) {
      return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
    }
    function asciiWrite$1 (buf, string, offset, length) {
      return blitBuffer$1(asciiToBytes$1(string), buf, offset, length)
    }
    function latin1Write$1 (buf, string, offset, length) {
      return asciiWrite$1(buf, string, offset, length)
    }
    function base64Write$1 (buf, string, offset, length) {
      return blitBuffer$1(base64ToBytes$1(string), buf, offset, length)
    }
    function ucs2Write$1 (buf, string, offset, length) {
      return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length)
    }
    Buffer$1.prototype.write = function write (string, offset, length, encoding) {
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
      if (!encoding) encoding = 'utf8';
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite$1(this, string, offset, length)
          case 'utf8':
          case 'utf-8':
            return utf8Write$1(this, string, offset, length)
          case 'ascii':
            return asciiWrite$1(this, string, offset, length)
          case 'latin1':
          case 'binary':
            return latin1Write$1(this, string, offset, length)
          case 'base64':
            return base64Write$1(this, string, offset, length)
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write$1(this, string, offset, length)
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer$1.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };
    function base64Slice$1 (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray$1(buf)
      } else {
        return fromByteArray$1(buf.slice(start, end))
      }
    }
    function utf8Slice$1 (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray$1(res)
    }
    var MAX_ARGUMENTS_LENGTH$1 = 0x1000;
    function decodeCodePointsArray$1 (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH$1) {
        return String.fromCharCode.apply(String, codePoints)
      }
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1)
        );
      }
      return res
    }
    function asciiSlice$1 (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }
    function latin1Slice$1 (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }
    function hexSlice$1 (buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex$1(buf[i]);
      }
      return out
    }
    function utf16leSlice$1 (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }
    Buffer$1.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf;
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer$1.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer$1(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf
    };
    function checkOffset$1 (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset$1(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      return val
    };
    Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset$1(offset, byteLength, this.length);
      }
      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }
      return val
    };
    Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 1, this.length);
      return this[offset]
    };
    Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };
    Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };
    Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };
    Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };
    Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset$1(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val
    };
    Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset$1(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val
    };
    Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };
    Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };
    Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };
    Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };
    Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };
    Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return read$1(this, offset, true, 23, 4)
    };
    Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 4, this.length);
      return read$1(this, offset, false, 23, 4)
    };
    Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 8, this.length);
      return read$1(this, offset, true, 52, 8)
    };
    Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset$1(offset, 8, this.length);
      return read$1(this, offset, false, 52, 8)
    };
    function checkInt$1 (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt$1(this, value, offset, byteLength, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }
      return offset + byteLength
    };
    Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt$1(this, value, offset, byteLength, maxBytes, 0);
      }
      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }
      return offset + byteLength
    };
    Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };
    function objectWriteUInt16$1 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }
    Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16$1(this, value, offset, true);
      }
      return offset + 2
    };
    Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16$1(this, value, offset, false);
      }
      return offset + 2
    };
    function objectWriteUInt32$1 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }
    Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32$1(this, value, offset, true);
      }
      return offset + 4
    };
    Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32$1(this, value, offset, false);
      }
      return offset + 4
    };
    Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }
      return offset + byteLength
    };
    Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
      }
      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }
      return offset + byteLength
    };
    Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };
    Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16$1(this, value, offset, true);
      }
      return offset + 2
    };
    Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16$1(this, value, offset, false);
      }
      return offset + 2
    };
    Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32$1(this, value, offset, true);
      }
      return offset + 4
    };
    Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32$1(this, value, offset, false);
      }
      return offset + 4
    };
    function checkIEEE754$1 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    function writeFloat$1 (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754$1(buf, value, offset, 4);
      }
      write$1(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }
    Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat$1(this, value, offset, true, noAssert)
    };
    Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat$1(this, value, offset, false, noAssert)
    };
    function writeDouble$1 (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754$1(buf, value, offset, 8);
      }
      write$1(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }
    Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble$1(this, value, offset, true, noAssert)
    };
    Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble$1(this, value, offset, false, noAssert)
    };
    Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len
    };
    Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
      if (end <= start) {
        return this
      }
      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer$1(val)
          ? val
          : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this
    };
    var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;
    function base64clean$1 (str) {
      str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, '');
      if (str.length < 2) return ''
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }
    function stringtrim$1 (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }
    function toHex$1 (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }
    function utf8ToBytes$1 (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          if (!leadSurrogate) {
            if (codePoint > 0xDBFF) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }
            leadSurrogate = codePoint;
            continue
          }
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }
      return bytes
    }
    function asciiToBytes$1 (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }
    function utf16leToBytes$1 (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray
    }
    function base64ToBytes$1 (str) {
      return toByteArray$1(base64clean$1(str))
    }
    function blitBuffer$1 (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }
    function isnan$1 (val) {
      return val !== val
    }
    function isBuffer$2(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj))
    }
    function isFastBuffer$1 (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }
    function isSlowBuffer$1 (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0))
    }

    function defaultSetTimout$1() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout$1 () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout$1 = defaultSetTimout$1;
    var cachedClearTimeout$1 = defaultClearTimeout$1;
    if (typeof global$2.setTimeout === 'function') {
        cachedSetTimeout$1 = setTimeout;
    }
    if (typeof global$2.clearTimeout === 'function') {
        cachedClearTimeout$1 = clearTimeout;
    }
    function runTimeout$1(fun) {
        if (cachedSetTimeout$1 === setTimeout) {
            return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
            cachedSetTimeout$1 = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            return cachedSetTimeout$1(fun, 0);
        } catch(e){
            try {
                return cachedSetTimeout$1.call(null, fun, 0);
            } catch(e){
                return cachedSetTimeout$1.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout$1(marker) {
        if (cachedClearTimeout$1 === clearTimeout) {
            return clearTimeout(marker);
        }
        if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
            cachedClearTimeout$1 = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            return cachedClearTimeout$1(marker);
        } catch (e){
            try {
                return cachedClearTimeout$1.call(null, marker);
            } catch (e){
                return cachedClearTimeout$1.call(this, marker);
            }
        }
    }
    var queue$1 = [];
    var draining$1 = false;
    var currentQueue$1;
    var queueIndex$1 = -1;
    function cleanUpNextTick$1() {
        if (!draining$1 || !currentQueue$1) {
            return;
        }
        draining$1 = false;
        if (currentQueue$1.length) {
            queue$1 = currentQueue$1.concat(queue$1);
        } else {
            queueIndex$1 = -1;
        }
        if (queue$1.length) {
            drainQueue$1();
        }
    }
    function drainQueue$1() {
        if (draining$1) {
            return;
        }
        var timeout = runTimeout$1(cleanUpNextTick$1);
        draining$1 = true;
        var len = queue$1.length;
        while(len) {
            currentQueue$1 = queue$1;
            queue$1 = [];
            while (++queueIndex$1 < len) {
                if (currentQueue$1) {
                    currentQueue$1[queueIndex$1].run();
                }
            }
            queueIndex$1 = -1;
            len = queue$1.length;
        }
        currentQueue$1 = null;
        draining$1 = false;
        runClearTimeout$1(timeout);
    }
    function nextTick$1(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue$1.push(new Item$1(fun, args));
        if (queue$1.length === 1 && !draining$1) {
            runTimeout$1(drainQueue$1);
        }
    }
    function Item$1(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item$1.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title$1 = 'browser';
    var platform$1 = 'browser';
    var browser$2 = true;
    var env$1 = {};
    var argv$1 = [];
    var version$2 = '';
    var versions$1 = {};
    var release$1 = {};
    var config$1 = {};
    function noop$2() {}
    var on$1 = noop$2;
    var addListener$1 = noop$2;
    var once$1 = noop$2;
    var off$1 = noop$2;
    var removeListener$1 = noop$2;
    var removeAllListeners$1 = noop$2;
    var emit$1 = noop$2;
    function binding$1(name) {
        throw new Error('process.binding is not supported');
    }
    function cwd$1 () { return '/' }
    function chdir$1 (dir) {
        throw new Error('process.chdir is not supported');
    }function umask$1() { return 0; }
    var performance$1 = global$2.performance || {};
    var performanceNow$1 =
      performance$1.now        ||
      performance$1.mozNow     ||
      performance$1.msNow      ||
      performance$1.oNow       ||
      performance$1.webkitNow  ||
      function(){ return (new Date()).getTime() };
    function hrtime$1(previousTimestamp){
      var clocktime = performanceNow$1.call(performance$1)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }
    var startTime$1 = new Date();
    function uptime$1() {
      var currentTime = new Date();
      var dif = currentTime - startTime$1;
      return dif / 1000;
    }
    var process = {
      nextTick: nextTick$1,
      title: title$1,
      browser: browser$2,
      env: env$1,
      argv: argv$1,
      version: version$2,
      versions: versions$1,
      on: on$1,
      addListener: addListener$1,
      once: once$1,
      off: off$1,
      removeListener: removeListener$1,
      removeAllListeners: removeAllListeners$1,
      emit: emit$1,
      binding: binding$1,
      cwd: cwd$1,
      chdir: chdir$1,
      umask: umask$1,
      hrtime: hrtime$1,
      platform: platform$1,
      release: release$1,
      config: config$1,
      uptime: uptime$1
    };

    var global$1 = (typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray$2 = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    /*
     * Export kMaxLength after typed array support is determined.
     */
    kMaxLength();

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray$2(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer$1;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray$2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer$1(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version$1 = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on = noop$1;
    var addListener = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version$1,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var inherits;
    if (typeof Object.create === 'function'){
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$1 = inherits;

    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString$1(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect$1(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull$1(x) || !isObject$1(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect$1(x);
        }
      }
      return str;
    }

    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined$1(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      if (browser$1.noDeprecation === true) {
        return fn;
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser$1.throwDeprecation) {
            throw new Error(msg);
          } else if (browser$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined$1(debugEnviron))
        debugEnviron = browser$1.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect$1(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean$1(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined$1(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined$1(ctx.depth)) ctx.depth = 2;
      if (isUndefined$1(ctx.colors)) ctx.colors = false;
      if (isUndefined$1(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect$1.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect$1.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect$1.styles[styleType];

      if (style) {
        return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
               '\u001b[' + inspect$1.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction$1(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect$1 &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString$1(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError$1(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction$1(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp$1(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate$1(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError$1(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray$1(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction$1(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp$1(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate$1(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError$1(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp$1(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined$1(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString$1(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber$1(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean$1(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull$1(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull$1(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined$1(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray$1(ar) {
      return Array.isArray(ar);
    }

    function isBoolean$1(arg) {
      return typeof arg === 'boolean';
    }

    function isNull$1(arg) {
      return arg === null;
    }

    function isNullOrUndefined$1(arg) {
      return arg == null;
    }

    function isNumber$1(arg) {
      return typeof arg === 'number';
    }

    function isString$1(arg) {
      return typeof arg === 'string';
    }

    function isSymbol$1(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined$1(arg) {
      return arg === void 0;
    }

    function isRegExp$1(re) {
      return isObject$1(re) && objectToString$1(re) === '[object RegExp]';
    }

    function isObject$1(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate$1(d) {
      return isObject$1(d) && objectToString$1(d) === '[object Date]';
    }

    function isError$1(e) {
      return isObject$1(e) &&
          (objectToString$1(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction$1(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive$1(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }

    function isBuffer(maybeBuf) {
      return Buffer.isBuffer(maybeBuf);
    }

    function objectToString$1(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    function log() {
      console.log('%s - %s', timestamp(), format.apply(null, arguments));
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject$1(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var _polyfillNode_util = {
      inherits: inherits$1,
      _extend: _extend,
      log: log,
      isBuffer: isBuffer,
      isPrimitive: isPrimitive$1,
      isFunction: isFunction$1,
      isError: isError$1,
      isDate: isDate$1,
      isObject: isObject$1,
      isRegExp: isRegExp$1,
      isUndefined: isUndefined$1,
      isSymbol: isSymbol$1,
      isString: isString$1,
      isNumber: isNumber$1,
      isNullOrUndefined: isNullOrUndefined$1,
      isNull: isNull$1,
      isBoolean: isBoolean$1,
      isArray: isArray$1,
      inspect: inspect$1,
      deprecate: deprecate,
      format: format,
      debuglog: debuglog
    };

    var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        format: format,
        deprecate: deprecate,
        debuglog: debuglog,
        inspect: inspect$1,
        isArray: isArray$1,
        isBoolean: isBoolean$1,
        isNull: isNull$1,
        isNullOrUndefined: isNullOrUndefined$1,
        isNumber: isNumber$1,
        isString: isString$1,
        isSymbol: isSymbol$1,
        isUndefined: isUndefined$1,
        isRegExp: isRegExp$1,
        isObject: isObject$1,
        isDate: isDate$1,
        isError: isError$1,
        isFunction: isFunction$1,
        isPrimitive: isPrimitive$1,
        isBuffer: isBuffer,
        log: log,
        inherits: inherits$1,
        _extend: _extend,
        'default': _polyfillNode_util
    });

    function compare(a, b) {
      if (a === b) {
        return 0;
      }

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var hasOwn = Object.prototype.hasOwnProperty;

    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }
      return keys;
    };
    var pSlice = Array.prototype.slice;
    var _functionsHaveNames;
    function functionsHaveNames() {
      if (typeof _functionsHaveNames !== 'undefined') {
        return _functionsHaveNames;
      }
      return _functionsHaveNames = (function () {
        return function foo() {}.name === 'foo';
      }());
    }
    function pToString (obj) {
      return Object.prototype.toString.call(obj);
    }
    function isView(arrbuf) {
      if (isBuffer$1(arrbuf)) {
        return false;
      }
      if (typeof global$1.ArrayBuffer !== 'function') {
        return false;
      }
      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }
      if (!arrbuf) {
        return false;
      }
      if (arrbuf instanceof DataView) {
        return true;
      }
      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }
      return false;
    }
    // 1. The assert module provides functions that throw
    // AssertionError's when particular conditions are not met. The
    // assert module must conform to the following interface.

    function assert$2(value, message) {
      if (!value) fail(value, true, message, '==', ok);
    }

    // 2. The AssertionError is defined in assert.
    // new assert.AssertionError({ message: message,
    //                             actual: actual,
    //                             expected: expected })

    var regex = /\s*function\s+([^\(\s]*)\s*/;
    // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
    function getName(func) {
      if (!isFunction$1(func)) {
        return;
      }
      if (functionsHaveNames()) {
        return func.name;
      }
      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }
    assert$2.AssertionError = AssertionError;
    function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        // non v8 browsers so we can have a stacktrace
        var err = new Error();
        if (err.stack) {
          var out = err.stack;

          // try to strip useless frames
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            // once we have located the function frame
            // we need to strip out everything before it (and its line)
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }

          this.stack = out;
        }
      }
    }

    // assert.AssertionError instanceof Error
    inherits$1(AssertionError, Error);

    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    function inspect(something) {
      if (functionsHaveNames() || !isFunction$1(something)) {
        return inspect$1(something);
      }
      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' +  name + ']';
    }
    function getMessage(self) {
      return truncate(inspect(self.actual), 128) + ' ' +
             self.operator + ' ' +
             truncate(inspect(self.expected), 128);
    }

    // At present only the three keys mentioned above are used and
    // understood by the spec. Implementations or sub modules can pass
    // other keys to the AssertionError's constructor - they will be
    // ignored.

    // 3. All of the following functions must throw an AssertionError
    // when a corresponding condition is not met, with a message that
    // may be undefined if not provided.  All assertion methods provide
    // both the actual and expected values to the assertion error for
    // display purposes.

    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }

    // EXTENSION! allows for well behaved errors defined elsewhere.
    assert$2.fail = fail;

    // 4. Pure assertion tests whether a value is truthy, as determined
    // by !!guard.
    // assert.ok(guard, message_opt);
    // This statement is equivalent to assert.equal(true, !!guard,
    // message_opt);. To test strictly for the value true, use
    // assert.strictEqual(true, guard, message_opt);.

    function ok(value, message) {
      if (!value) fail(value, true, message, '==', ok);
    }
    assert$2.ok = ok;

    // 5. The equality assertion tests shallow, coercive equality with
    // ==.
    // assert.equal(actual, expected, message_opt);
    assert$2.equal = equal;
    function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', equal);
    }

    // 6. The non-equality assertion tests for whether two objects are not equal
    // with != assert.notEqual(actual, expected, message_opt);
    assert$2.notEqual = notEqual;
    function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', notEqual);
      }
    }

    // 7. The equivalence assertion tests a deep equality relation.
    // assert.deepEqual(actual, expected, message_opt);
    assert$2.deepEqual = deepEqual$1;
    function deepEqual$1(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', deepEqual$1);
      }
    }
    assert$2.deepStrictEqual = deepStrictEqual;
    function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
      }
    }

    function _deepEqual(actual, expected, strict, memos) {
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
      } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
        return compare(actual, expected) === 0;

      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      } else if (isDate$1(actual) && isDate$1(expected)) {
        return actual.getTime() === expected.getTime();

      // 7.3 If the expected value is a RegExp object, the actual value is
      // equivalent if it is also a RegExp object with the same source and
      // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
      } else if (isRegExp$1(actual) && isRegExp$1(expected)) {
        return actual.source === expected.source &&
               actual.global === expected.global &&
               actual.multiline === expected.multiline &&
               actual.lastIndex === expected.lastIndex &&
               actual.ignoreCase === expected.ignoreCase;

      // 7.4. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if ((actual === null || typeof actual !== 'object') &&
                 (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;

      // If both values are instances of typed arrays, wrap their underlying
      // ArrayBuffers in a Buffer each to increase performance
      // This optimization requires the arrays to have the same type as checked by
      // Object.prototype.toString (aka pToString). Never perform binary
      // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
      // bit patterns are not identical.
      } else if (isView(actual) && isView(expected) &&
                 pToString(actual) === pToString(expected) &&
                 !(actual instanceof Float32Array ||
                   actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer),
                       new Uint8Array(expected.buffer)) === 0;

      // 7.5 For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
        return false;
      } else {
        memos = memos || {actual: [], expected: []};

        var actualIndex = memos.actual.indexOf(actual);
        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }

        memos.actual.push(actual);
        memos.expected.push(expected);

        return objEquiv(actual, expected, strict, memos);
      }
    }

    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }

    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined)
        return false;
      // if one is a primitive, the other must be same
      if (isPrimitive$1(a) || isPrimitive$1(b))
        return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
        return false;
      var aIsArgs = isArguments(a);
      var bIsArgs = isArguments(b);
      if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
        return false;
      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }
      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key, i;
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length !== kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
          return false;
      }
      return true;
    }

    // 8. The non-equivalence assertion tests for any deep inequality.
    // assert.notDeepEqual(actual, expected, message_opt);
    assert$2.notDeepEqual = notDeepEqual;
    function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
      }
    }

    assert$2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }


    // 9. The strict equality assertion tests strict equality, as determined by ===.
    // assert.strictEqual(actual, expected, message_opt);
    assert$2.strictEqual = strictEqual;
    function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', strictEqual);
      }
    }

    // 10. The strict non-equality assertion tests for strict inequality, as
    // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
    assert$2.notStrictEqual = notStrictEqual;
    function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', notStrictEqual);
      }
    }

    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }

      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }

      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {
        // Ignore.  The instanceof check doesn't work for arrow functions.
      }

      if (Error.isPrototypeOf(expected)) {
        return false;
      }

      return expected.call({}, actual) === true;
    }

    function _tryBlock(block) {
      var error;
      try {
        block();
      } catch (e) {
        error = e;
      }
      return error;
    }

    function _throws(shouldThrow, block, expected, message) {
      var actual;

      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }

      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }

      actual = _tryBlock(block);

      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
                (message ? ' ' + message : '.');

      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }

      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && isError$1(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;

      if ((isUnwantedException &&
          userProvidedMessage &&
          expectedException(actual, expected)) ||
          isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }

      if ((shouldThrow && actual && expected &&
          !expectedException(actual, expected)) || (!shouldThrow && actual)) {
        throw actual;
      }
    }

    // 11. Expected to throw an error:
    // assert.throws(block, Error_opt, message_opt);
    assert$2.throws = throws;
    function throws(block, /*optional*/error, /*optional*/message) {
      _throws(true, block, error, message);
    }

    // EXTENSION! This is annoying to write outside this module.
    assert$2.doesNotThrow = doesNotThrow;
    function doesNotThrow(block, /*optional*/error, /*optional*/message) {
      _throws(false, block, error, message);
    }

    assert$2.ifError = ifError;
    function ifError(err) {
      if (err) throw err;
    }

    var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': assert$2,
        AssertionError: AssertionError,
        fail: fail,
        ok: ok,
        assert: ok,
        equal: equal,
        notEqual: notEqual,
        deepEqual: deepEqual$1,
        deepStrictEqual: deepStrictEqual,
        notDeepEqual: notDeepEqual,
        notDeepStrictEqual: notDeepStrictEqual,
        strictEqual: strictEqual,
        notStrictEqual: notStrictEqual,
        throws: throws,
        doesNotThrow: doesNotThrow,
        ifError: ifError
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.usingDomains = false;

    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active ) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };
        
    // Alias for removeListener added in NodeJS 10.0
    // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
    EventEmitter.prototype.off = function(type, listener){
        return this.removeListener(type, listener);
    };

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount$1.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount$1;
    function listenerCount$1(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    BufferList.prototype.push = function (v) {
      var entry = { data: v, next: null };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };

    BufferList.prototype.unshift = function (v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };

    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };

    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };

    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    };

    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return Buffer.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };

    // Copyright Joyent, Inc. and other Node contributors.
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         };


    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    function StringDecoder(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }

      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    }

    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;

        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }

        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);

        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;

        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }

      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);

      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);

      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }

      // or just emit the charStr
      return charStr;
    };

    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;

      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];

        // See http://en.wikipedia.org/wiki/UTF-8#Description

        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }

        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }

        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    Readable.ReadableState = ReadableState;

    var debug = debuglog('stream');
    inherits$1(Readable, EventEmitter);

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        // This is a hack to make sure that our error handler is attached before any
        // userland ones.  NEVER DO THIS. This is here only because this code needs
        // to continue to work with older versions of Node.js that do not include
        // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    function listenerCount (emitter, type) {
      return emitter.listeners(type).length;
    }
    function ReadableState(options, stream) {

      options = options || {};

      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;

      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;

      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;

      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {

      if (!(this instanceof Readable)) return new Readable(options);

      this._readableState = new ReadableState(options, this);

      // legacy
      this.readable = true;

      if (options && typeof options.read === 'function') this._read = options.read;

      EventEmitter.call(this);
    }

    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
      }

      return readableAddChunk(this, state, chunk, encoding, false);
    };

    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };

    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');
          stream.emit('error', _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }

          if (!addToFront) state.reading = false;

          // Don't add to the buffer if we've decoded to an empty string chunk and
          // we're not in object mode
          if (!skipAdd) {
            // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

              if (state.needReadable) emitReadable(stream);
            }
          }

          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }

      return needMoreData(state);
    }

    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }

    // backwards compatibility.
    Readable.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };

    // Don't raise the hwm > 8MB
    var MAX_HWM = 0x800000;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }

    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      }
      // If we're asking for more than the current hwm, then raise the hwm.
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      // Don't have enough
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }

    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function (n) {
      debug('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;

      if (n !== 0) state.emittedReadable = false;

      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state);

      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }

      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.

      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);

      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }

      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);

      return ret;
    };

    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }

    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;

      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }

    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
      }
    }

    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }

    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;else len = state.length;
      }
      state.readingMore = false;
    }

    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

      var doEnd = (!pipeOpts || pipeOpts.end !== false);

      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }

      function onend() {
        debug('onend');
        dest.end();
      }

      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);

      var cleanedUp = false;
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);

        cleanedUp = true;

        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      // If the user pushes more data while we're writing to dest then we'll end up
      // in ondata again. However, we only want to increase awaitDrain once because
      // dest will only emit one 'drain' event for the multiple writes.
      // => Introduce a guard on increasing awaitDrain.
      var increasedAwaitDrain = false;
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }

      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
      }

      // Make sure our error handler is attached before userland ones.
      prependListener(dest, 'error', onerror);

      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);

      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }

      // tell the dest that it's being piped to
      dest.emit('pipe', src);

      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && src.listeners('data').length) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;

      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0) return this;

      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;

        if (!dest) dest = state.pipes;

        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }

      // slow case. multiple pipe destinations.

      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }return this;
      }

      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;

      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];

      dest.emit('unpipe', this);

      return this;
    };

    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function (ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);

      if (ev === 'data') {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }

      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;

    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }

    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }

      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }

    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;

      var self = this;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }

        self.push(null);
      });

      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);

        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });

      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }

      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });

      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return self;
    };

    // exposed for testing purposes only.
    Readable._fromList = fromList;

    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;

      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
      }

      return ret;
    }

    // Extracts only enough buffered data to satisfy the amount requested.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
      } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }

    // Copies a specified amount of characters from the list of buffered data
    // chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    // Copies a specified amount of bytes from the list of buffered data chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBuffer(n, list) {
      var ret = Buffer.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState;

      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }

    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }

    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }

    // A bit simpler than readable streams.
    Writable.WritableState = WritableState;
    inherits$1(Writable, EventEmitter);

    function nop() {}

    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }

    function WritableState(options, stream) {
      Object.defineProperty(this, 'buffer', {
        get: deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
      });
      options = options || {};

      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;

      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;

      // a flag to see when we're in the middle of a write.
      this.writing = false;

      // when true all writes will be buffered until .uncork() call
      this.corked = 0;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;

      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function (er) {
        onwrite(stream, er);
      };

      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;

      // the amount that is being written when _write is called.
      this.writelen = 0;

      this.bufferedRequest = null;
      this.lastBufferedRequest = null;

      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;

      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;

      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;

      // count buffered requests
      this.bufferedRequestCount = 0;

      // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two
      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    function Writable(options) {

      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

      this._writableState = new WritableState(options, this);

      // legacy.
      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;

        if (typeof options.writev === 'function') this._writev = options.writev;
      }

      EventEmitter.call(this);
    }

    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };

    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      nextTick(cb, er);
    }

    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      // Always throw error if a null is written
      // if we are not in object mode then throw
      // if it is not a buffer, string, or undefined.
      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      if (er) {
        stream.emit('error', er);
        nextTick(cb, er);
        valid = false;
      }
      return valid;
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

      if (typeof cb !== 'function') cb = nop;

      if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }

      return ret;
    };

    Writable.prototype.cork = function () {
      var state = this._writableState;

      state.corked++;
    };

    Writable.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;

        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
      }
      return chunk;
    }

    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;

      state.length += len;

      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) nextTick(cb, er);else cb(er);

      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;

      onwriteStateUpdate(state);

      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          /*<replacement>*/
            nextTick(afterWrite, stream, state, finished, cb);
          /*</replacement>*/
        } else {
            afterWrite(stream, state, finished, cb);
          }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }

    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }

    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;

        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }

        doWrite(stream, state, true, state.length, buffer, '', holder.finish);

        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;

          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }

      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }

    // It seems a linked list but it is not
    // there will be only 2 of these for each stream
    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }

    inherits$1(Duplex, Readable);

    var keys = Object.keys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);

      Readable.call(this, options);
      Writable.call(this, options);

      if (options && options.readable === false) this.readable = false;

      if (options && options.writable === false) this.writable = false;

      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

      this.once('end', onend);
    }

    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended) return;

      // no more data can be written.
      // But allow more writes to happen in this tick.
      nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    }

    // a transform stream is a readable/writable stream where you do
    inherits$1(Transform, Duplex);

    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };

      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }

    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;

      var cb = ts.writecb;

      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

      ts.writechunk = null;
      ts.writecb = null;

      if (data !== null && data !== undefined) stream.push(data);

      cb(er);

      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);

      Duplex.call(this, options);

      this._transformState = new TransformState(this);

      // when the writable side finishes, then flush out anything remaining.
      var stream = this;

      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;

      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;

        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };

    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };

    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    function done(stream, er) {
      if (er) return stream.emit('error', er);

      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;

      if (ws.length) throw new Error('Calling transform done when ws.length != 0');

      if (ts.transforming) throw new Error('Calling transform done when still transforming');

      return stream.push(null);
    }

    inherits$1(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);

      Transform.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    inherits$1(Stream$1, EventEmitter);
    Stream$1.Readable = Readable;
    Stream$1.Writable = Writable;
    Stream$1.Duplex = Duplex;
    Stream$1.Transform = Transform;
    Stream$1.PassThrough = PassThrough;

    // Backwards-compat with node 0.4.x
    Stream$1.Stream = Stream$1;

    // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.

    function Stream$1() {
      EventEmitter.call(this);
    }

    Stream$1.prototype.pipe = function(dest, options) {
      var source = this;

      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }

      source.on('data', ondata);

      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }

      dest.on('drain', ondrain);

      // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }

      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
      }


      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === 'function') dest.destroy();
      }

      // don't leave dangling pipes when there are errors.
      function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }

      source.on('error', onerror);
      dest.on('error', onerror);

      // remove all the event listeners that were added.
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);

        source.removeListener('end', onend);
        source.removeListener('close', onclose);

        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);

        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);

        dest.removeListener('close', cleanup);
      }

      source.on('end', cleanup);
      source.on('close', cleanup);

      dest.on('close', cleanup);

      dest.emit('pipe', source);

      // Allow for unix-like usage: A.pipe(B).pipe(C)
      return dest;
    };

    var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Stream$1,
        Readable: Readable,
        Writable: Writable,
        Duplex: Duplex,
        Transform: Transform,
        PassThrough: PassThrough,
        Stream: Stream$1
    });

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

    var assert$1 = require$$0;
    var Stream = require$$1.Stream;
    var util$3 = require$$2;
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    function _toss(name, expected, oper, arg, actual) {
        throw new assert$1.AssertionError({
            message: util$3.format('%s (%s) is required', name, expected),
            actual: (actual === undefined) ? typeof (arg) : actual(arg),
            expected: expected,
            operator: oper || '===',
            stackStartFunction: _toss.caller
        });
    }
    function _getClass(arg) {
        return (Object.prototype.toString.call(arg).slice(8, -1));
    }
    function noop() {
    }
    var types = {
        bool: {
            check: function (arg) { return typeof (arg) === 'boolean'; }
        },
        func: {
            check: function (arg) { return typeof (arg) === 'function'; }
        },
        string: {
            check: function (arg) { return typeof (arg) === 'string'; }
        },
        object: {
            check: function (arg) {
                return typeof (arg) === 'object' && arg !== null;
            }
        },
        number: {
            check: function (arg) {
                return typeof (arg) === 'number' && !isNaN(arg);
            }
        },
        finite: {
            check: function (arg) {
                return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
            }
        },
        buffer: {
            check: function (arg) { return isBuffer$2(arg); },
            operator: 'Buffer.isBuffer'
        },
        array: {
            check: function (arg) { return Array.isArray(arg); },
            operator: 'Array.isArray'
        },
        stream: {
            check: function (arg) { return arg instanceof Stream; },
            operator: 'instanceof',
            actual: _getClass
        },
        date: {
            check: function (arg) { return arg instanceof Date; },
            operator: 'instanceof',
            actual: _getClass
        },
        regexp: {
            check: function (arg) { return arg instanceof RegExp; },
            operator: 'instanceof',
            actual: _getClass
        },
        uuid: {
            check: function (arg) {
                return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
            },
            operator: 'isUUID'
        }
    };
    function _setExports(ndebug) {
        var keys = Object.keys(types);
        var out;
        if (process.env.NODE_NDEBUG) {
            out = noop;
        } else {
            out = function (arg, msg) {
                if (!arg) {
                    _toss(msg, 'true', arg);
                }
            };
        }
        keys.forEach(function (k) {
            if (ndebug) {
                out[k] = noop;
                return;
            }
            var type = types[k];
            out[k] = function (arg, msg) {
                if (!type.check(arg)) {
                    _toss(msg, k, type.operator, arg, type.actual);
                }
            };
        });
        keys.forEach(function (k) {
            var name = 'optional' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            out[name] = function (arg, msg) {
                if (arg === undefined || arg === null) {
                    return;
                }
                if (!type.check(arg)) {
                    _toss(msg, k, type.operator, arg, type.actual);
                }
            };
        });
        keys.forEach(function (k) {
            var name = 'arrayOf' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            var expected = '[' + k + ']';
            out[name] = function (arg, msg) {
                if (!Array.isArray(arg)) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
                var i;
                for (i = 0; i < arg.length; i++) {
                    if (!type.check(arg[i])) {
                        _toss(msg, expected, type.operator, arg, type.actual);
                    }
                }
            };
        });
        keys.forEach(function (k) {
            var name = 'optionalArrayOf' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            var expected = '[' + k + ']';
            out[name] = function (arg, msg) {
                if (arg === undefined || arg === null) {
                    return;
                }
                if (!Array.isArray(arg)) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
                var i;
                for (i = 0; i < arg.length; i++) {
                    if (!type.check(arg[i])) {
                        _toss(msg, expected, type.operator, arg, type.actual);
                    }
                }
            };
        });
        Object.keys(assert$1).forEach(function (k) {
            if (k === 'AssertionError') {
                out[k] = assert$1[k];
                return;
            }
            if (ndebug) {
                out[k] = noop;
                return;
            }
            out[k] = assert$1[k];
        });
        out._setExports = _setExports;
        return out;
    }
    var assert_1 = _setExports(process.env.NODE_NDEBUG);

    var jsprim$1 = {};

    var extsprintf$1 = {};

    var mod_assert$2 = require$$0;
    var mod_util$2 = require$$2;
    extsprintf$1.sprintf = jsSprintf$1;
    extsprintf$1.printf = jsPrintf$1;
    extsprintf$1.fprintf = jsFprintf$1;
    function jsSprintf$1(fmt)
    {
    	var regex = [
    	    '([^%]*)',
    	    '%',
    	    '([\'\\-+ #0]*?)',
    	    '([1-9]\\d*)?',
    	    '(\\.([1-9]\\d*))?',
    	    '[lhjztL]*?',
    	    '([diouxXfFeEgGaAcCsSp%jr])'
    	].join('');
    	var re = new RegExp(regex);
    	var args = Array.prototype.slice.call(arguments, 1);
    	var flags, width, precision, conversion;
    	var left, pad, sign, arg, match;
    	var ret = '';
    	var argn = 1;
    	mod_assert$2.equal('string', typeof (fmt));
    	while ((match = re.exec(fmt)) !== null) {
    		ret += match[1];
    		fmt = fmt.substring(match[0].length);
    		flags = match[2] || '';
    		width = match[3] || 0;
    		precision = match[4] || '';
    		conversion = match[6];
    		left = false;
    		sign = false;
    		pad = ' ';
    		if (conversion == '%') {
    			ret += '%';
    			continue;
    		}
    		if (args.length === 0)
    			throw (new Error('too few args to sprintf'));
    		arg = args.shift();
    		argn++;
    		if (flags.match(/[\' #]/))
    			throw (new Error(
    			    'unsupported flags: ' + flags));
    		if (precision.length > 0)
    			throw (new Error(
    			    'non-zero precision not supported'));
    		if (flags.match(/-/))
    			left = true;
    		if (flags.match(/0/))
    			pad = '0';
    		if (flags.match(/\+/))
    			sign = true;
    		switch (conversion) {
    		case 's':
    			if (arg === undefined || arg === null)
    				throw (new Error('argument ' + argn +
    				    ': attempted to print undefined or null ' +
    				    'as a string'));
    			ret += doPad$1(pad, width, left, arg.toString());
    			break;
    		case 'd':
    			arg = Math.floor(arg);
    		case 'f':
    			sign = sign && arg > 0 ? '+' : '';
    			ret += sign + doPad$1(pad, width, left,
    			    arg.toString());
    			break;
    		case 'x':
    			ret += doPad$1(pad, width, left, arg.toString(16));
    			break;
    		case 'j':
    			if (width === 0)
    				width = 10;
    			ret += mod_util$2.inspect(arg, false, width);
    			break;
    		case 'r':
    			ret += dumpException$1(arg);
    			break;
    		default:
    			throw (new Error('unsupported conversion: ' +
    			    conversion));
    		}
    	}
    	ret += fmt;
    	return (ret);
    }
    function jsPrintf$1() {
    	var args = Array.prototype.slice.call(arguments);
    	args.unshift(process.stdout);
    	jsFprintf$1.apply(null, args);
    }
    function jsFprintf$1(stream) {
    	var args = Array.prototype.slice.call(arguments, 1);
    	return (stream.write(jsSprintf$1.apply(this, args)));
    }
    function doPad$1(chr, width, left, str)
    {
    	var ret = str;
    	while (ret.length < width) {
    		if (left)
    			ret += chr;
    		else
    			ret = chr + ret;
    	}
    	return (ret);
    }
    function dumpException$1(ex)
    {
    	var ret;
    	if (!(ex instanceof Error))
    		throw (new Error(jsSprintf$1('invalid type for %%r: %j', ex)));
    	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
    	if (ex.cause && typeof (ex.cause) === 'function') {
    		var cex = ex.cause();
    		if (cex) {
    			ret += '\nCaused by: ' + dumpException$1(cex);
    		}
    	}
    	return (ret);
    }

    var extsprintf = {};

    var mod_assert$1 = require$$0;
    var mod_util$1 = require$$2;
    extsprintf.sprintf = jsSprintf;
    extsprintf.printf = jsPrintf;
    extsprintf.fprintf = jsFprintf;
    function jsSprintf(ofmt)
    {
    	var regex = [
    	    '([^%]*)',
    	    '%',
    	    '([\'\\-+ #0]*?)',
    	    '([1-9]\\d*)?',
    	    '(\\.([1-9]\\d*))?',
    	    '[lhjztL]*?',
    	    '([diouxXfFeEgGaAcCsSp%jr])'
    	].join('');
    	var re = new RegExp(regex);
    	var args = Array.prototype.slice.call(arguments, 1);
    	var fmt = ofmt;
    	var flags, width, precision, conversion;
    	var left, pad, sign, arg, match;
    	var ret = '';
    	var argn = 1;
    	var posn = 0;
    	var convposn;
    	var curconv;
    	mod_assert$1.equal('string', typeof (fmt),
    	    'first argument must be a format string');
    	while ((match = re.exec(fmt)) !== null) {
    		ret += match[1];
    		fmt = fmt.substring(match[0].length);
    		curconv = match[0].substring(match[1].length);
    		convposn = posn + match[1].length + 1;
    		posn += match[0].length;
    		flags = match[2] || '';
    		width = match[3] || 0;
    		precision = match[4] || '';
    		conversion = match[6];
    		left = false;
    		sign = false;
    		pad = ' ';
    		if (conversion == '%') {
    			ret += '%';
    			continue;
    		}
    		if (args.length === 0) {
    			throw (jsError(ofmt, convposn, curconv,
    			    'has no matching argument ' +
    			    '(too few arguments passed)'));
    		}
    		arg = args.shift();
    		argn++;
    		if (flags.match(/[\' #]/)) {
    			throw (jsError(ofmt, convposn, curconv,
    			    'uses unsupported flags'));
    		}
    		if (precision.length > 0) {
    			throw (jsError(ofmt, convposn, curconv,
    			    'uses non-zero precision (not supported)'));
    		}
    		if (flags.match(/-/))
    			left = true;
    		if (flags.match(/0/))
    			pad = '0';
    		if (flags.match(/\+/))
    			sign = true;
    		switch (conversion) {
    		case 's':
    			if (arg === undefined || arg === null) {
    				throw (jsError(ofmt, convposn, curconv,
    				    'attempted to print undefined or null ' +
    				    'as a string (argument ' + argn + ' to ' +
    				    'sprintf)'));
    			}
    			ret += doPad(pad, width, left, arg.toString());
    			break;
    		case 'd':
    			arg = Math.floor(arg);
    		case 'f':
    			sign = sign && arg > 0 ? '+' : '';
    			ret += sign + doPad(pad, width, left,
    			    arg.toString());
    			break;
    		case 'x':
    			ret += doPad(pad, width, left, arg.toString(16));
    			break;
    		case 'j':
    			if (width === 0)
    				width = 10;
    			ret += mod_util$1.inspect(arg, false, width);
    			break;
    		case 'r':
    			ret += dumpException(arg);
    			break;
    		default:
    			throw (jsError(ofmt, convposn, curconv,
    			    'is not supported'));
    		}
    	}
    	ret += fmt;
    	return (ret);
    }
    function jsError(fmtstr, convposn, curconv, reason) {
    	mod_assert$1.equal(typeof (fmtstr), 'string');
    	mod_assert$1.equal(typeof (curconv), 'string');
    	mod_assert$1.equal(typeof (convposn), 'number');
    	mod_assert$1.equal(typeof (reason), 'string');
    	return (new Error('format string "' + fmtstr +
    	    '": conversion specifier "' + curconv + '" at character ' +
    	    convposn + ' ' + reason));
    }
    function jsPrintf() {
    	var args = Array.prototype.slice.call(arguments);
    	args.unshift(process.stdout);
    	jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
    	var args = Array.prototype.slice.call(arguments, 1);
    	return (stream.write(jsSprintf.apply(this, args)));
    }
    function doPad(chr, width, left, str)
    {
    	var ret = str;
    	while (ret.length < width) {
    		if (left)
    			ret += chr;
    		else
    			ret = chr + ret;
    	}
    	return (ret);
    }
    function dumpException(ex)
    {
    	var ret;
    	if (!(ex instanceof Error))
    		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
    	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
    	if (ex.cause && typeof (ex.cause) === 'function') {
    		var cex = ex.cause();
    		if (cex) {
    			ret += '\nCaused by: ' + dumpException(cex);
    		}
    	}
    	return (ret);
    }

    var util$2 = {};

    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === '[object Array]';
    }
    util$2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    util$2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    util$2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    util$2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    util$2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    util$2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    util$2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    util$2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === '[object RegExp]';
    }
    util$2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    util$2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === '[object Date]';
    }
    util$2.isDate = isDate;
    function isError(e) {
      return (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    util$2.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    util$2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||
             typeof arg === 'undefined';
    }
    util$2.isPrimitive = isPrimitive;
    util$2.isBuffer = isBuffer$2;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    var mod_assertplus = assert_1;
    var mod_util = require$$2;
    var mod_extsprintf$1 = extsprintf;
    var mod_isError = util$2.isError;
    var sprintf = mod_extsprintf$1.sprintf;
    var verror = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args)
    {
    	var argv, options, sprintf_args, shortmessage, k;
    	mod_assertplus.object(args, 'args');
    	mod_assertplus.bool(args.strict, 'args.strict');
    	mod_assertplus.array(args.argv, 'args.argv');
    	argv = args.argv;
    	if (argv.length === 0) {
    		options = {};
    		sprintf_args = [];
    	} else if (mod_isError(argv[0])) {
    		options = { 'cause': argv[0] };
    		sprintf_args = argv.slice(1);
    	} else if (typeof (argv[0]) === 'object') {
    		options = {};
    		for (k in argv[0]) {
    			options[k] = argv[0][k];
    		}
    		sprintf_args = argv.slice(1);
    	} else {
    		mod_assertplus.string(argv[0],
    		    'first argument to VError, SError, or WError ' +
    		    'constructor must be a string, object, or Error');
    		options = {};
    		sprintf_args = argv;
    	}
    	mod_assertplus.object(options);
    	if (!options.strict && !args.strict) {
    		sprintf_args = sprintf_args.map(function (a) {
    			return (a === null ? 'null' :
    			    a === undefined ? 'undefined' : a);
    		});
    	}
    	if (sprintf_args.length === 0) {
    		shortmessage = '';
    	} else {
    		shortmessage = sprintf.apply(null, sprintf_args);
    	}
    	return ({
    	    'options': options,
    	    'shortmessage': shortmessage
    	});
    }
    function VError()
    {
    	var args, obj, parsed, cause, ctor, message, k;
    	args = Array.prototype.slice.call(arguments, 0);
    	if (!(this instanceof VError)) {
    		obj = Object.create(VError.prototype);
    		VError.apply(obj, arguments);
    		return (obj);
    	}
    	parsed = parseConstructorArguments({
    	    'argv': args,
    	    'strict': false
    	});
    	if (parsed.options.name) {
    		mod_assertplus.string(parsed.options.name,
    		    'error\'s "name" must be a string');
    		this.name = parsed.options.name;
    	}
    	this.jse_shortmsg = parsed.shortmessage;
    	message = parsed.shortmessage;
    	cause = parsed.options.cause;
    	if (cause) {
    		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
    		this.jse_cause = cause;
    		if (!parsed.options.skipCauseMessage) {
    			message += ': ' + cause.message;
    		}
    	}
    	this.jse_info = {};
    	if (parsed.options.info) {
    		for (k in parsed.options.info) {
    			this.jse_info[k] = parsed.options.info[k];
    		}
    	}
    	this.message = message;
    	Error.call(this, message);
    	if (Error.captureStackTrace) {
    		ctor = parsed.options.constructorOpt || this.constructor;
    		Error.captureStackTrace(this, ctor);
    	}
    	return (this);
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = 'VError';
    VError.prototype.toString = function ve_toString()
    {
    	var str = (this.hasOwnProperty('name') && this.name ||
    		this.constructor.name || this.constructor.prototype.name);
    	if (this.message)
    		str += ': ' + this.message;
    	return (str);
    };
    VError.prototype.cause = function ve_cause()
    {
    	var cause = VError.cause(this);
    	return (cause === null ? undefined : cause);
    };
    VError.cause = function (err)
    {
    	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
    };
    VError.info = function (err)
    {
    	var rv, cause, k;
    	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    	cause = VError.cause(err);
    	if (cause !== null) {
    		rv = VError.info(cause);
    	} else {
    		rv = {};
    	}
    	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
    		for (k in err.jse_info) {
    			rv[k] = err.jse_info[k];
    		}
    	}
    	return (rv);
    };
    VError.findCauseByName = function (err, name)
    {
    	var cause;
    	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    	mod_assertplus.string(name, 'name');
    	mod_assertplus.ok(name.length > 0, 'name cannot be empty');
    	for (cause = err; cause !== null; cause = VError.cause(cause)) {
    		mod_assertplus.ok(mod_isError(cause));
    		if (cause.name == name) {
    			return (cause);
    		}
    	}
    	return (null);
    };
    VError.hasCauseWithName = function (err, name)
    {
    	return (VError.findCauseByName(err, name) !== null);
    };
    VError.fullStack = function (err)
    {
    	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    	var cause = VError.cause(err);
    	if (cause) {
    		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
    	}
    	return (err.stack);
    };
    VError.errorFromList = function (errors)
    {
    	mod_assertplus.arrayOfObject(errors, 'errors');
    	if (errors.length === 0) {
    		return (null);
    	}
    	errors.forEach(function (e) {
    		mod_assertplus.ok(mod_isError(e));
    	});
    	if (errors.length == 1) {
    		return (errors[0]);
    	}
    	return (new MultiError(errors));
    };
    VError.errorForEach = function (err, func)
    {
    	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    	mod_assertplus.func(func, 'func');
    	if (err instanceof MultiError) {
    		err.errors().forEach(function iterError(e) { func(e); });
    	} else {
    		func(err);
    	}
    };
    function SError()
    {
    	var args, obj, parsed, options;
    	args = Array.prototype.slice.call(arguments, 0);
    	if (!(this instanceof SError)) {
    		obj = Object.create(SError.prototype);
    		SError.apply(obj, arguments);
    		return (obj);
    	}
    	parsed = parseConstructorArguments({
    	    'argv': args,
    	    'strict': true
    	});
    	options = parsed.options;
    	VError.call(this, options, '%s', parsed.shortmessage);
    	return (this);
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors)
    {
    	mod_assertplus.array(errors, 'list of errors');
    	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
    	this.ase_errors = errors;
    	VError.call(this, {
    	    'cause': errors[0]
    	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = 'MultiError';
    MultiError.prototype.errors = function me_errors()
    {
    	return (this.ase_errors.slice(0));
    };
    function WError()
    {
    	var args, obj, parsed, options;
    	args = Array.prototype.slice.call(arguments, 0);
    	if (!(this instanceof WError)) {
    		obj = Object.create(WError.prototype);
    		WError.apply(obj, args);
    		return (obj);
    	}
    	parsed = parseConstructorArguments({
    	    'argv': args,
    	    'strict': false
    	});
    	options = parsed.options;
    	options['skipCauseMessage'] = true;
    	VError.call(this, options, '%s', parsed.shortmessage);
    	return (this);
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = 'WError';
    WError.prototype.toString = function we_toString()
    {
    	var str = (this.hasOwnProperty('name') && this.name ||
    		this.constructor.name || this.constructor.prototype.name);
    	if (this.message)
    		str += ': ' + this.message;
    	if (this.jse_cause && this.jse_cause.message)
    		str += '; caused by ' + this.jse_cause.toString();
    	return (str);
    };
    WError.prototype.cause = function we_cause(c)
    {
    	if (mod_isError(c))
    		this.jse_cause = c;
    	return (this.jse_cause);
    };

    var validate = {exports: {}};

    (function (module) {
    	(function (root, factory) {
    	    if (module.exports) {
    	        module.exports = factory();
    	    } else {
    	        root.jsonSchema = factory();
    	    }
    	}(commonjsGlobal, function () {
    	var exports = validate;
    	exports.Integer = {type:"integer"};
    	var primitiveConstructors = {
    		String: String,
    		Boolean: Boolean,
    		Number: Number,
    		Object: Object,
    		Array: Array,
    		Date: Date
    	};
    	exports.validate = validate;
    	function validate(instance,schema) {
    			return validate(instance, schema, {changing: false});
    		}	exports.checkPropertyChange = function(value,schema, property) {
    			return validate(value, schema, {changing: property || "property"});
    		};
    	var validate = exports._validate = function(instance,schema,options) {
    		if (!options) options = {};
    		var _changing = options.changing;
    		function getType(schema){
    			return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
    		}
    		var errors = [];
    		function checkProp(value, schema, path,i){
    			var l;
    			path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
    			function addError(message){
    				errors.push({property:path,message:message});
    			}
    			if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
    				if(typeof schema == 'function'){
    					if(!(value instanceof schema)){
    						addError("is not an instance of the class/constructor " + schema.name);
    					}
    				}else if(schema){
    					addError("Invalid schema/property definition " + schema);
    				}
    				return null;
    			}
    			if(_changing && schema.readonly){
    				addError("is a readonly field, it can not be changed");
    			}
    			if(schema['extends']){
    				checkProp(value,schema['extends'],path,i);
    			}
    			function checkType(type,value){
    				if(type){
    					if(typeof type == 'string' && type != 'any' &&
    							(type == 'null' ? value !== null : typeof value != type) &&
    							!(value instanceof Array && type == 'array') &&
    							!(value instanceof Date && type == 'date') &&
    							!(type == 'integer' && value%1===0)){
    						return [{property:path,message:value + " - " + (typeof value) + " value found, but a " + type + " is required"}];
    					}
    					if(type instanceof Array){
    						var unionErrors=[];
    						for(var j = 0; j < type.length; j++){
    							if(!(unionErrors=checkType(type[j],value)).length){
    								break;
    							}
    						}
    						if(unionErrors.length){
    							return unionErrors;
    						}
    					}else if(typeof type == 'object'){
    						var priorErrors = errors;
    						errors = [];
    						checkProp(value,type,path);
    						var theseErrors = errors;
    						errors = priorErrors;
    						return theseErrors;
    					}
    				}
    				return [];
    			}
    			if(value === undefined){
    				if(schema.required){
    					addError("is missing and it is required");
    				}
    			}else {
    				errors = errors.concat(checkType(getType(schema),value));
    				if(schema.disallow && !checkType(schema.disallow,value).length){
    					addError(" disallowed value was matched");
    				}
    				if(value !== null){
    					if(value instanceof Array){
    						if(schema.items){
    							var itemsIsArray = schema.items instanceof Array;
    							var propDef = schema.items;
    							for (i = 0, l = value.length; i < l; i += 1) {
    								if (itemsIsArray)
    									propDef = schema.items[i];
    								if (options.coerce)
    									value[i] = options.coerce(value[i], propDef);
    								errors.concat(checkProp(value[i],propDef,path,i));
    							}
    						}
    						if(schema.minItems && value.length < schema.minItems){
    							addError("There must be a minimum of " + schema.minItems + " in the array");
    						}
    						if(schema.maxItems && value.length > schema.maxItems){
    							addError("There must be a maximum of " + schema.maxItems + " in the array");
    						}
    					}else if(schema.properties || schema.additionalProperties){
    						errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
    					}
    					if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
    						addError("does not match the regex pattern " + schema.pattern);
    					}
    					if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
    						addError("may only be " + schema.maxLength + " characters long");
    					}
    					if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
    						addError("must be at least " + schema.minLength + " characters long");
    					}
    					if(typeof schema.minimum !== 'undefined' && typeof value == typeof schema.minimum &&
    							schema.minimum > value){
    						addError("must have a minimum value of " + schema.minimum);
    					}
    					if(typeof schema.maximum !== 'undefined' && typeof value == typeof schema.maximum &&
    							schema.maximum < value){
    						addError("must have a maximum value of " + schema.maximum);
    					}
    					if(schema['enum']){
    						var enumer = schema['enum'];
    						l = enumer.length;
    						var found;
    						for(var j = 0; j < l; j++){
    							if(enumer[j]===value){
    								found=1;
    								break;
    							}
    						}
    						if(!found){
    							addError("does not have a value in the enumeration " + enumer.join(", "));
    						}
    					}
    					if(typeof schema.maxDecimal == 'number' &&
    						(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
    						addError("may only have " + schema.maxDecimal + " digits of decimal places");
    					}
    				}
    			}
    			return null;
    		}
    		function checkObj(instance,objTypeDef,path,additionalProp){
    			if(typeof objTypeDef =='object'){
    				if(typeof instance != 'object' || instance instanceof Array){
    					errors.push({property:path,message:"an object is required"});
    				}
    				for(var i in objTypeDef){
    					if(objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor'){
    						var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
    						if (value === undefined && options.existingOnly) continue;
    						var propDef = objTypeDef[i];
    						if(value === undefined && propDef["default"]){
    							value = instance[i] = propDef["default"];
    						}
    						if(options.coerce && i in instance){
    							value = instance[i] = options.coerce(value, propDef);
    						}
    						checkProp(value,propDef,path,i);
    					}
    				}
    			}
    			for(i in instance){
    				if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
    					if (options.filter) {
    						delete instance[i];
    						continue;
    					} else {
    						errors.push({property:path,message:"The property " + i +
    							" is not defined in the schema and the schema does not allow additional properties"});
    					}
    				}
    				var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
    				if(requires && !(requires in instance)){
    					errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
    				}
    				value = instance[i];
    				if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
    					if(options.coerce){
    						value = instance[i] = options.coerce(value, additionalProp);
    					}
    					checkProp(value,additionalProp,path,i);
    				}
    				if(!_changing && value && value.$schema){
    					errors = errors.concat(checkProp(value,value.$schema,path,i));
    				}
    			}
    			return errors;
    		}
    		if(schema){
    			checkProp(instance,schema,'',_changing || '');
    		}
    		if(!_changing && instance && instance.$schema){
    			checkProp(instance,instance.$schema,'','');
    		}
    		return {valid:!errors.length,errors:errors};
    	};
    	exports.mustBeValid = function(result){
    		if(!result.valid){
    			throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
    		}
    	};
    	return exports;
    	}));
    } (validate));

    var mod_assert = assert_1;
    var mod_extsprintf = extsprintf$1;
    var mod_verror = verror;
    var mod_jsonschema = validate.exports;
    jsprim$1.deepCopy = deepCopy;
    jsprim$1.deepEqual = deepEqual;
    jsprim$1.isEmpty = isEmpty;
    jsprim$1.hasKey = hasKey;
    jsprim$1.forEachKey = forEachKey;
    jsprim$1.pluck = pluck;
    jsprim$1.flattenObject = flattenObject;
    jsprim$1.flattenIter = flattenIter;
    jsprim$1.validateJsonObject = validateJsonObjectJS;
    jsprim$1.validateJsonObjectJS = validateJsonObjectJS;
    jsprim$1.randElt = randElt;
    jsprim$1.extraProperties = extraProperties;
    jsprim$1.mergeObjects = mergeObjects;
    jsprim$1.startsWith = startsWith;
    jsprim$1.endsWith = endsWith;
    jsprim$1.parseInteger = parseInteger;
    jsprim$1.iso8601 = iso8601;
    jsprim$1.rfc1123 = rfc1123;
    jsprim$1.parseDateTime = parseDateTime;
    jsprim$1.hrtimediff = hrtimeDiff;
    jsprim$1.hrtimeDiff = hrtimeDiff;
    jsprim$1.hrtimeAccum = hrtimeAccum;
    jsprim$1.hrtimeAdd = hrtimeAdd;
    jsprim$1.hrtimeNanosec = hrtimeNanosec;
    jsprim$1.hrtimeMicrosec = hrtimeMicrosec;
    jsprim$1.hrtimeMillisec = hrtimeMillisec;
    function deepCopy(obj)
    {
    	var ret, key;
    	var marker = '__deepCopy';
    	if (obj && obj[marker])
    		throw (new Error('attempted deep copy of cyclic object'));
    	if (obj && obj.constructor == Object) {
    		ret = {};
    		obj[marker] = true;
    		for (key in obj) {
    			if (key == marker)
    				continue;
    			ret[key] = deepCopy(obj[key]);
    		}
    		delete (obj[marker]);
    		return (ret);
    	}
    	if (obj && obj.constructor == Array) {
    		ret = [];
    		obj[marker] = true;
    		for (key = 0; key < obj.length; key++)
    			ret.push(deepCopy(obj[key]));
    		delete (obj[marker]);
    		return (ret);
    	}
    	return (obj);
    }
    function deepEqual(obj1, obj2)
    {
    	if (typeof (obj1) != typeof (obj2))
    		return (false);
    	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
    		return (obj1 === obj2);
    	if (obj1.constructor != obj2.constructor)
    		return (false);
    	var k;
    	for (k in obj1) {
    		if (!obj2.hasOwnProperty(k))
    			return (false);
    		if (!deepEqual(obj1[k], obj2[k]))
    			return (false);
    	}
    	for (k in obj2) {
    		if (!obj1.hasOwnProperty(k))
    			return (false);
    	}
    	return (true);
    }
    function isEmpty(obj)
    {
    	var key;
    	for (key in obj)
    		return (false);
    	return (true);
    }
    function hasKey(obj, key)
    {
    	mod_assert.equal(typeof (key), 'string');
    	return (Object.prototype.hasOwnProperty.call(obj, key));
    }
    function forEachKey(obj, callback)
    {
    	for (var key in obj) {
    		if (hasKey(obj, key)) {
    			callback(key, obj[key]);
    		}
    	}
    }
    function pluck(obj, key)
    {
    	mod_assert.equal(typeof (key), 'string');
    	return (pluckv(obj, key));
    }
    function pluckv(obj, key)
    {
    	if (obj === null || typeof (obj) !== 'object')
    		return (undefined);
    	if (obj.hasOwnProperty(key))
    		return (obj[key]);
    	var i = key.indexOf('.');
    	if (i == -1)
    		return (undefined);
    	var key1 = key.substr(0, i);
    	if (!obj.hasOwnProperty(key1))
    		return (undefined);
    	return (pluckv(obj[key1], key.substr(i + 1)));
    }
    function flattenIter(data, depth, callback)
    {
    	doFlattenIter(data, depth, [], callback);
    }
    function doFlattenIter(data, depth, accum, callback)
    {
    	var each;
    	var key;
    	if (depth === 0) {
    		each = accum.slice(0);
    		each.push(data);
    		callback(each);
    		return;
    	}
    	mod_assert.ok(data !== null);
    	mod_assert.equal(typeof (data), 'object');
    	mod_assert.equal(typeof (depth), 'number');
    	mod_assert.ok(depth >= 0);
    	for (key in data) {
    		each = accum.slice(0);
    		each.push(key);
    		doFlattenIter(data[key], depth - 1, each, callback);
    	}
    }
    function flattenObject(data, depth)
    {
    	if (depth === 0)
    		return ([ data ]);
    	mod_assert.ok(data !== null);
    	mod_assert.equal(typeof (data), 'object');
    	mod_assert.equal(typeof (depth), 'number');
    	mod_assert.ok(depth >= 0);
    	var rv = [];
    	var key;
    	for (key in data) {
    		flattenObject(data[key], depth - 1).forEach(function (p) {
    			rv.push([ key ].concat(p));
    		});
    	}
    	return (rv);
    }
    function startsWith(str, prefix)
    {
    	return (str.substr(0, prefix.length) == prefix);
    }
    function endsWith(str, suffix)
    {
    	return (str.substr(
    	    str.length - suffix.length, suffix.length) == suffix);
    }
    function iso8601(d)
    {
    	if (typeof (d) == 'number')
    		d = new Date(d);
    	mod_assert.ok(d.constructor === Date);
    	return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
    	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
    	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
    	    d.getUTCMilliseconds()));
    }
    var RFC1123_MONTHS = [
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var RFC1123_DAYS = [
        'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    function rfc1123(date) {
    	return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
    	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
    	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
    	    date.getUTCHours(), date.getUTCMinutes(),
    	    date.getUTCSeconds()));
    }
    function parseDateTime(str)
    {
    	var numeric = +str;
    	if (!isNaN(numeric)) {
    		return (new Date(numeric));
    	} else {
    		return (new Date(str));
    	}
    }
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var PI_DEFAULTS = {
    	base: 10,
    	allowSign: true,
    	allowPrefix: false,
    	allowTrailing: false,
    	allowImprecise: false,
    	trimWhitespace: false,
    	leadingZeroIsOctal: false
    };
    var CP_0 = 0x30;
    var CP_9 = 0x39;
    var CP_A = 0x41;
    var CP_B = 0x42;
    var CP_O = 0x4f;
    var CP_T = 0x54;
    var CP_X = 0x58;
    var CP_Z = 0x5a;
    var CP_a = 0x61;
    var CP_b = 0x62;
    var CP_o = 0x6f;
    var CP_t = 0x74;
    var CP_x = 0x78;
    var CP_z = 0x7a;
    var PI_CONV_DEC = 0x30;
    var PI_CONV_UC = 0x37;
    var PI_CONV_LC = 0x57;
    function parseInteger(str, uopts)
    {
    	mod_assert.string(str, 'str');
    	mod_assert.optionalObject(uopts, 'options');
    	var baseOverride = false;
    	var options = PI_DEFAULTS;
    	if (uopts) {
    		baseOverride = hasKey(uopts, 'base');
    		options = mergeObjects(options, uopts);
    		mod_assert.number(options.base, 'options.base');
    		mod_assert.ok(options.base >= 2, 'options.base >= 2');
    		mod_assert.ok(options.base <= 36, 'options.base <= 36');
    		mod_assert.bool(options.allowSign, 'options.allowSign');
    		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
    		mod_assert.bool(options.allowTrailing,
    		    'options.allowTrailing');
    		mod_assert.bool(options.allowImprecise,
    		    'options.allowImprecise');
    		mod_assert.bool(options.trimWhitespace,
    		    'options.trimWhitespace');
    		mod_assert.bool(options.leadingZeroIsOctal,
    		    'options.leadingZeroIsOctal');
    		if (options.leadingZeroIsOctal) {
    			mod_assert.ok(!baseOverride,
    			    '"base" and "leadingZeroIsOctal" are ' +
    			    'mutually exclusive');
    		}
    	}
    	var c;
    	var pbase = -1;
    	var base = options.base;
    	var start;
    	var mult = 1;
    	var value = 0;
    	var idx = 0;
    	var len = str.length;
    	if (options.trimWhitespace) {
    		while (idx < len && isSpace(str.charCodeAt(idx))) {
    			++idx;
    		}
    	}
    	if (options.allowSign) {
    		if (str[idx] === '-') {
    			idx += 1;
    			mult = -1;
    		} else if (str[idx] === '+') {
    			idx += 1;
    		}
    	}
    	if (str[idx] === '0') {
    		if (options.allowPrefix) {
    			pbase = prefixToBase(str.charCodeAt(idx + 1));
    			if (pbase !== -1 && (!baseOverride || pbase === base)) {
    				base = pbase;
    				idx += 2;
    			}
    		}
    		if (pbase === -1 && options.leadingZeroIsOctal) {
    			base = 8;
    		}
    	}
    	for (start = idx; idx < len; ++idx) {
    		c = translateDigit(str.charCodeAt(idx));
    		if (c !== -1 && c < base) {
    			value *= base;
    			value += c;
    		} else {
    			break;
    		}
    	}
    	if (start === idx) {
    		return (new Error('invalid number: ' + JSON.stringify(str)));
    	}
    	if (options.trimWhitespace) {
    		while (idx < len && isSpace(str.charCodeAt(idx))) {
    			++idx;
    		}
    	}
    	if (idx < len && !options.allowTrailing) {
    		return (new Error('trailing characters after number: ' +
    		    JSON.stringify(str.slice(idx))));
    	}
    	if (value === 0) {
    		return (0);
    	}
    	var result = value * mult;
    	if (!options.allowImprecise &&
    	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
    		return (new Error('number is outside of the supported range: ' +
    		    JSON.stringify(str.slice(start, idx))));
    	}
    	return (result);
    }
    function translateDigit(d)
    {
    	if (d >= CP_0 && d <= CP_9) {
    		return (d - PI_CONV_DEC);
    	} else if (d >= CP_A && d <= CP_Z) {
    		return (d - PI_CONV_UC);
    	} else if (d >= CP_a && d <= CP_z) {
    		return (d - PI_CONV_LC);
    	} else {
    		return (-1);
    	}
    }
    function isSpace(c)
    {
    	return (c === 0x20) ||
    	    (c >= 0x0009 && c <= 0x000d) ||
    	    (c === 0x00a0) ||
    	    (c === 0x1680) ||
    	    (c === 0x180e) ||
    	    (c >= 0x2000 && c <= 0x200a) ||
    	    (c === 0x2028) ||
    	    (c === 0x2029) ||
    	    (c === 0x202f) ||
    	    (c === 0x205f) ||
    	    (c === 0x3000) ||
    	    (c === 0xfeff);
    }
    function prefixToBase(c)
    {
    	if (c === CP_b || c === CP_B) {
    		return (2);
    	} else if (c === CP_o || c === CP_O) {
    		return (8);
    	} else if (c === CP_t || c === CP_T) {
    		return (10);
    	} else if (c === CP_x || c === CP_X) {
    		return (16);
    	} else {
    		return (-1);
    	}
    }
    function validateJsonObjectJS(schema, input)
    {
    	var report = mod_jsonschema.validate(input, schema);
    	if (report.errors.length === 0)
    		return (null);
    	var error = report.errors[0];
    	var propname = error['property'];
    	var reason = error['message'].toLowerCase();
    	var i, j;
    	if ((i = reason.indexOf('the property ')) != -1 &&
    	    (j = reason.indexOf(' is not defined in the schema and the ' +
    	    'schema does not allow additional properties')) != -1) {
    		i += 'the property '.length;
    		if (propname === '')
    			propname = reason.substr(i, j - i);
    		else
    			propname = propname + '.' + reason.substr(i, j - i);
    		reason = 'unsupported property';
    	}
    	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    	rv.jsv_details = error;
    	return (rv);
    }
    function randElt(arr)
    {
    	mod_assert.ok(Array.isArray(arr) && arr.length > 0,
    	    'randElt argument must be a non-empty array');
    	return (arr[Math.floor(Math.random() * arr.length)]);
    }
    function assertHrtime(a)
    {
    	mod_assert.ok(a[0] >= 0 && a[1] >= 0,
    	    'negative numbers not allowed in hrtimes');
    	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
    }
    function hrtimeDiff(a, b)
    {
    	assertHrtime(a);
    	assertHrtime(b);
    	mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
    	    'negative differences not allowed');
    	var rv = [ a[0] - b[0], 0 ];
    	if (a[1] >= b[1]) {
    		rv[1] = a[1] - b[1];
    	} else {
    		rv[0]--;
    		rv[1] = 1e9 - (b[1] - a[1]);
    	}
    	return (rv);
    }
    function hrtimeNanosec(a)
    {
    	assertHrtime(a);
    	return (Math.floor(a[0] * 1e9 + a[1]));
    }
    function hrtimeMicrosec(a)
    {
    	assertHrtime(a);
    	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
    }
    function hrtimeMillisec(a)
    {
    	assertHrtime(a);
    	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
    }
    function hrtimeAccum(a, b)
    {
    	assertHrtime(a);
    	assertHrtime(b);
    	a[1] += b[1];
    	if (a[1] >= 1e9) {
    		a[0]++;
    		a[1] -= 1e9;
    	}
    	a[0] += b[0];
    	return (a);
    }
    function hrtimeAdd(a, b)
    {
    	assertHrtime(a);
    	var rv = [ a[0], a[1] ];
    	return (hrtimeAccum(rv, b));
    }
    function extraProperties(obj, allowed)
    {
    	mod_assert.ok(typeof (obj) === 'object' && obj !== null,
    	    'obj argument must be a non-null object');
    	mod_assert.ok(Array.isArray(allowed),
    	    'allowed argument must be an array of strings');
    	for (var i = 0; i < allowed.length; i++) {
    		mod_assert.ok(typeof (allowed[i]) === 'string',
    		    'allowed argument must be an array of strings');
    	}
    	return (Object.keys(obj).filter(function (key) {
    		return (allowed.indexOf(key) === -1);
    	}));
    }
    function mergeObjects(provided, overrides, defaults)
    {
    	var rv, k;
    	rv = {};
    	if (defaults) {
    		for (k in defaults)
    			rv[k] = defaults[k];
    	}
    	if (provided) {
    		for (k in provided)
    			rv[k] = provided[k];
    	}
    	if (overrides) {
    		for (k in overrides)
    			rv[k] = overrides[k];
    	}
    	return (rv);
    }

    var assert = assert_1;
    var jsprim = jsprim$1;
    var util$1 = require$$2;
    function ParseError(input, message, index) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
      this.input = input;
      this.message = message;
      if (index !== undefined) {
        this.message += ' at index ' + index;
      }
    }
    util$1.inherits(ParseError, Error);
    function modulo(a, n) {
      return (n + (a % n)) % n;
    }
    function _arrayToOctetString(input) {
      var out;
      out = (input[0] >> 8) + '.' + (input[0] & 0xff) + '.';
      out += (input[1] >> 8) + '.' + (input[1] & 0xff);
      return out;
    }
    function _isAddr(addr) {
      if (typeof (addr) === 'object') {
        if (Array.isArray(addr._fields) && typeof (addr._attrs) === 'object') {
          return true;
        }
      }
      return false;
    }
    function _toAddr(input) {
      if (typeof (input) === 'string') {
        return ip6addrParse(input);
      } else if (_isAddr(input)) {
        return input;
      } else {
        throw new Error('Invalid argument: Addr or parsable string expected');
      }
    }
    function _arrayToHex(input, zeroElide, zeroPad) {
      var i;
      var elStart = null;
      var elLen = 0;
      if (zeroElide) {
        var start = null;
        var len = null;
        for (i = 0; i < input.length; i++) {
          if (input[i] === 0) {
            if (start === null) {
              start = i;
              len = 1;
            } else {
              len++;
            }
          } else if (start !== null) {
            if (len > elLen) {
              elStart = start;
              elLen = len;
            }
            start = null;
          }
        }
        if (start !== null && len > elLen) {
          elStart = start;
          elLen = len;
        }
      }
      var output = [];
      var num;
      for (i = 0; i < input.length; i++) {
        if (elStart !== null) {
          if (i === elStart) {
            if (elLen === 8) {
              return ['::'];
            } else if (elStart === 0 || elStart + elLen === input.length) {
              output.push(':');
            } else {
              output.push('');
            }
          }
          if (i >= elStart && i < elStart + elLen) {
            continue;
          }
        }
        num = input[i].toString(16);
        if (zeroPad && num.length != 4) {
          num = '0000'.slice(num.length) + num;
        }
        output.push(num);
      }
      return output;
    }
    function _ipv4Mapped(input) {
      var comp = [0, 0, 0, 0, 0, 0xffff];
      var i;
      for (i = 0; i < 6; i++) {
        if (input[i] != comp[i])
          return false;
      }
      return true;
    }
    function _prefixToAddr(len) {
      assert.number(len);
      len = len | 0;
      assert.ok(len <= 128);
      assert.ok(len >= 0);
      var output = new Addr();
      var i;
      for (i = 0; len > 16; i++, len -= 16) {
        output._fields[i] = 0xffff;
      }
      if (len > 0) {
        output._fields[i] = 0xffff - ((1 << (16 - len)) - 1);
      }
      return output;
    }
    function _toCIDR(input) {
      if (typeof (input) === 'string') {
        return new CIDR(input);
      } else if (input instanceof CIDR) {
        return input;
      } else {
        throw new Error('Invalid argument: CIDR or parsable string expected');
      }
    }
    var strDefaults = {
      format: 'auto',
      zeroElide: true,
      zeroPad: false
    };
    function getStrOpt(opts, name) {
      if (opts && opts.hasOwnProperty(name)) {
        return opts[name];
      } else {
        return strDefaults[name];
      }
    }
    function Addr() {
      this._fields = [0, 0, 0, 0, 0, 0, 0, 0];
      this._attrs = {};
    }
    Addr.prototype.kind = function getKind() {
      if (v4subnet.contains(this)) {
        return 'ipv4';
      } else {
        return 'ipv6';
      }
    };
    Addr.prototype.toString = function toString(opts) {
      assert.optionalObject(opts, 'opts');
      var format = getStrOpt(opts, 'format');
      var zeroElide = getStrOpt(opts, 'zeroElide');
      var zeroPad = getStrOpt(opts, 'zeroPad');
      assert.string(format, 'opts.format');
      assert.bool(zeroElide, 'opts.zeroElide');
      assert.bool(zeroPad, 'opts.zeroPad');
      if (format === 'auto') {
        if (this._attrs.ipv4Bare) {
          format = 'v4';
        } else if (this._attrs.ipv4Mapped) {
          format = 'v4-mapped';
        } else {
          format = 'v6';
        }
      }
      switch (format) {
      case 'v4':
        if (!v4subnet.contains(this)) {
            throw new Error('cannot print non-v4 address in dotted quad notation');
        }
        return _arrayToOctetString(this._fields.slice(6));
      case 'v4-mapped':
        if (!v4subnet.contains(this)) {
            throw new Error('cannot print non-v4 address as a v4-mapped address');
        }
        var output = _arrayToHex(this._fields.slice(0, 6), zeroElide, zeroPad);
        output.push(_arrayToOctetString(this._fields.slice(6)));
        return output.join(':');
      case 'v6':
        return _arrayToHex(this._fields, zeroElide, zeroPad).join(':');
      default:
        throw new Error('unrecognized format method "' + format + '"');
      }
    };
    Addr.prototype.toBuffer = function toBuffer(buf) {
      if (buf !== undefined) {
        if (!isBuffer$2(buf)) {
          throw new Error('optional arg must be Buffer');
        }
      } else {
        buf = new Buffer$1(16);
      }
      var i;
      for (i = 0; i < 8; i++) {
        buf.writeUInt16BE(this._fields[i], i*2);
      }
      return buf;
    };
    Addr.prototype.toLong = function toLong() {
      if (!v4subnet.contains(this)) {
        throw new Error('only possible for ipv4-mapped addresses');
      }
      return ((this._fields[6] << 16) >>> 0) + this._fields[7];
    };
    Addr.prototype.clone = function cloneAddr() {
      var out = new Addr();
      out._fields = this._fields.slice();
      for (var k in this._attrs) {
          out._attrs[k] = this._attrs[k];
      }
      return out;
    };
    Addr.prototype.offset = function offset(num) {
      if (num < -4294967295 || num > 4294967295) {
        throw new Error('offsets should be between -4294967295 and 4294967295');
      }
      var out = this.clone();
      var i, moved;
      for (i = 7; i >= 0; i--) {
        moved = out._fields[i] + num;
        if (moved > 65535) {
          num = moved >>> 16;
          moved = moved & 0xffff;
        } else if (moved < 0) {
          num = Math.floor(moved / (1 << 16));
          moved = modulo(moved, 1 << 16);
        } else {
          num = 0;
        }
        out._fields[i] = moved;
        if (num !== 0) {
          if ((i === 0) || (i === 6 && this._attrs.ipv4Mapped)) {
            return null;
          }
        } else {
          break;
        }
      }
      return out;
    };
    Addr.prototype.and = function addrAnd(input) {
      input = _toAddr(input);
      var i;
      var output = this.clone();
      for (i = 0; i < 8; i++) {
        output._fields[i] = output._fields[i] & input._fields[i];
      }
      return output;
    };
    Addr.prototype.or = function addrOr(input) {
      input = _toAddr(input);
      var i;
      var output = this.clone();
      for (i = 0; i < 8; i++) {
        output._fields[i] = output._fields[i] | input._fields[i];
      }
      return output;
    };
    Addr.prototype.not = function addrNot() {
      var i;
      var output = this.clone();
      for (i = 0; i < 8; i++) {
        output._fields[i] = (~ output._fields[i]) & 0xffff;
      }
      return output;
    };
    Addr.prototype.compare = function compareMember(addr) {
      return ip6addrCompare(this, addr);
    };
    function CIDR(addr, prefixLen) {
      if (prefixLen === undefined) {
        assert.string(addr);
        var fields = addr.match(/^([a-fA-F0-9:.]+)\/([0-9]+)$/);
        if (fields === null) {
          throw new Error('Invalid argument: <addr>/<prefix> expected');
        }
        addr = fields[1];
        prefixLen = parseInt(fields[2], 10);
      }
      assert.number(prefixLen);
      prefixLen = prefixLen | 0;
      addr = _toAddr(addr);
      if (addr._attrs.ipv4Bare) {
        prefixLen += 96;
      }
      if (prefixLen < 0 || prefixLen > 128) {
        throw new Error('Invalid prefix length');
      }
      this._prefix = prefixLen;
      this._mask = _prefixToAddr(prefixLen);
      this._addr = addr.and(this._mask);
    }
    CIDR.prototype.contains = function cidrContains(input) {
      input = _toAddr(input);
      return (this._addr.compare(input.and(this._mask)) === 0);
    };
    CIDR.prototype.first = function cidrFirst() {
      if (this._prefix >= 127) {
        return this._addr;
      } else {
        return this._addr.offset(1);
      }
    };
    CIDR.prototype.last = function cidrLast() {
      var ending = this._addr.or(this._mask.not());
      if (this._prefix >= 127) {
        return ending;
      } else {
        if (this._addr._attrs.ipv4Mapped) {
          return ending.offset(-1);
        } else {
          return ending;
        }
      }
    };
    CIDR.prototype.broadcast = function getBroadcast() {
      if (!v4subnet.contains(this._addr)) {
        throw new Error('Only IPv4 networks have broadcast addresses');
      }
      return this._addr.or(this._mask.not());
    };
    CIDR.prototype.compare = function compareCIDR(cidr) {
      return ip6cidrCompare(this, cidr);
    };
    CIDR.prototype.prefixLength = function getPrefixLength(format) {
      assert.optionalString(format, 'format');
      if (format === undefined || format === 'auto') {
        format = this._addr._attrs.ipv4Bare ? 'v4' : 'v6';
      }
      switch (format) {
      case 'v4':
        if (!v4subnet.contains(this._addr)) {
            throw new Error('cannot return v4 prefix length for non-v4 address');
        }
        return this._prefix - 96;
      case 'v6':
        return this._prefix;
      default:
        throw new Error('unrecognized format method "' + format + '"');
      }
    };
    CIDR.prototype.address = function getAddressComponent() {
      return this._addr;
    };
    CIDR.prototype.toString = function cidrString(opts) {
      assert.optionalObject(opts, 'opts');
      var format = getStrOpt(opts, 'format');
      if (format === 'v4-mapped') {
        format = 'v6';
      }
      return this._addr.toString(opts) + '/' + this.prefixLength(format);
    };
    var v4subnet = new CIDR('::ffff:0:0', 96);
    function ip6cidrCompare(a, b) {
      a = _toCIDR(a);
      b = _toCIDR(b);
      var cmp = ip6addrCompare(a._addr, b._addr);
      return cmp === 0 ? b._prefix - a._prefix : cmp;
    }
    function AddrRange(begin, end) {
      begin = _toAddr(begin);
      end = _toAddr(end);
      if (begin.compare(end) > 0) {
        throw new Error('begin address must be <= end address');
      }
      this._begin = begin;
      this._end = end;
    }
    AddrRange.prototype.contains = function addrRangeContains(input) {
      input = _toAddr(input);
      return (this._begin.compare(input) <= 0 && this._end.compare(input) >= 0);
    };
    AddrRange.prototype.first = function addrRangeFirst() {
      return this._begin;
    };
    AddrRange.prototype.last = function addrRangeLast() {
      return this._end;
    };
    function ip6addrParse(input) {
      if (typeof (input) === 'string') {
        return parseString(input);
      } else if (typeof (input) === 'number') {
        return parseLong(input);
      } else if (typeof (input) === 'object' && _isAddr(input)) {
        return input;
      } else {
        throw new Error('Invalid argument: only string|number allowed');
      }
    }
    function parseString(input) {
      assert.string(input);
      input = input.toLowerCase();
      var result = new Addr();
      var ip6Fields = [];
      var ip4Fields = [];
      var expIndex = null;
      var value = '';
      var i, c;
      if (input.length > 40) {
        throw new ParseError(input, 'Input too long');
      }
      for (i = 0; i < input.length; i++) {
        c = input[i];
        if (c === ':') {
          if ((i+1) < input.length && input[i+1] === ':') {
            if (expIndex !== null) {
              throw new ParseError(input, 'Multiple :: delimiters', i);
            }
            if (value !== '') {
              ip6Fields.push(value);
              value = '';
            }
            expIndex = ip6Fields.length;
            i++;
          } else {
            if (value === '') {
              throw new ParseError(input, 'illegal delimiter', i);
            }
            ip6Fields.push(value);
            value = '';
          }
        } else if (c === '.') {
          ip4Fields.push(value);
          value = '';
        } else {
          value = value + c;
        }
      }
      if (value !== '') {
        if (ip4Fields.length !== 0) {
          ip4Fields.push(value);
        } else {
          ip6Fields.push(value);
        }
        value = '';
      } else {
        if (expIndex !== ip6Fields.length || ip4Fields.length > 0) {
          throw new ParseError(input, 'Cannot end with delimiter besides ::');
        }
      }
      if (ip4Fields.length === 0) {
        if (ip6Fields.length > 8) {
          throw new ParseError(input, 'Too many fields');
        } else if (ip6Fields.length < 8 && expIndex === null) {
          throw new ParseError(input, 'Too few fields');
        }
      } else {
        if (ip4Fields.length !== 4) {
          throw new ParseError(input, 'IPv4 portion must have 4 fields');
        }
        if (ip6Fields.length === 0 && expIndex === null) {
          result._attrs.ipv4Bare = true;
          ip6Fields = ['ffff'];
          expIndex = 0;
        }
        if (ip6Fields.length > 6) {
          throw new ParseError(input, 'Too many fields');
        } else if (ip6Fields.length < 6 && expIndex === null) {
          throw new ParseError(input, 'Too few fields');
        }
      }
      var field, num;
      for (i = 0; i < ip6Fields.length; i++) {
        field = ip6Fields[i];
        num = jsprim.parseInteger(field, { base: 16, allowSign: false });
        if (num instanceof Error || num < 0 || num > 65535) {
          throw new ParseError(input, 'Invalid field value: ' + field);
        }
        ip6Fields[i] = num;
      }
      for (i = 0; i < ip4Fields.length; i++) {
        field = ip4Fields[i];
        num = jsprim.parseInteger(field, { base: 10, allowSign: false });
        if (num instanceof Error || num < 0 || num > 255) {
          throw new ParseError(input, 'Invalid field value: ' + field);
        }
        ip4Fields[i] = num;
      }
      if (ip4Fields.length !== 0) {
        ip6Fields.push((ip4Fields[0]*256) + ip4Fields[1]);
        ip6Fields.push((ip4Fields[2]*256) + ip4Fields[3]);
      }
      if (ip6Fields.length < 8 && expIndex !== null) {
        var filler = [];
        for (i = 0; i < (8 - ip6Fields.length); i++) {
          filler.push(0);
        }
        ip6Fields = Array.prototype.concat(
          ip6Fields.slice(0, expIndex),
          filler,
          ip6Fields.slice(expIndex)
        );
      }
      if (ip4Fields.length !== 0) {
        if (!_ipv4Mapped(ip6Fields)) {
          throw new ParseError(input, 'invalid dotted-quad notation');
        } else {
          result._attrs.ipv4Mapped = true;
        }
      }
      result._fields = ip6Fields;
      return result;
    }
    function parseLong(input) {
      assert.number(input);
      if (input !== Math.floor(input)) {
        throw new Error('Value must be integer');
      }
      if (input < 0 || input > 0xffffffff) {
        throw new Error('Value must be 32 bit');
      }
      var out = new Addr();
      out._fields[7] = input & 0xffff;
      out._fields[6] = (input >>> 16);
      out._fields[5] = 0xffff;
      out._attrs.ipv4Bare = true;
      out._attrs.ipv4Mapped = true;
      return out;
    }
    function ip6addrCompare(a, b) {
      a = _toAddr(a);
      b = _toAddr(b);
      var i;
      for (i = 0; i < 8; i++) {
        if (a._fields[i] < b._fields[i]) {
          return -1;
        } else if (a._fields[i] > b._fields[i]) {
          return 1;
        }
      }
      return 0;
    }
    var ip6addr = {
      parse: ip6addrParse,
      compare: ip6addrCompare,
      createCIDR: function (addr, len) {
        return new CIDR(addr, len);
      },
      compareCIDR: ip6cidrCompare,
      createAddrRange: function (begin, end) {
        return new AddrRange(begin, end);
      }
    };

    /**
     * This is the base class representing double values modifiers
     */
    var BaseValuesModifier = /** @class */ (function () {
        /**
         * Parses the values string
         *
         * @param values - values string
         *
         * @throws an error if the string is empty or invalid
         */
        function BaseValuesModifier(values) {
            /**
             * Separator between values
             */
            this.SEPARATOR = '|';
            if (!values) {
                throw new SyntaxError('Modifier cannot be empty');
            }
            this.value = values;
            var permittedValues = [];
            var restrictedValues = [];
            var parts = values.split(this.SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var app = parts[i];
                var restricted = false;
                if (app.startsWith('~')) {
                    restricted = true;
                    app = app.substring(1).trim();
                }
                if (app === '') {
                    throw new SyntaxError("Empty values specified in \"".concat(values, "\""));
                }
                if (restricted) {
                    restrictedValues.push(app);
                }
                else {
                    permittedValues.push(app);
                }
            }
            this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
            this.permitted = permittedValues.length > 0 ? permittedValues : null;
        }
        BaseValuesModifier.prototype.getPermitted = function () {
            return this.permitted;
        };
        BaseValuesModifier.prototype.getRestricted = function () {
            return this.restricted;
        };
        BaseValuesModifier.prototype.getValue = function () {
            return this.value;
        };
        BaseValuesModifier.prototype.match = function (value) {
            if (!this.restricted && !this.permitted) {
                return true;
            }
            if (this.restricted && this.restricted.includes(value)) {
                return false;
            }
            if (this.permitted) {
                return this.permitted.includes(value);
            }
            return true;
        };
        return BaseValuesModifier;
    }());

    /**
     * Netmasks class
     */
    var NetmasksCollection = /** @class */ (function () {
        function NetmasksCollection() {
            this.ipv4Masks = [];
            this.ipv6Masks = [];
        }
        /**
         * Returns true if any of the containing masks contains provided value
         *
         * @param value
         */
        NetmasksCollection.prototype.contains = function (value) {
            if (isIp_1.v4(value)) {
                return this.ipv4Masks.some(function (x) { return x.contains(value); });
            }
            return this.ipv6Masks.some(function (x) { return x.contains(value); });
        };
        return NetmasksCollection;
    }());
    /**
     * The client modifier allows specifying clients this rule will be working for.
     * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
     */
    var ClientModifier = /** @class */ (function (_super) {
        __extends(ClientModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function ClientModifier(value) {
            var _this = _super.call(this, value) || this;
            var permitted = _this.getPermitted();
            if (permitted) {
                _this.permitted = ClientModifier.stripValues(permitted);
                _this.permittedNetmasks = ClientModifier.parseNetmasks(_this.permitted);
            }
            var restricted = _this.getRestricted();
            if (restricted) {
                _this.restricted = ClientModifier.stripValues(restricted);
                _this.restrictedNetmasks = ClientModifier.parseNetmasks(_this.restricted);
            }
            return _this;
        }
        /**
         * Unquotes and unescapes string
         *
         * @param values
         */
        ClientModifier.stripValues = function (values) {
            return values.map(function (v) {
                if ((v.startsWith('"') && v.endsWith('"'))
                    || (v.startsWith('\'') && v.endsWith('\''))) {
                    // eslint-disable-next-line no-param-reassign
                    v = v.substr(1, v.length - 2);
                }
                return v.replace(/\\/ig, '');
            });
        };
        /**
         * Checks if this modifier matches provided params
         *
         * @param clientName
         * @param clientIP
         */
        ClientModifier.prototype.matchAny = function (clientName, clientIP) {
            if (this.restricted) {
                if (clientName && this.restricted.includes(clientName)) {
                    return false;
                }
                if (clientIP && this.restricted.includes(clientIP)) {
                    return false;
                }
                return true;
            }
            if (this.restrictedNetmasks) {
                if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                    return false;
                }
                return true;
            }
            if (this.permitted) {
                if (clientName && this.permitted.includes(clientName)) {
                    return true;
                }
                if (clientIP && this.permitted.includes(clientIP)) {
                    return true;
                }
            }
            if (this.permittedNetmasks) {
                if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Parses netmasks from client's strings
         *
         * @param values
         */
        ClientModifier.parseNetmasks = function (values) {
            var result = new NetmasksCollection();
            values.forEach(function (x) {
                var cidrVersion = isCidr.exports(x);
                if (cidrVersion === 4) {
                    result.ipv4Masks.push(new Netmask_1(x));
                }
                else if (cidrVersion === 6) {
                    result.ipv6Masks.push(ip6addr.createCIDR(x));
                }
            });
            return result;
        };
        return ClientModifier;
    }(BaseValuesModifier));

    /**
     * The dnsrewrite response modifier allows replacing the content of the response
     * to the DNS request for the matching hosts.
     *
     * TODO: This modifier is not yet implemented
     * https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite
     */
    var DnsRewriteModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function DnsRewriteModifier(value) {
            this.value = value;
        }
        /**
         * Modifier value
         */
        DnsRewriteModifier.prototype.getValue = function () {
            return this.value;
        };
        return DnsRewriteModifier;
    }());

    /**
     * The dnstype modifier allows specifying DNS request type on which this rule will be triggered.
     */
    var DnsTypeModifier = /** @class */ (function (_super) {
        __extends(DnsTypeModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function DnsTypeModifier(value) {
            var _this = _super.call(this, value) || this;
            if (_this.permitted) {
                _this.restricted = null;
            }
            return _this;
        }
        return DnsTypeModifier;
    }(BaseValuesModifier));

    /**
     * The ctag modifier allows to block domains only for specific types of DNS client tags.
     */
    var CtagModifier = /** @class */ (function (_super) {
        __extends(CtagModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function CtagModifier(value) {
            var _this = _super.call(this, value) || this;
            _this.validate();
            return _this;
        }
        /**
         * Validates tag values
         */
        CtagModifier.prototype.validate = function () {
            if (!this.getValue()) {
                throw new Error('Invalid rule: Ctag modifier must not be empty');
            }
            var tags = this.permitted ? this.permitted : this.restricted;
            if (tags && tags.some(function (x) { return !CtagModifier.ALLOWED_TAGS.includes(x); })) {
                throw new Error('Invalid rule: Invalid ctag modifier');
            }
        };
        /**
         * The list of allowed tags
         */
        CtagModifier.ALLOWED_TAGS = [
            // By device type:
            'device_audio',
            'device_camera',
            'device_gameconsole',
            'device_laptop',
            'device_nas',
            'device_pc',
            'device_phone',
            'device_printer',
            'device_securityalarm',
            'device_tablet',
            'device_tv',
            'device_other',
            // By operating system:
            'os_android',
            'os_ios',
            'os_linux',
            'os_macos',
            'os_windows',
            'os_other',
            // By user group:
            'user_admin',
            'user_regular',
            'user_child',
        ];
        return CtagModifier;
    }(BaseValuesModifier));

    /**
     * Rule pattern class
     *
     * This class parses rule pattern text to simple fields.
     */
    var Pattern = /** @class */ (function () {
        /**
         * Constructor
         * @param pattern
         * @param matchcase
         */
        function Pattern(pattern, matchcase) {
            if (matchcase === void 0) { matchcase = false; }
            this.pattern = pattern;
            this.shortcut = SimpleRegex.extractShortcut(this.pattern);
            this.matchcase = matchcase;
        }
        /**
         * Checks if this rule pattern matches the specified request.
         *
         * @param request - request to check
         * @param shortcutMatched if true, it means that the request already matches
         * this pattern's shortcut and we don't need to match it again.
         * @returns true if pattern matches
         */
        Pattern.prototype.matchPattern = function (request, shortcutMatched) {
            this.prepare();
            if (this.patternShortcut) {
                return shortcutMatched || this.matchShortcut(request.urlLowercase);
            }
            if (this.hostname) {
                // If we have a `||example.org^` rule, it's easier to match
                // against the request's hostname only without matching
                // a regular expression.
                return request.hostname === this.hostname
                    || ( // First light check without new string memory allocation
                    request.hostname.endsWith(this.hostname)
                        // Strict check
                        && request.hostname.endsWith(".".concat(this.hostname)));
            }
            // If the regular expression is invalid, just return false right away.
            if (this.regexInvalid || !this.regex) {
                return false;
            }
            // This is needed for DNS filtering only, not used in browser blocking.
            if (this.shouldMatchHostname(request)) {
                return this.regex.test(request.hostname);
            }
            return this.regex.test(request.url);
        };
        /**
         * Checks if this rule pattern matches the specified relative path string.
         * This method is used in cosmetic rules to implement the $path modifier matching logic.
         *
         * @param path - path to check
         * @returns true if pattern matches
         */
        Pattern.prototype.matchPathPattern = function (path) {
            this.prepare();
            if (this.hostname) {
                return false;
            }
            if (this.patternShortcut) {
                return this.matchShortcut(path);
            }
            // If the regular expression is invalid, just return false right away.
            if (this.regexInvalid || !this.regex) {
                return false;
            }
            return this.regex.test(path);
        };
        /**
         * matchShortcut simply checks if shortcut is a substring of the URL.
         * @param request - request to check.
         */
        Pattern.prototype.matchShortcut = function (str) {
            return str.indexOf(this.shortcut) >= 0;
        };
        /**
         * Prepares this pattern
         */
        Pattern.prototype.prepare = function () {
            if (this.prepared) {
                return;
            }
            this.prepared = true;
            // If shortcut and pattern are the same, we don't need to actually compile
            // a regex and can simply use matchShortcut instead.
            if (this.pattern === this.shortcut) {
                this.patternShortcut = true;
                return;
            }
            // Rules like `/example/*` are rather often in the real-life filters,
            // we might want to process them.
            if (this.pattern.startsWith(this.shortcut)
                && this.pattern.length === this.shortcut.length + 1
                && this.pattern.endsWith('*')) {
                this.patternShortcut = true;
                return;
            }
            if (this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                && this.pattern.endsWith(SimpleRegex.MASK_SEPARATOR)
                && this.pattern.indexOf('*') < 0
                && this.pattern.indexOf('/') < 0) {
                this.hostname = this.pattern.slice(2, this.pattern.length - 1);
                return;
            }
            this.compileRegex();
        };
        /**
         * Compiles this pattern regex
         */
        Pattern.prototype.compileRegex = function () {
            var regexText = SimpleRegex.patternToRegexp(this.pattern);
            try {
                var flags = 'i';
                if (this.matchcase) {
                    flags = '';
                }
                this.regex = new RegExp(regexText, flags);
            }
            catch (e) {
                this.regexInvalid = true;
            }
        };
        /**
         * Checks if we should match hostnames and not the URL
         * this is important for the cases when we use urlfilter for DNS-level blocking
         * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead
         *
         * @param request
         */
        Pattern.prototype.shouldMatchHostname = function (request) {
            if (!request.isHostnameRequest) {
                return false;
            }
            return !this.isPatternDomainSpecific();
        };
        /**
         * In case pattern starts with the following it targets some specific domain
         */
        Pattern.prototype.isPatternDomainSpecific = function () {
            if (this.patternDomainSpecific === undefined) {
                this.patternDomainSpecific = this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                    || this.pattern.startsWith('http://')
                    || this.pattern.startsWith('https:/')
                    || this.pattern.startsWith('://');
            }
            return this.patternDomainSpecific;
        };
        return Pattern;
    }());

    /**
     * NetworkRuleOption is the enumeration of various rule options.
     * In order to save memory, we store some options as a flag.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
     */
    exports.NetworkRuleOption = void 0;
    (function (NetworkRuleOption) {
        /** $third-party modifier */
        NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
        /** $match-case modifier */
        NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
        /** $important modifier */
        NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
        // Allowlist rules modifiers
        // Each of them can disable part of the functionality
        /** $elemhide modifier */
        NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
        /** $generichide modifier */
        NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
        /** $specifichide modifier */
        NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
        /** $genericblock modifier */
        NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
        /** $jsinject modifier */
        NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
        /** $urlblock modifier */
        NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
        /** $content modifier */
        NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
        /** $extension modifier */
        NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
        /** $stealth modifier */
        NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
        // Content modifying
        // $empty modifier
        NetworkRuleOption[NetworkRuleOption["Empty"] = 4096] = "Empty";
        // $mp4 modifier
        NetworkRuleOption[NetworkRuleOption["Mp4"] = 8192] = "Mp4";
        // Other modifiers
        /** $popup modifier */
        NetworkRuleOption[NetworkRuleOption["Popup"] = 16384] = "Popup";
        /** $csp modifier */
        NetworkRuleOption[NetworkRuleOption["Csp"] = 32768] = "Csp";
        /** $replace modifier */
        NetworkRuleOption[NetworkRuleOption["Replace"] = 65536] = "Replace";
        /** $cookie modifier */
        NetworkRuleOption[NetworkRuleOption["Cookie"] = 131072] = "Cookie";
        /** $redirect modifier */
        NetworkRuleOption[NetworkRuleOption["Redirect"] = 262144] = "Redirect";
        /** $badfilter modifier */
        NetworkRuleOption[NetworkRuleOption["Badfilter"] = 524288] = "Badfilter";
        /** $removeparam modifier */
        NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 1048576] = "RemoveParam";
        /** $removeheader modifier */
        NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 2097152] = "RemoveHeader";
        // Compatibility dependent
        /** $network modifier */
        NetworkRuleOption[NetworkRuleOption["Network"] = 4194304] = "Network";
        /** dns modifiers */
        NetworkRuleOption[NetworkRuleOption["Client"] = 8388608] = "Client";
        NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 16777216] = "DnsRewrite";
        NetworkRuleOption[NetworkRuleOption["DnsType"] = 33554432] = "DnsType";
        NetworkRuleOption[NetworkRuleOption["Ctag"] = 67108864] = "Ctag";
        // Document
        NetworkRuleOption[NetworkRuleOption["Document"] = 134217728] = "Document";
        // Groups (for validation)
        /** Blacklist-only modifiers */
        NetworkRuleOption[NetworkRuleOption["BlacklistOnly"] = 12288] = "BlacklistOnly";
        /** Allowlist-only modifiers */
        NetworkRuleOption[NetworkRuleOption["AllowlistOnly"] = 4088] = "AllowlistOnly";
        /** Options supported by host-level network rules * */
        NetworkRuleOption[NetworkRuleOption["OptionHostLevelRules"] = 126353412] = "OptionHostLevelRules";
        /**
         * Removeparam compatible modifiers
         *
         * $removeparam rules are compatible only with content type modifiers ($script, $stylesheet, etc)
         * and this list of modifiers:
         */
        NetworkRuleOption[NetworkRuleOption["RemoveParamCompatibleOptions"] = 135790599] = "RemoveParamCompatibleOptions";
        /**
         * Removeheader compatible modifiers
         *
         * $removeheader rules are compatible only with content type modifiers ($script, $stylesheet, etc)
         * and this list of modifiers:
         */
        NetworkRuleOption[NetworkRuleOption["RemoveHeaderCompatibleOptions"] = 136839175] = "RemoveHeaderCompatibleOptions";
    })(exports.NetworkRuleOption || (exports.NetworkRuleOption = {}));
    /**
     * Helper class that is used for passing {@link NetworkRule.parseRuleText}
     * result to the caller. Should not be used outside of this file.
     */
    var BasicRuleParts = /** @class */ (function () {
        function BasicRuleParts() {
        }
        return BasicRuleParts;
    }());
    /**
     * Basic network filtering rule.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
     */
    var NetworkRule = /** @class */ (function () {
        /**
         * Creates an instance of the {@link NetworkRule}.
         * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
         * and rule modifiers.
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function NetworkRule(ruleText, filterListId) {
            this.permittedDomains = null;
            this.restrictedDomains = null;
            /**
             * Domains in denyallow modifier providing exceptions for permitted domains
             * https://github.com/AdguardTeam/CoreLibs/issues/1304
             */
            this.denyAllowDomains = null;
            /** Flag with all enabled rule options */
            this.enabledOptions = 0;
            /** Flag with all disabled rule options */
            this.disabledOptions = 0;
            /** Flag with all permitted request types. 0 means ALL. */
            this.permittedRequestTypes = 0;
            /** Flag with all restricted request types. 0 means NONE. */
            this.restrictedRequestTypes = 0;
            /**
             * Rule Advanced modifier
             */
            this.advancedModifier = null;
            /**
             * Rule App modifier
             */
            this.appModifier = null;
            /**
             * Priority weight
             * Used in rules priority comparision
             */
            this.priorityWeight = 0;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var ruleParts = NetworkRule.parseRuleText(ruleText);
            this.allowlist = !!ruleParts.allowlist;
            var pattern = ruleParts.pattern;
            if (pattern && NetworkRule.hasSpaces(pattern)) {
                throw new SyntaxError('Rule has spaces, seems to be an host rule');
            }
            if (ruleParts.options) {
                this.loadOptions(ruleParts.options);
            }
            if (pattern === SimpleRegex.MASK_START_URL
                || pattern === SimpleRegex.MASK_ANY_CHARACTER
                || pattern === ''
                || pattern.length < SimpleRegex.MIN_GENERIC_RULE_LENGTH) {
                // Except cookie and removeparam rules, they have their own atmosphere
                if (!(this.advancedModifier instanceof CookieModifier)
                    && !(this.advancedModifier instanceof RemoveParamModifier)) {
                    if (!(this.hasPermittedDomains() || this.hasPermittedApps())) {
                        // Rule matches too much and does not have any domain restriction
                        // We should not allow this kind of rules
                        // eslint-disable-next-line max-len
                        throw new SyntaxError('The rule is too wide, add domain restriction or make the pattern more specific');
                    }
                }
            }
            this.pattern = new Pattern(pattern, this.isOptionEnabled(exports.NetworkRuleOption.MatchCase));
        }
        NetworkRule.prototype.getText = function () {
            return this.ruleText;
        };
        NetworkRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Returns rule pattern,
         * which currently is used only in the rule validator module
         */
        NetworkRule.prototype.getPattern = function () {
            return this.pattern.pattern;
        };
        /**
         * Returns `true` if the rule is "allowlist", e.g. if it disables other
         * rules when the pattern matches the request.
         */
        NetworkRule.prototype.isAllowlist = function () {
            return this.allowlist;
        };
        /**
         * Checks if the rule is a document-level allowlist rule
         * This means that the rule is supposed to disable or modify blocking
         * of the page subrequests.
         * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
         */
        NetworkRule.prototype.isDocumentLevelAllowlistRule = function () {
            if (!this.isAllowlist()) {
                return false;
            }
            return this.isOptionEnabled(exports.NetworkRuleOption.Urlblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Genericblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Content);
        };
        /**
         * Checks if the rule is a document allowlist rule.
         * For instance,
         * "@@||example.org^$document"
         * completely disables filtering on all pages at example.com and all subdomains.
         */
        NetworkRule.prototype.isDocumentAllowlistRule = function () {
            if (!this.isAllowlist()) {
                return false;
            }
            return this.isOptionEnabled(exports.NetworkRuleOption.Document);
        };
        /**
         * The longest part of pattern without any special characters.
         * It is used to improve the matching performance.
         */
        NetworkRule.prototype.getShortcut = function () {
            return this.pattern.shortcut;
        };
        /**
         * Gets list of permitted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
         */
        NetworkRule.prototype.getPermittedDomains = function () {
            return this.permittedDomains;
        };
        /**
         * Gets list of denyAllow domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier
         */
        NetworkRule.prototype.getDenyAllowDomains = function () {
            return this.denyAllowDomains;
        };
        /**
         * Gets list of restricted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
         */
        NetworkRule.prototype.getRestrictedDomains = function () {
            return this.restrictedDomains;
        };
        /**
         * Gets list of permitted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
         */
        NetworkRule.prototype.getPermittedApps = function () {
            if (this.appModifier) {
                return this.appModifier.permittedApps;
            }
            return null;
        };
        /**
         * Gets list of restricted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
         */
        NetworkRule.prototype.getRestrictedApps = function () {
            if (this.appModifier) {
                return this.appModifier.restrictedApps;
            }
            return null;
        };
        /** Flag with all permitted request types. 0 means ALL. */
        NetworkRule.prototype.getPermittedRequestTypes = function () {
            return this.permittedRequestTypes;
        };
        /** Flag with all restricted request types. 0 means NONE. */
        NetworkRule.prototype.getRestrictedRequestTypes = function () {
            return this.restrictedRequestTypes;
        };
        /**
         * Advanced modifier
         */
        NetworkRule.prototype.getAdvancedModifier = function () {
            return this.advancedModifier;
        };
        /**
         * Advanced modifier value
         */
        NetworkRule.prototype.getAdvancedModifierValue = function () {
            return this.advancedModifier && this.advancedModifier.getValue();
        };
        /**
         * isRegexRule returns true if rule's pattern is a regular expression.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
         */
        NetworkRule.prototype.isRegexRule = function () {
            return (this.getPattern().startsWith(SimpleRegex.MASK_REGEX_RULE)
                && this.getPattern().endsWith(SimpleRegex.MASK_REGEX_RULE));
        };
        NetworkRule.prototype.matchesPermittedDomains = function (hostname) {
            if (this.hasPermittedDomains()
                && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains)) {
                return true;
            }
            return false;
        };
        /**
         * Checks if this filtering rule matches the specified request.
         * @param request - request to check.
         * @param useShortcut - the flag to use this rule shortcut
         *
         * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
         * includes full rule shortcut.
         */
        NetworkRule.prototype.match = function (request, useShortcut) {
            if (useShortcut === void 0) { useShortcut = true; }
            if (useShortcut && !this.matchShortcut(request)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.ThirdParty) && !request.thirdParty) {
                return false;
            }
            if (this.isOptionDisabled(exports.NetworkRuleOption.ThirdParty) && request.thirdParty) {
                return false;
            }
            if (!this.matchRequestType(request.requestType)) {
                return false;
            }
            if (!this.matchDomainModifier(request)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                if (!this.matchRequestTypeExplicit(request.requestType)) {
                    return false;
                }
            }
            if (!this.matchDenyAllowDomains(request.hostname)) {
                return false;
            }
            if (!this.matchDnsType(request.dnsType)) {
                return false;
            }
            if (!this.matchClientTags(request.clientTags)) {
                return false;
            }
            if (!this.matchClient(request.clientName, request.clientIP)) {
                return false;
            }
            return this.pattern.matchPattern(request, true);
        };
        /**
         * matchShortcut simply checks if shortcut is a substring of the URL.
         * @param request - request to check.
         */
        NetworkRule.prototype.matchShortcut = function (request) {
            return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
        };
        /**
         * matchDomain checks if the filtering rule is allowed on this domain.
         * @param domain - domain to check.
         */
        NetworkRule.prototype.matchDomain = function (domain) {
            if (this.hasRestrictedDomains()) {
                if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                    // Domain or host is restricted
                    // i.e. $domain=~example.org
                    return false;
                }
            }
            if (this.hasPermittedDomains()) {
                if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                    // Domain is not among permitted
                    // i.e. $domain=example.org and we're checking example.com
                    return false;
                }
            }
            return true;
        };
        /**
         * Check if request matches domain modifier by request referrer (general case) or by request target
         *
         * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
         * This happens when the following is true (1 AND ((2 AND 3) OR 4):
         *
         * 1) The request has document type
         * 2) The rule's pattern doesn't match any particular domain(s)
         * 3) The rule's pattern doesn't contain regular expressions
         * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
         *
         * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
         * https://github.com/AdguardTeam/tsurlfilter/issues/45
         * @param request
         */
        NetworkRule.prototype.matchDomainModifier = function (request) {
            if (!this.permittedDomains && !this.restrictedDomains) {
                return true;
            }
            var isDocumentType = request.requestType === exports.RequestType.Document
                || request.requestType === exports.RequestType.SubDocument;
            var hasOnlyExcludedDomains = (!this.permittedDomains || this.permittedDomains.length === 0)
                && this.restrictedDomains
                && this.restrictedDomains.length > 0;
            var patternIsRegex = this.isRegexRule();
            var patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
            var matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
            if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
                // check if matches source hostname if exists or if matches target hostname
                return (request.sourceHostname && this.matchDomain(request.sourceHostname))
                    || this.matchDomain(request.hostname);
            }
            return this.matchDomain(request.sourceHostname || '');
        };
        /**
         * checks if the filtering rule is allowed on this domain.
         * @param domain
         */
        NetworkRule.prototype.matchDenyAllowDomains = function (domain) {
            if (!this.denyAllowDomains) {
                return true;
            }
            if (this.denyAllowDomains.length > 0) {
                if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Return TRUE if this rule matches with the tags associated with a client
         *
         * @param clientTags
         */
        NetworkRule.prototype.matchClientTags = function (clientTags) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
                return true;
            }
            if (!clientTags) {
                return false;
            }
            var cTagsModifier = advancedModifier;
            return clientTags.every(function (x) { return cTagsModifier.match(x); });
        };
        /**
         * returns TRUE if the rule matches with the specified client
         *
         * @param clientName
         * @param clientIP
         */
        NetworkRule.prototype.matchClient = function (clientName, clientIP) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
                return true;
            }
            if (!clientName && !clientIP) {
                return false;
            }
            var modifier = advancedModifier;
            return modifier.matchAny(clientName, clientIP);
        };
        /**
         * Return TRUE if this rule matches with the request dnstype
         *
         * @param dnstype
         */
        NetworkRule.prototype.matchDnsType = function (dnstype) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
                return true;
            }
            if (!dnstype) {
                return false;
            }
            var modifier = advancedModifier;
            return modifier.match(dnstype);
        };
        /**
         * Checks if rule has permitted domains
         */
        NetworkRule.prototype.hasPermittedDomains = function () {
            return this.permittedDomains != null && this.permittedDomains.length > 0;
        };
        /**
         * Checks if rule has restricted domains
         */
        NetworkRule.prototype.hasRestrictedDomains = function () {
            return this.restrictedDomains != null && this.restrictedDomains.length > 0;
        };
        /**
         * Checks if rule has permitted apps
         */
        NetworkRule.prototype.hasPermittedApps = function () {
            if (!this.appModifier) {
                return false;
            }
            return this.appModifier.permittedApps !== null && this.appModifier.permittedApps.length > 0;
        };
        /**
         * matchRequestType checks if the request's type matches the rule properties
         * @param requestType - request type to check.
         */
        NetworkRule.prototype.matchRequestType = function (requestType) {
            if (this.permittedRequestTypes !== 0) {
                if ((this.permittedRequestTypes & requestType) !== requestType) {
                    return false;
                }
            }
            if (this.restrictedRequestTypes !== 0) {
                if ((this.restrictedRequestTypes & requestType) === requestType) {
                    return false;
                }
            }
            return true;
        };
        /**
         * In case of $removeparam modifier,
         * we only allow it to target other content types if the rule has an explicit content-type modifier.
         */
        NetworkRule.prototype.matchRequestTypeExplicit = function (requestType) {
            if (this.permittedRequestTypes === 0
                && this.restrictedRequestTypes === 0
                && requestType !== exports.RequestType.Document
                && requestType !== exports.RequestType.SubDocument) {
                return false;
            }
            return this.matchRequestType(requestType);
        };
        /**
         * Checks if pattern has spaces
         * Used in order to do not create network rules from host rules
         * @param pattern
         * @private
         */
        NetworkRule.hasSpaces = function (pattern) {
            return pattern.indexOf(' ') > -1;
        };
        /**
         * Parses the options string and saves them.
         * More on the rule modifiers:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
         *
         * @param options - string with the rule modifiers
         *
         * @throws an error if there is an unsupported modifier
         */
        NetworkRule.prototype.loadOptions = function (options) {
            var optionParts = splitByDelimiterWithEscapeCharacter(options, ',', '\\', false);
            for (var i = 0; i < optionParts.length; i += 1) {
                var option = optionParts[i];
                var valueIndex = option.indexOf('=');
                var optionName = option;
                var optionValue = '';
                if (valueIndex > 0) {
                    optionName = option.substring(0, valueIndex);
                    optionValue = option.substring(valueIndex + 1);
                }
                this.loadOption(optionName, optionValue);
            }
            // More specified rule has more priority
            this.priorityWeight = optionParts.length;
            this.validateOptions();
            // In the case of allowlist rules $document implicitly includes all other modifiers:
            // `$content`, `$elemhide`, `$jsinject`, `$urlblock`.
            if (this.isAllowlist() && this.isOptionEnabled(exports.NetworkRuleOption.Document)) {
                this.setOptionEnabled(exports.NetworkRuleOption.Elemhide, true, true);
                this.setOptionEnabled(exports.NetworkRuleOption.Jsinject, true, true);
                this.setOptionEnabled(exports.NetworkRuleOption.Urlblock, true, true);
                this.setOptionEnabled(exports.NetworkRuleOption.Content, true, true);
            }
            // Rules of these types can be applied to documents only
            // $jsinject, $elemhide, $urlblock, $genericblock, $generichide and $content for allowlist rules.
            // $popup - for url blocking
            if (this.isOptionEnabled(exports.NetworkRuleOption.Jsinject)
                || this.isOptionEnabled(exports.NetworkRuleOption.Elemhide)
                || this.isOptionEnabled(exports.NetworkRuleOption.Content)
                || this.isOptionEnabled(exports.NetworkRuleOption.Urlblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Genericblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Generichide)
                || this.isOptionEnabled(exports.NetworkRuleOption.Popup)) {
                this.permittedRequestTypes = exports.RequestType.Document;
            }
        };
        /**
         * Returns true if the specified option is enabled.
         * Please note, that options have three state: enabled, disabled, undefined.
         *
         * @param option - rule option to check.
         */
        NetworkRule.prototype.isOptionEnabled = function (option) {
            return (this.enabledOptions & option) === option;
        };
        /**
         * Returns true if one and only option is enabled
         *
         * @param option
         */
        NetworkRule.prototype.isSingleOptionEnabled = function (option) {
            return this.enabledOptions === option;
        };
        /**
         * Returns true if the specified option is disabled.
         * Please note, that options have three state: enabled, disabled, undefined.
         *
         * @param option - rule option to check.
         */
        NetworkRule.prototype.isOptionDisabled = function (option) {
            return (this.disabledOptions & option) === option;
        };
        /**
         * Checks if the rule has higher priority that the specified rule
         * allowlist + $important > $important > allowlist > basic rules
         */
        NetworkRule.prototype.isHigherPriority = function (r) {
            var important = this.isOptionEnabled(exports.NetworkRuleOption.Important);
            var rImportant = r.isOptionEnabled(exports.NetworkRuleOption.Important);
            if (this.isAllowlist() && important && !(r.isAllowlist() && rImportant)) {
                return true;
            }
            if (r.isAllowlist() && rImportant && !(this.isAllowlist() && important)) {
                return false;
            }
            if (important && !rImportant) {
                return true;
            }
            if (rImportant && !important) {
                return false;
            }
            if (this.isAllowlist() && !r.isAllowlist()) {
                return true;
            }
            if (r.isAllowlist() && !this.isAllowlist()) {
                return false;
            }
            var generic = this.isGeneric();
            var rGeneric = r.isGeneric();
            if (!generic && rGeneric) {
                // specific rules have priority over generic rules
                return true;
            }
            return this.priorityWeight > r.priorityWeight;
        };
        /**
         * Returns true if the rule is considered "generic"
         * "generic" means that the rule is not restricted to a limited set of domains
         * Please note that it might be forbidden on some domains, though.
         *
         * @return {boolean}
         */
        NetworkRule.prototype.isGeneric = function () {
            return !this.hasPermittedDomains();
        };
        /**
         * Returns true if this rule negates the specified rule
         * Only makes sense when this rule has a `badfilter` modifier
         */
        NetworkRule.prototype.negatesBadfilter = function (specifiedRule) {
            if (!this.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                return false;
            }
            if (this.allowlist !== specifiedRule.allowlist) {
                return false;
            }
            if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
                return false;
            }
            if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
                return false;
            }
            if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
                return false;
            }
            if ((this.enabledOptions ^ exports.NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
                return false;
            }
            if (this.disabledOptions !== specifiedRule.disabledOptions) {
                return false;
            }
            if (!stringArraysEquals(this.restrictedDomains, specifiedRule.restrictedDomains)) {
                return false;
            }
            if (!stringArraysHaveIntersection(this.permittedDomains, specifiedRule.permittedDomains)) {
                return false;
            }
            return true;
        };
        /**
         * Checks if this rule can be used for hosts-level blocking
         */
        NetworkRule.prototype.isHostLevelNetworkRule = function () {
            if (this.hasPermittedDomains() || this.hasRestrictedDomains()) {
                return false;
            }
            if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
                return false;
            }
            if (this.disabledOptions !== 0) {
                return false;
            }
            if (this.enabledOptions !== 0) {
                return ((this.enabledOptions
                    & exports.NetworkRuleOption.OptionHostLevelRules)
                    | (this.enabledOptions
                        ^ exports.NetworkRuleOption.OptionHostLevelRules)) === exports.NetworkRuleOption.OptionHostLevelRules;
            }
            return true;
        };
        /**
         * Enables or disables the specified option.
         *
         * @param option - option to enable or disable.
         * @param enabled - true to enable, false to disable.
         * @param skipRestrictions - skip options allowlist/blacklist restrictions
         *
         * @throws an error if the option we're trying to enable cannot be.
         * For instance, you cannot enable $elemhide for blacklist rules.
         */
        NetworkRule.prototype.setOptionEnabled = function (option, enabled, skipRestrictions) {
            if (skipRestrictions === void 0) { skipRestrictions = false; }
            if (!skipRestrictions) {
                if (this.allowlist && (option & exports.NetworkRuleOption.BlacklistOnly) === option) {
                    throw new SyntaxError("Modifier ".concat(exports.NetworkRuleOption[option], " cannot be used in allowlist rule"));
                }
                if (!this.allowlist && (option & exports.NetworkRuleOption.AllowlistOnly) === option) {
                    throw new SyntaxError("Modifier ".concat(exports.NetworkRuleOption[option], " cannot be used in blacklist rule"));
                }
            }
            if (enabled) {
                this.enabledOptions |= option;
            }
            else {
                this.disabledOptions |= option;
            }
        };
        /**
         * Permits or forbids the specified request type.
         * "Permits" means that the rule will match **only** the types that are permitted.
         * "Restricts" means that the rule will match **all but restricted**.
         *
         * @param requestType - request type.
         * @param permitted - true if it's permitted (whic)
         */
        NetworkRule.prototype.setRequestType = function (requestType, permitted) {
            if (permitted) {
                this.permittedRequestTypes |= requestType;
            }
            else {
                this.restrictedRequestTypes |= requestType;
            }
        };
        /**
         * Sets and validates exceptionally allowed domains presented in $denyallow modifier
         *
         * @param optionValue
         */
        NetworkRule.prototype.setDenyAllowDomains = function (optionValue) {
            var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
            if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
                throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
            }
            if (domainModifier.permittedDomains
                && domainModifier.permittedDomains.some(function (x) { return x.includes(SimpleRegex.MASK_ANY_CHARACTER); })) {
                throw new SyntaxError('Invalid modifier: $denyallow domains wildcards are not supported');
            }
            this.denyAllowDomains = domainModifier.permittedDomains;
        };
        /**
         * Loads the specified modifier:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
         *
         * @param optionName - modifier name.
         * @param optionValue - modifier value.
         *
         * @throws an error if there is an unsupported modifier
         */
        NetworkRule.prototype.loadOption = function (optionName, optionValue) {
            var OPTIONS = NetworkRule.OPTIONS;
            if (optionName.startsWith(OPTIONS.NOOP)) {
                /**
                 * A noop modifier does nothing and can be used to increase some rules readability.
                 * It consists of the sequence of underscore characters (_) of any length
                 * and can appear in a rule as many times as it's needed.
                 */
                if (!optionName.split(OPTIONS.NOOP).some(function (s) { return !!s; })) {
                    return;
                }
            }
            switch (optionName) {
                // General options
                case OPTIONS.THIRD_PARTY:
                case NOT_MARK + OPTIONS.FIRST_PARTY:
                    this.setOptionEnabled(exports.NetworkRuleOption.ThirdParty, true);
                    break;
                case NOT_MARK + OPTIONS.THIRD_PARTY:
                case OPTIONS.FIRST_PARTY:
                    this.setOptionEnabled(exports.NetworkRuleOption.ThirdParty, false);
                    break;
                case OPTIONS.MATCH_CASE:
                    this.setOptionEnabled(exports.NetworkRuleOption.MatchCase, true);
                    break;
                case NOT_MARK + OPTIONS.MATCH_CASE:
                    this.setOptionEnabled(exports.NetworkRuleOption.MatchCase, false);
                    break;
                case OPTIONS.IMPORTANT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Important, true);
                    break;
                // $domain modifier
                case OPTIONS.DOMAIN: {
                    var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
                    this.permittedDomains = domainModifier.permittedDomains;
                    this.restrictedDomains = domainModifier.restrictedDomains;
                    break;
                }
                case OPTIONS.DENYALLOW: {
                    this.setDenyAllowDomains(optionValue);
                    break;
                }
                // Document-level allowlist rules
                case OPTIONS.ELEMHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Elemhide, true);
                    break;
                case OPTIONS.GENERICHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Generichide, true);
                    break;
                case OPTIONS.SPECIFICHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Specifichide, true);
                    break;
                case OPTIONS.GENERICBLOCK:
                    this.setOptionEnabled(exports.NetworkRuleOption.Genericblock, true);
                    break;
                case OPTIONS.JSINJECT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Jsinject, true);
                    break;
                case OPTIONS.URLBLOCK:
                    this.setOptionEnabled(exports.NetworkRuleOption.Urlblock, true);
                    break;
                case OPTIONS.CONTENT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Content, true);
                    break;
                // $document
                case OPTIONS.DOCUMENT:
                case OPTIONS.DOC:
                    this.setOptionEnabled(exports.NetworkRuleOption.Document, true);
                    this.setRequestType(exports.RequestType.Document, true);
                    break;
                case NOT_MARK + OPTIONS.DOCUMENT:
                case NOT_MARK + OPTIONS.DOC:
                    this.setOptionEnabled(exports.NetworkRuleOption.Document, false);
                    this.setRequestType(exports.RequestType.Document, false);
                    break;
                // Stealth mode $stealth
                case OPTIONS.STEALTH:
                    this.setOptionEnabled(exports.NetworkRuleOption.Stealth, true);
                    break;
                // $popup blocking option
                case OPTIONS.POPUP:
                    this.setOptionEnabled(exports.NetworkRuleOption.Popup, true);
                    break;
                // $empty and $mp4
                // Deprecated in favor of $redirect
                case OPTIONS.EMPTY:
                    this.setOptionEnabled(exports.NetworkRuleOption.Empty, true);
                    break;
                case OPTIONS.MP4:
                    this.setOptionEnabled(exports.NetworkRuleOption.Mp4, true);
                    break;
                // Content type options
                case OPTIONS.SCRIPT:
                    this.setRequestType(exports.RequestType.Script, true);
                    break;
                case NOT_MARK + OPTIONS.SCRIPT:
                    this.setRequestType(exports.RequestType.Script, false);
                    break;
                case OPTIONS.STYLESHEET:
                    this.setRequestType(exports.RequestType.Stylesheet, true);
                    break;
                case NOT_MARK + OPTIONS.STYLESHEET:
                    this.setRequestType(exports.RequestType.Stylesheet, false);
                    break;
                case OPTIONS.SUBDOCUMENT:
                    this.setRequestType(exports.RequestType.SubDocument, true);
                    break;
                case NOT_MARK + OPTIONS.SUBDOCUMENT:
                    this.setRequestType(exports.RequestType.SubDocument, false);
                    break;
                case OPTIONS.OBJECT:
                    this.setRequestType(exports.RequestType.Object, true);
                    break;
                case NOT_MARK + OPTIONS.OBJECT:
                    this.setRequestType(exports.RequestType.Object, false);
                    break;
                case OPTIONS.IMAGE:
                    this.setRequestType(exports.RequestType.Image, true);
                    break;
                case NOT_MARK + OPTIONS.IMAGE:
                    this.setRequestType(exports.RequestType.Image, false);
                    break;
                case OPTIONS.XMLHTTPREQUEST:
                    this.setRequestType(exports.RequestType.XmlHttpRequest, true);
                    break;
                case NOT_MARK + OPTIONS.XMLHTTPREQUEST:
                    this.setRequestType(exports.RequestType.XmlHttpRequest, false);
                    break;
                case OPTIONS.MEDIA:
                    this.setRequestType(exports.RequestType.Media, true);
                    break;
                case NOT_MARK + OPTIONS.MEDIA:
                    this.setRequestType(exports.RequestType.Media, false);
                    break;
                case OPTIONS.FONT:
                    this.setRequestType(exports.RequestType.Font, true);
                    break;
                case NOT_MARK + OPTIONS.FONT:
                    this.setRequestType(exports.RequestType.Font, false);
                    break;
                case OPTIONS.WEBSOCKET:
                    this.setRequestType(exports.RequestType.WebSocket, true);
                    break;
                case NOT_MARK + OPTIONS.WEBSOCKET:
                    this.setRequestType(exports.RequestType.WebSocket, false);
                    break;
                case OPTIONS.OTHER:
                    this.setRequestType(exports.RequestType.Other, true);
                    break;
                case NOT_MARK + OPTIONS.OTHER:
                    this.setRequestType(exports.RequestType.Other, false);
                    break;
                case OPTIONS.PING:
                    this.setRequestType(exports.RequestType.Ping, true);
                    break;
                case NOT_MARK + OPTIONS.PING:
                    this.setRequestType(exports.RequestType.Ping, false);
                    break;
                case OPTIONS.WEBRTC:
                    this.setRequestType(exports.RequestType.WebRtc, true);
                    break;
                case NOT_MARK + OPTIONS.WEBRTC:
                    this.setRequestType(exports.RequestType.WebRtc, false);
                    break;
                // Special modifiers
                case OPTIONS.BADFILTER:
                    this.setOptionEnabled(exports.NetworkRuleOption.Badfilter, true);
                    break;
                case OPTIONS.CSP:
                    this.setOptionEnabled(exports.NetworkRuleOption.Csp, true);
                    this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                    break;
                case OPTIONS.REPLACE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Replace, true);
                    this.advancedModifier = new ReplaceModifier(optionValue);
                    break;
                case OPTIONS.COOKIE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Cookie, true);
                    this.advancedModifier = new CookieModifier(optionValue);
                    break;
                case OPTIONS.REDIRECT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Redirect, true);
                    this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist());
                    break;
                case OPTIONS.REDIRECTRULE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Redirect, true);
                    this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist(), true);
                    break;
                case OPTIONS.REMOVEPARAM:
                    this.setOptionEnabled(exports.NetworkRuleOption.RemoveParam, true);
                    this.advancedModifier = new RemoveParamModifier(optionValue);
                    break;
                case OPTIONS.REMOVEHEADER:
                    this.setOptionEnabled(exports.NetworkRuleOption.RemoveHeader, true);
                    this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                    break;
                // Dns modifiers
                case OPTIONS.CLIENT: {
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $client modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Client, true);
                    this.advancedModifier = new ClientModifier(optionValue);
                    break;
                }
                case OPTIONS.DNSREWRITE: {
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.DnsRewrite, true);
                    this.advancedModifier = new DnsRewriteModifier(optionValue);
                    break;
                }
                case OPTIONS.DNSTYPE: {
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.DnsType, true);
                    this.advancedModifier = new DnsTypeModifier(optionValue);
                    break;
                }
                case OPTIONS.CTAG: {
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Ctag, true);
                    this.advancedModifier = new CtagModifier(optionValue);
                    break;
                }
                case OPTIONS.APP: {
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $app modifier');
                    }
                    this.appModifier = new AppModifier(optionValue);
                    break;
                }
                case OPTIONS.NETWORK:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $network modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Network, true);
                    break;
                case OPTIONS.EXTENSION:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $extension modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Extension, true);
                    break;
                case NOT_MARK + OPTIONS.EXTENSION:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $extension modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Extension, false);
                    break;
                default: {
                    // clear empty values
                    var modifierView = [optionName, optionValue]
                        .filter(function (i) { return i; })
                        .join('=');
                    throw new SyntaxError("Unknown modifier: ".concat(modifierView));
                }
            }
        };
        /**
         * Validates rule options
         */
        NetworkRule.prototype.validateOptions = function () {
            if (this.advancedModifier instanceof RemoveParamModifier) {
                this.validateRemoveParamRule();
            }
            else if (this.advancedModifier instanceof RemoveHeaderModifier) {
                this.validateRemoveHeaderRule();
            }
        };
        /**
         * $removeparam rules are not compatible with any other modifiers except $domain,
         * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
         * The rules with any other modifiers are considered invalid and will be discarded.
         */
        NetworkRule.prototype.validateRemoveParamRule = function () {
            if ((this.enabledOptions | exports.NetworkRuleOption.RemoveParamCompatibleOptions)
                !== exports.NetworkRuleOption.RemoveParamCompatibleOptions) {
                throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
            }
        };
        /**
         * $removeheader rules are not compatible with any other modifiers except $domain,
         * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
         * The rules with any other modifiers are considered invalid and will be discarded.
         */
        NetworkRule.prototype.validateRemoveHeaderRule = function () {
            if ((this.enabledOptions | exports.NetworkRuleOption.RemoveHeaderCompatibleOptions)
                !== exports.NetworkRuleOption.RemoveHeaderCompatibleOptions) {
                throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
            }
        };
        /**
         * parseRuleText splits the rule text into multiple parts.
         * @param ruleText - original rule text
         * @returns basic rule parts
         *
         * @throws error if the rule is empty (for instance, empty string or `@@`)
         */
        NetworkRule.parseRuleText = function (ruleText) {
            var ruleParts = new BasicRuleParts();
            ruleParts.allowlist = false;
            var startIndex = 0;
            if (ruleText.startsWith(NetworkRule.MASK_ALLOWLIST)) {
                ruleParts.allowlist = true;
                startIndex = NetworkRule.MASK_ALLOWLIST.length;
            }
            if (ruleText.length <= startIndex) {
                throw new SyntaxError('Rule is too short');
            }
            // Setting pattern to rule text (for the case of empty options)
            ruleParts.pattern = ruleText.substring(startIndex);
            // Avoid parsing options inside of a regex rule
            if (ruleParts.pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
                && ruleParts.pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)
                && !ruleParts.pattern.includes("".concat(NetworkRule.OPTIONS.REPLACE, "="))) {
                return ruleParts;
            }
            var removeParamIndex = ruleText.lastIndexOf("".concat(NetworkRule.OPTIONS.REMOVEPARAM, "="));
            var endIndex = removeParamIndex >= 0 ? removeParamIndex : ruleText.length - 2;
            var foundEscaped = false;
            for (var i = endIndex; i >= startIndex; i -= 1) {
                var c = ruleText.charAt(i);
                if (c === NetworkRule.OPTIONS_DELIMITER) {
                    if (i > startIndex && ruleText.charAt(i - 1) === NetworkRule.ESCAPE_CHARACTER) {
                        foundEscaped = true;
                    }
                    else {
                        ruleParts.pattern = ruleText.substring(startIndex, i);
                        ruleParts.options = ruleText.substring(i + 1);
                        if (foundEscaped) {
                            // Find and replace escaped options delimiter
                            ruleParts.options = ruleParts.options.replace(NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER, NetworkRule.OPTIONS_DELIMITER);
                            // Reset the regexp state
                            NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER.lastIndex = 0;
                        }
                        // Options delimiter was found, exiting loop
                        break;
                    }
                }
            }
            return ruleParts;
        };
        /**
         * Separates the rule pattern from the list of modifiers.
         *
         * ```
         * rule = ["@@"] pattern [ "$" modifiers ]
         * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
         * ```
         */
        NetworkRule.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
        /**
         * This character is used to escape special characters in modifiers values
         */
        NetworkRule.ESCAPE_CHARACTER = ESCAPE_CHARACTER;
        // eslint-disable-next-line max-len
        NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER = new RegExp("".concat(NetworkRule.ESCAPE_CHARACTER).concat(NetworkRule.OPTIONS_DELIMITER), 'g');
        /**
         * A marker that is used in rules of exception.
         * To turn off filtering for a request, start your rule with this marker.
         */
        NetworkRule.MASK_ALLOWLIST = MASK_ALLOWLIST;
        /**
         * Mark that negates options
         */
        NetworkRule.NOT_MARK = NOT_MARK;
        /**
         * Rule options
         */
        NetworkRule.OPTIONS = NETWORK_RULE_OPTIONS;
        return NetworkRule;
    }());

    /**
     * Implements a host rule.
     *
     * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
     * http://man7.org/linux/man-pages/man5/hosts.5.html
     * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
     *
     * Rules syntax looks like this:
     * ```
     * IP_address canonical_hostname [aliases...]
     * ```
     *
     * Examples:
     * * `192.168.1.13 bar.mydomain.org bar` -- ipv4
     * * `ff02::1 ip6-allnodes` -- ipv6
     * * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
     * * `example.org` -- "just domain" syntax
     */
    var HostRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * Parses the rule and creates a new HostRule instance
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function HostRule(ruleText, filterListId) {
            this.hostnames = [];
            this.ip = '';
            this.invalid = false;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var commentIndex = ruleText.indexOf('#');
            var stripped = commentIndex >= 0 ? ruleText.substring(0, commentIndex) : ruleText;
            var parts = stripped.trim().split(' ');
            if (parts.length >= 2) {
                if (!isIp_1(parts[0])) {
                    this.invalid = true;
                    return;
                }
                // eslint-disable-next-line prefer-destructuring
                this.ip = parts[0];
                this.hostnames = parts.slice(1).filter(function (x) { return !!x; });
            }
            else if (parts.length === 1 && isDomainName(parts[0])) {
                this.hostnames = [parts[0]];
                this.ip = '0.0.0.0';
            }
            else {
                this.invalid = true;
            }
        }
        /**
         * Match returns true if this rule can be used on the specified hostname.
         *
         * @param hostname - hostname to check
         */
        HostRule.prototype.match = function (hostname) {
            return this.hostnames.includes(hostname);
        };
        /**
         * Returns list id
         */
        HostRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Return rule text
         */
        HostRule.prototype.getText = function () {
            return this.ruleText;
        };
        /**
         * Returns ip address
         */
        HostRule.prototype.getIp = function () {
            return this.ip;
        };
        /**
         * Returns hostnames
         */
        HostRule.prototype.getHostnames = function () {
            return this.hostnames;
        };
        /**
         * Is invalid rule
         */
        HostRule.prototype.isInvalid = function () {
            return this.invalid;
        };
        return HostRule;
    }());

    /**
     * MatchingResult contains all the rules matching a web request, and provides methods
     * that define how a web request should be processed
     */
    var MatchingResult = /** @class */ (function () {
        /**
         * Creates an instance of the MatchingResult struct and fills it with the rules.
         *
         * @param rules network rules
         * @param sourceRule source rule
         */
        function MatchingResult(rules, sourceRule) {
            this.basicRule = null;
            this.documentRule = null;
            this.cspRules = null;
            this.cookieRules = null;
            this.replaceRules = null;
            this.removeParamRules = null;
            this.removeHeaderRules = null;
            this.redirectRules = null;
            this.cspRules = null;
            this.stealthRule = null;
            // eslint-disable-next-line no-param-reassign
            rules = MatchingResult.removeBadfilterRules(rules);
            if (sourceRule) {
                this.documentRule = sourceRule;
            }
            // Second - check if blocking rules (generic or all of them) are allowed
            // generic blocking rules are allowed by default
            var genericAllowed = true;
            // basic blocking rules are allowed by default
            var basicAllowed = true;
            if (this.documentRule) {
                var documentRule = this.documentRule;
                if (documentRule.isOptionEnabled(exports.NetworkRuleOption.Urlblock)) {
                    basicAllowed = false;
                }
                else if (documentRule.isOptionEnabled(exports.NetworkRuleOption.Genericblock)) {
                    genericAllowed = false;
                }
            }
            // Iterate through the list of rules and fill the MatchingResult
            for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
                var rule = rules_1[_i];
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Cookie)) {
                    if (!this.cookieRules) {
                        this.cookieRules = [];
                    }
                    this.cookieRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Replace)) {
                    if (!this.replaceRules) {
                        this.replaceRules = [];
                    }
                    this.replaceRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                    if (!this.removeParamRules) {
                        this.removeParamRules = [];
                    }
                    this.removeParamRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveHeader)) {
                    if (!this.removeHeaderRules) {
                        this.removeHeaderRules = [];
                    }
                    this.removeHeaderRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Redirect)) {
                    if (!this.redirectRules) {
                        this.redirectRules = [];
                    }
                    this.redirectRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Csp)) {
                    if (!this.cspRules) {
                        this.cspRules = [];
                    }
                    this.cspRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Stealth)) {
                    this.stealthRule = rule;
                    continue;
                }
                // Check blocking rules against $genericblock / $urlblock
                if (!rule.isAllowlist()) {
                    if (!basicAllowed) {
                        continue;
                    }
                    if (!genericAllowed && rule.isGeneric()) {
                        continue;
                    }
                }
                if (!this.basicRule || rule.isHigherPriority(this.basicRule)) {
                    this.basicRule = rule;
                }
            }
        }
        /**
         * GetBasicResult returns a rule that should be applied to the web request.
         * Possible outcomes are:
         * returns nil -- bypass the request.
         * returns a allowlist rule -- bypass the request.
         * returns a blocking rule -- block the request.
         *
         * @return {NetworkRule | null} basic result rule
         */
        MatchingResult.prototype.getBasicResult = function () {
            var basic = this.basicRule;
            if (!basic) {
                // Only document-level frame rule would be returned as a basic result,
                // cause only those rules could block or modify page subrequests.
                // Other frame rules (generichide, elemhide etc) will be used in getCosmeticOption function.
                if (this.documentRule && this.documentRule.isDocumentLevelAllowlistRule()) {
                    basic = this.documentRule;
                }
            }
            // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#replace-modifier
            // 1. $replace rules have a higher priority than other basic rules (including exception rules).
            //  So if a request corresponds to two different rules one of which has the $replace modifier,
            //  this rule will be applied.
            // 2. $document exception rules and rules with $content or $replace modifiers do disable $replace rules
            //  for requests matching them.
            if (this.replaceRules) {
                if (basic && basic.isAllowlist()) {
                    if (basic.isDocumentAllowlistRule()) {
                        return basic;
                    }
                    if (basic.isOptionEnabled(exports.NetworkRuleOption.Replace)
                        || basic.isOptionEnabled(exports.NetworkRuleOption.Content)) {
                        return basic;
                    }
                }
                return null;
            }
            // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#redirect-modifier
            // Redirect rules have a high priority
            var redirectRule = this.getRedirectRule();
            if (redirectRule) {
                if (!basic || redirectRule.isHigherPriority(basic)) {
                    return redirectRule;
                }
            }
            return basic;
        };
        /**
         * Returns a bit-flag with the list of cosmetic options
         *
         * @return {CosmeticOption} mask
         */
        MatchingResult.prototype.getCosmeticOption = function () {
            if (!this.basicRule || !this.basicRule.isAllowlist()) {
                return exports.CosmeticOption.CosmeticOptionAll;
            }
            if (this.basicRule.isDocumentAllowlistRule()) {
                return exports.CosmeticOption.CosmeticOptionNone;
            }
            var option = exports.CosmeticOption.CosmeticOptionAll;
            if (this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Elemhide)) {
                option ^= exports.CosmeticOption.CosmeticOptionGenericCSS;
                option ^= exports.CosmeticOption.CosmeticOptionSpecificCSS;
            }
            if (this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Generichide)) {
                option ^= exports.CosmeticOption.CosmeticOptionGenericCSS;
            }
            if (this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Specifichide)) {
                option ^= exports.CosmeticOption.CosmeticOptionSpecificCSS;
            }
            if (this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Jsinject)) {
                option ^= exports.CosmeticOption.CosmeticOptionJS;
            }
            if (this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Content)) {
                option ^= exports.CosmeticOption.CosmeticOptionHtml;
            }
            return option;
        };
        /**
         * Return an array of replace rules
         */
        MatchingResult.prototype.getReplaceRules = function () {
            if (!this.replaceRules) {
                return [];
            }
            // TODO: Look up for allowlist $content rule
            return MatchingResult.filterAdvancedModifierRules(this.replaceRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
        };
        /**
         * Filters array of rules according to allowlist rules contained.
         * Empty advanced modifier allowlists everything.
         *
         * @param rules
         * @param allowlistPredicate allowlist criteria
         * This function result will be called for testing if rule `x` allowlists rule `r`
         */
        MatchingResult.filterAdvancedModifierRules = function (rules, allowlistPredicate) {
            var _this = this;
            var blockingRules = [];
            var allowlistRules = [];
            for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
                var rule = rules_2[_i];
                if (rule.isAllowlist()) {
                    allowlistRules.push(rule);
                }
                else {
                    blockingRules.push(rule);
                }
            }
            if (blockingRules.length === 0) {
                return [];
            }
            if (allowlistRules.length === 0) {
                return blockingRules;
            }
            if (allowlistRules.length > 0) {
                var allowlistRuleWithEmptyOption_1 = allowlistRules
                    .find(function (allowlistRule) { return allowlistRule.getAdvancedModifierValue() === ''; });
                var result_1 = [];
                blockingRules.forEach(function (blockRule) {
                    if (allowlistRuleWithEmptyOption_1
                        && !blockRule.isHigherPriority(allowlistRuleWithEmptyOption_1)) {
                        result_1.push(allowlistRuleWithEmptyOption_1);
                        return;
                    }
                    var allowlistingRule = allowlistRules.find(function (a) {
                        return !blockRule.isHigherPriority(a) && allowlistPredicate.call(_this, blockRule)(a);
                    });
                    if (allowlistingRule) {
                        result_1.push(allowlistingRule);
                    }
                    else {
                        result_1.push(blockRule);
                    }
                });
                return result_1.filter(function (item, pos) { return result_1.indexOf(item) === pos; });
            }
            return blockingRules;
        };
        /**
         * Returns an array of csp rules
         */
        MatchingResult.prototype.getCspRules = function () {
            if (!this.cspRules) {
                return [];
            }
            var blockingRules = [];
            var allowlistedRulesByDirective = new Map();
            for (var _i = 0, _a = this.cspRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                if (rule.isAllowlist()) {
                    if (!rule.getAdvancedModifierValue()) { // Global allowlist rule
                        return [rule];
                    }
                    MatchingResult.putWithPriority(rule, undefined, allowlistedRulesByDirective);
                }
                else {
                    blockingRules.push(rule);
                }
            }
            var rulesByDirective = new Map();
            // Collect allowlist and blocking CSP rules in one array
            blockingRules.forEach(function (rule) {
                if (rule.getAdvancedModifierValue()) {
                    var allowlistRule = allowlistedRulesByDirective.get(rule.getAdvancedModifierValue());
                    MatchingResult.putWithPriority(rule, allowlistRule, rulesByDirective);
                }
            });
            return Array.from(rulesByDirective.values());
        };
        /**
         * Returns a redirect rule
         */
        MatchingResult.prototype.getRedirectRule = function () {
            if (!this.redirectRules) {
                return null;
            }
            var result = MatchingResult.filterAdvancedModifierRules(this.redirectRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
            result = result.filter(function (r) { return !r.isAllowlist(); });
            var conditionalRedirectRules = result.filter(function (x) {
                var redirectModifier = x.getAdvancedModifier();
                return redirectModifier.isRedirectingOnlyBlocked;
            });
            var allWeatherRedirectRules = result.filter(function (x) { return !conditionalRedirectRules.includes(x); });
            if (allWeatherRedirectRules.length > 0) {
                return allWeatherRedirectRules.sort(function (a, b) { return (b.isOptionEnabled(exports.NetworkRuleOption.Important)
                    && !a.isOptionEnabled(exports.NetworkRuleOption.Important) ? 1 : -1); })[0];
            }
            if (conditionalRedirectRules.length === 0) {
                return null;
            }
            var resultRule = conditionalRedirectRules.sort(function (a, b) { return (b.isOptionEnabled(exports.NetworkRuleOption.Important)
                && !a.isOptionEnabled(exports.NetworkRuleOption.Important) ? 1 : -1); })[0];
            var redirectModifier = resultRule.getAdvancedModifier();
            if (redirectModifier && redirectModifier.isRedirectingOnlyBlocked) {
                if (!(this.basicRule && !this.basicRule.isAllowlist())) {
                    return null;
                }
            }
            return resultRule;
        };
        /**
         * Returns an array of cookie rules
         */
        MatchingResult.prototype.getCookieRules = function () {
            if (!this.cookieRules) {
                return [];
            }
            var basic = this.getBasicResult();
            if (basic === null || basic === void 0 ? void 0 : basic.isDocumentAllowlistRule()) {
                return [];
            }
            var allowlistPredicate = function (rule) { return (function (allowlistRule) {
                var allowlistRuleCookieModifier = allowlistRule.getAdvancedModifier();
                var ruleCookieModifier = rule.getAdvancedModifier();
                if (allowlistRule.getAdvancedModifierValue() === rule.getAdvancedModifierValue()) {
                    return true;
                }
                // Matches by cookie name
                if (allowlistRuleCookieModifier.matches(ruleCookieModifier.getCookieName())) {
                    return true;
                }
                return false;
            }); };
            var filtered = MatchingResult.filterAdvancedModifierRules(this.cookieRules, allowlistPredicate);
            return filtered.concat(__spreadArray([], this.cookieRules.filter(function (r) { return r.isAllowlist(); }), true));
        };
        /**
         * Returns an array of removeparam rules
         */
        MatchingResult.prototype.getRemoveParamRules = function () {
            if (!this.removeParamRules) {
                return [];
            }
            return MatchingResult.filterAdvancedModifierRules(this.removeParamRules, 
            // eslint-disable-next-line arrow-body-style
            function (rule) { return (function (x) {
                return x.isHigherPriority(rule) && x.getAdvancedModifierValue() === rule.getAdvancedModifierValue();
            }); });
        };
        /**
         * Returns an array of removeheader rules
         */
        MatchingResult.prototype.getRemoveHeaderRules = function () {
            if (!this.removeHeaderRules) {
                return [];
            }
            if (this.basicRule
                && this.basicRule.isAllowlist()
                && this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Urlblock)) {
                return [];
            }
            return MatchingResult.filterAdvancedModifierRules(this.removeHeaderRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
        };
        /**
         * Decides which rule should be put into the given map.
         * Compares priorities of the two given rules with the equal CSP directive and the rule that may already in the map.
         *
         * @param rule CSP rule (not null)
         * @param allowlistRule CSP allowlist rule (may be null)
         * @param map Rules mapped by csp directive
         */
        // eslint-disable-next-line max-len
        MatchingResult.putWithPriority = function (rule, allowlistRule, map) {
            var cspDirective = rule.getAdvancedModifierValue();
            var currentRule = cspDirective ? map.get(cspDirective) : null;
            var newRule = rule;
            if (currentRule && !rule.isHigherPriority(currentRule)) {
                newRule = currentRule;
            }
            if (allowlistRule && allowlistRule.isHigherPriority(newRule)) {
                newRule = allowlistRule;
            }
            map.set(cspDirective, newRule);
        };
        /**
         * Looks if there are any matching $badfilter rules and removes
         * matching bad filters from the array (see the $badfilter description for more info)
         *
         * @param rules to filter
         * @return filtered rules
         */
        MatchingResult.removeBadfilterRules = function (rules) {
            var badfilterRules = [];
            for (var _i = 0, rules_3 = rules; _i < rules_3.length; _i++) {
                var rule = rules_3[_i];
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                    badfilterRules.push(rule);
                }
            }
            if (badfilterRules.length > 0) {
                return rules.filter(function (rule) {
                    if (rule.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                        return false;
                    }
                    var isRuleNegated = badfilterRules.some(function (badfilter) { return badfilter.negatesBadfilter(rule); });
                    return !isRuleNegated;
                });
            }
            return rules;
        };
        return MatchingResult;
    }());

    /**
     * Scanner types enum
     */
    var ScannerType;
    (function (ScannerType) {
        /**
         * Scanning for network rules
         */
        ScannerType[ScannerType["NetworkRules"] = 0] = "NetworkRules";
        /**
         * Scanning for cosmetic rules
         */
        ScannerType[ScannerType["CosmeticRules"] = 2] = "CosmeticRules";
        /**
         * Scanning for host rules
         */
        ScannerType[ScannerType["HostRules"] = 4] = "HostRules";
        /**
         * All
         */
        ScannerType[ScannerType["All"] = 6] = "All";
    })(ScannerType || (ScannerType = {}));

    /**
     * Prefix tree implementation
     */
    var TrieNode = /** @class */ (function () {
        /**
         * Creates an instance of a TrieNode with the specified char code.
         *
         * @param code
         */
        function TrieNode(code) {
            this.code = code;
        }
        /**
         * Attaches data to this TrieNode.
         *
         * @param data
         */
        TrieNode.prototype.attach = function (data) {
            if (!this.data) {
                this.data = [];
            }
            this.data.push(data);
        };
        /**
         * Adds the specified string to the Trie and attaches data to it.
         *
         * @param str string to add.
         * @param data data to attach to the leaf node.
         */
        TrieNode.prototype.add = function (str, data) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var root = this;
            for (var i = 0; i < str.length; i += 1) {
                var c = str.charCodeAt(i);
                var next = root.getChild(c);
                if (!next) {
                    next = root.addChild(c);
                }
                root = next;
            }
            root.attach(data);
        };
        /**
         * Traverses this TrieNode and it's children using the specified search string.
         * This method collects all the data that's attached on the way and returns as
         * a result.
         *
         * @param str string to check.
         * @param start index in str where to start traversing from.
         */
        TrieNode.prototype.traverse = function (str, start) {
            var result = [];
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var current = this;
            for (var i = start; i < str.length; i += 1) {
                var c = str.charCodeAt(i);
                var next = current.getChild(c);
                if (!next) {
                    break;
                }
                if (next.data) {
                    result.push.apply(result, next.data);
                }
                current = next;
            }
            return result;
        };
        /**
         * Traverses this TrieNode and it's children using the specified search string and all substrings.
         *
         * @param str string to check
         * @param len max length to check
         */
        TrieNode.prototype.traverseAll = function (str, len) {
            var data = [];
            for (var i = 0; i <= len; i += 1) {
                var result = this.traverse(str, i);
                if (result) {
                    data.push.apply(data, result);
                }
            }
            return data;
        };
        /**
         * Returns a child node with the specified character code or
         * undefined if not found.
         *
         * @param code character code
         * @returns child node or undefined.
         */
        TrieNode.prototype.getChild = function (code) {
            var children = this.children;
            if (!children) {
                return undefined;
            }
            if (children instanceof TrieNode) {
                if (children.code === code) {
                    return children;
                }
                return undefined;
            }
            return children.get(code);
        };
        /**
         * Adds a new child node with the specified character code.
         *
         * @param code character code.
         * @returns the newly created TrieNode.
         */
        TrieNode.prototype.addChild = function (code) {
            var node = new TrieNode(code);
            if (!this.children) {
                this.children = node;
            }
            else if (this.children instanceof TrieNode) {
                var oldNode = this.children;
                this.children = new Map();
                this.children.set(oldNode.code, oldNode);
                this.children.set(code, node);
            }
            else {
                this.children.set(code, node);
            }
            return node;
        };
        return TrieNode;
    }());

    /**
     * Look up table with underlying prefix tree
     */
    var TrieLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance of the TrieLookupTable.
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function TrieLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            this.ruleStorage = storage;
            this.trie = new TrieNode(0);
        }
        /**
         * Finds all matching rules from the shortcuts lookup table
         *
         * @param request to check
         * @return array of matching rules
         */
        TrieLookupTable.prototype.matchAll = function (request) {
            var rulesIndexes = this.traverse(request);
            return this.matchRules(request, rulesIndexes);
        };
        /**
         * Tries to add the rule to the lookup table.
         * returns true if it was added
         *
         * @param rule to add
         * @param storageIdx index
         * @return {boolean} true if the rule been added
         */
        TrieLookupTable.prototype.addRule = function (rule, storageIdx) {
            var shortcut = rule.getShortcut();
            if (!shortcut || TrieLookupTable.isAnyURLShortcut(shortcut)
                || shortcut.length < SimpleRegex.MIN_SHORTCUT_LENGTH) {
                return false;
            }
            this.trie.add(shortcut, storageIdx);
            this.rulesCount += 1;
            return true;
        };
        /**
         * @return total rules count
         */
        TrieLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * For specified request finds matching rules from rules indexes array
         *
         * @param request
         * @param rulesIndexes
         */
        TrieLookupTable.prototype.matchRules = function (request, rulesIndexes) {
            if (!rulesIndexes) {
                return [];
            }
            var result = [];
            for (var j = 0; j < rulesIndexes.length; j += 1) {
                var idx = rulesIndexes[j];
                var rule = this.ruleStorage.retrieveNetworkRule(idx);
                if (rule && rule.match(request, false)) {
                    result.push(rule);
                }
            }
            return result;
        };
        /**
         * Traverses trie
         *
         * @param request
         */
        TrieLookupTable.prototype.traverse = function (request) {
            return this.trie.traverseAll(request.urlLowercase, request.urlLowercase.length);
        };
        /**
         * Checks if the rule potentially matches too many URLs.
         * We'd better use another type of lookup table for this kind of rules.
         *
         * @param shortcut to check
         * @return check result
         */
        TrieLookupTable.isAnyURLShortcut = function (shortcut) {
            // The numbers are basically ("PROTO://".length + 1)
            if (shortcut.length < 6 && shortcut.indexOf('ws:') === 0) {
                return true;
            }
            if (shortcut.length < 7 && shortcut.indexOf('|ws') === 0) {
                return true;
            }
            if (shortcut.length < 9 && shortcut.indexOf('http') === 0) {
                return true;
            }
            return !!(shortcut.length < 10 && shortcut.indexOf('|http') === 0);
        };
        return TrieLookupTable;
    }());

    /**
     * Domain lookup table. Key is the domain name hash.
     */
    var DomainsLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function DomainsLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Domain lookup table. Key is the domain name hash.
             */
            this.domainsLookupTable = new Map();
            this.ruleStorage = storage;
        }
        /**
         * addRule implements the ILookupTable interface for DomainsLookupTable.
         * @param rule
         * @param storageIdx
         */
        DomainsLookupTable.prototype.addRule = function (rule, storageIdx) {
            var _this = this;
            var permittedDomains = rule.getPermittedDomains();
            if (!permittedDomains || permittedDomains.length === 0) {
                return false;
            }
            var hasWildcardDomain = permittedDomains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
            if (hasWildcardDomain) {
                return false;
            }
            permittedDomains.forEach(function (domain) {
                var hash = fastHash(domain);
                // Add the rule to the lookup table
                var rulesIndexes = _this.domainsLookupTable.get(hash);
                if (!rulesIndexes) {
                    rulesIndexes = [];
                }
                rulesIndexes.push(storageIdx);
                _this.domainsLookupTable.set(hash, rulesIndexes);
            });
            this.rulesCount += 1;
            return true;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        DomainsLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        DomainsLookupTable.prototype.matchAll = function (request) {
            var result = [];
            if (!request.sourceHostname) {
                return result;
            }
            var domains = request.subdomains;
            if (request.hostname !== request.sourceHostname) {
                domains.push.apply(domains, request.sourceSubdomains);
            }
            for (var i = 0; i < domains.length; i += 1) {
                var hash = fastHash(domains[i]);
                var rulesIndexes = this.domainsLookupTable.get(hash);
                if (rulesIndexes) {
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            }
            return result;
        };
        return DomainsLookupTable;
    }());

    /**
     * Hostname lookup table.
     * For specific kind of rules like '||hostname^' and '||hostname/path' more simple algorithm with hashes is faster.
     */
    var HostnameLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function HostnameLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Domain lookup table. Key is the domain name hash.
             */
            this.hostnameLookupTable = new Map();
            this.ruleStorage = storage;
        }
        /**
         * addRule implements the ILookupTable interface for DomainsLookupTable.
         * @param rule
         * @param storageIdx
         */
        HostnameLookupTable.prototype.addRule = function (rule, storageIdx) {
            var pattern = rule.getPattern();
            var hostname = '';
            // Pattern: '||example.org^'
            if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.endsWith(SimpleRegex.MASK_SEPARATOR)) {
                hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, pattern.length - SimpleRegex.MASK_SEPARATOR.length);
            }
            // Pattern: '||example.org/path'
            if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.indexOf(SimpleRegex.MASK_BACKSLASH) !== -1) {
                var end = pattern.indexOf(SimpleRegex.MASK_BACKSLASH);
                hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, end);
            }
            if (!HostnameLookupTable.isValidHostname(hostname)) {
                return false;
            }
            var hash = fastHash(hostname);
            var rulesIndexes = this.hostnameLookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = new Array();
                this.hostnameLookupTable.set(hash, rulesIndexes);
            }
            rulesIndexes.push(storageIdx);
            this.rulesCount += 1;
            return true;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        HostnameLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        HostnameLookupTable.prototype.matchAll = function (request) {
            var result = [];
            var domains = request.subdomains;
            for (var i = 0; i < domains.length; i += 1) {
                var hash = fastHash(domains[i]);
                var rulesIndexes = this.hostnameLookupTable.get(hash);
                if (rulesIndexes) {
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            }
            return result;
        };
        /**
         * Checks if this hostname string is valid
         *
         * @param hostname
         */
        HostnameLookupTable.isValidHostname = function (hostname) {
            if (!hostname) {
                return false;
            }
            if (hostname.indexOf(SimpleRegex.MASK_ANY_CHARACTER) !== -1) {
                return false;
            }
            if (hostname.indexOf('.') < 0 || hostname.endsWith('.')) {
                return false;
            }
            return true;
        };
        return HostnameLookupTable;
    }());

    /**
     * Sequence scan lookup table of rules for which we could not find a shortcut
     * and could not place it to the shortcuts lookup table.
     * In common case of rule there is always a way to just check a rule.match().
     */
    var SeqScanLookupTable = /** @class */ (function () {
        function SeqScanLookupTable() {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Rules for which we could not find a shortcut and could not place it to the shortcuts lookup table.
             */
            this.rules = [];
        }
        /**
         * addRule implements the ILookupTable interface for SeqScanLookupTable.
         * @param rule
         */
        SeqScanLookupTable.prototype.addRule = function (rule) {
            if (!this.rules.includes(rule)) {
                this.rules.push(rule);
                this.rulesCount += 1;
                return true;
            }
            return false;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        SeqScanLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        SeqScanLookupTable.prototype.matchAll = function (request) {
            var result = [];
            for (var i = 0; i < this.rules.length; i += 1) {
                var r = this.rules[i];
                if (r.match(request)) {
                    result.push(r);
                }
            }
            return result;
        };
        return SeqScanLookupTable;
    }());

    /**
     * NetworkEngine is the engine that supports quick search over network rules
     */
    var NetworkEngine = /** @class */ (function () {
        /**
         * Builds an instance of the network engine
         *
         * @param storage an object for a rules storage.
         * @param skipStorageScan create an instance without storage scanning.
         */
        function NetworkEngine(storage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = storage;
            this.rulesCount = 0;
            this.domainsLookupTable = new DomainsLookupTable(storage);
            this.hostnameLookupTable = new HostnameLookupTable(storage);
            this.shortcutsLookupTable = new TrieLookupTable(storage);
            this.seqScanLookupTable = new SeqScanLookupTable();
            if (skipStorageScan) {
                return;
            }
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule
                    && indexedRule.rule instanceof NetworkRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
        /**
         * Match searches over all filtering rules loaded to the engine
         * It returns rule if a match was found alongside the matching rule
         *
         * @param request to check
         * @return rule matching request or null
         */
        NetworkEngine.prototype.match = function (request) {
            var networkRules = this.matchAll(request);
            if (networkRules.length === 0) {
                return null;
            }
            var result = new MatchingResult(networkRules, null);
            return result.getBasicResult();
        };
        /**
         * Finds all rules matching the specified request regardless of the rule types
         * It will find both allowlist and blacklist rules
         *
         * @param request to check
         * @return array of matching rules
         */
        NetworkEngine.prototype.matchAll = function (request) {
            // First check by shortcuts
            var result = this.hostnameLookupTable.matchAll(request);
            result.push.apply(result, (this.shortcutsLookupTable.matchAll(request)));
            result.push.apply(result, (this.domainsLookupTable.matchAll(request)));
            result.push.apply(result, (this.seqScanLookupTable.matchAll(request)));
            return result;
        };
        /**
         * Adds rule to the network engine
         *
         * @param rule
         * @param storageIdx
         */
        NetworkEngine.prototype.addRule = function (rule, storageIdx) {
            if (!this.hostnameLookupTable.addRule(rule, storageIdx)) {
                if (!this.shortcutsLookupTable.addRule(rule, storageIdx)) {
                    if (!this.domainsLookupTable.addRule(rule, storageIdx)) {
                        this.seqScanLookupTable.addRule(rule, storageIdx);
                    }
                }
            }
            this.rulesCount += 1;
        };
        return NetworkEngine;
    }());

    /**
     * Request represents a web request with all it's necessary properties
     */
    var Request$1 = /** @class */ (function () {
        /**
         * Creates an instance of a Request
         *
         * @param url - request URL
         * @param sourceUrl - source URL
         * @param requestType - request type
         *
         * @throws
         */
        function Request(url, sourceUrl, requestType) {
            /**
             * the request is for a given Hostname, and not for a URL, and we don't really know what protocol it is.
             * This can be true for DNS requests, or for HTTP CONNECT, or SNI matching.
             */
            this.isHostnameRequest = false;
            this.url = url;
            this.requestType = requestType;
            this.urlLowercase = Request.compactUrl(url).toLowerCase();
            this.sourceUrl = Request.compactUrl(sourceUrl);
            var tldResult = parse(url);
            this.hostname = tldResult.hostname;
            this.domain = tldResult.domain;
            this.subdomains = Request.getSubdomains(tldResult);
            if (sourceUrl) {
                var sourceTldResult = parse(sourceUrl);
                this.sourceHostname = sourceTldResult.hostname;
                this.sourceDomain = sourceTldResult.domain;
                this.sourceSubdomains = Request.getSubdomains(sourceTldResult);
            }
            else {
                this.sourceHostname = null;
                this.sourceDomain = null;
                this.sourceSubdomains = [];
            }
            if (this.sourceDomain) {
                this.thirdParty = this.domain !== this.sourceDomain;
            }
            else {
                this.thirdParty = null;
            }
        }
        /**
         * We cut the url in performance purposes
         * @param url
         */
        Request.compactUrl = function (url) {
            var compacted = url;
            if (compacted && compacted.length > Request.MAX_URL_MATCH_LENGTH) {
                compacted = compacted.substring(0, Request.MAX_URL_MATCH_LENGTH);
            }
            return compacted;
        };
        /**
        * Splits subdomains and returns all subdomains (including the hostname itself)
        *
        * @param tldResult
        * @returns array of subdomains
        */
        Request.getSubdomains = function (tldResult) {
            var domain = tldResult.domain, hostname = tldResult.hostname, subdomain = tldResult.subdomain, publicSuffix = tldResult.publicSuffix;
            var subdomainsResult = [];
            if (!domain) {
                if (hostname) {
                    subdomainsResult.push(hostname);
                    return subdomainsResult;
                }
                return [];
            }
            if (publicSuffix) {
                subdomainsResult.push(publicSuffix);
            }
            subdomainsResult.push(domain);
            if (!subdomain) {
                return subdomainsResult;
            }
            var parts = subdomain.split('.');
            var incrementDomain = domain;
            for (var i = parts.length - 1; i >= 0; i -= 1) {
                incrementDomain = "".concat(parts[i], ".").concat(incrementDomain);
                subdomainsResult.push(incrementDomain);
            }
            return subdomainsResult;
        };
        /**
         * Max url length for matching
         * Some urls are really long and slow down matching, so we cut them to this length.
         */
        Request.MAX_URL_MATCH_LENGTH = 2000;
        return Request;
    }());

    /**
     * DnsResult contains a network rule and host rules matching request
     */
    var DnsResult = /** @class */ (function () {
        function DnsResult() {
            /**
             * BasicRule - a network rule matching the request.
             */
            this.basicRule = null;
            /**
             * Host rules
             */
            this.hostRules = [];
        }
        return DnsResult;
    }());

    /**
     * DNSEngine combines host rules and network rules and is supposed to quickly find
     * matching rules for hostnames.
     * First, it looks over network rules and returns first rule found.
     * Then, if nothing found, it looks up the host rules.
     */
    var DnsEngine = /** @class */ (function () {
        /**
         * Builds an instance of dns engine
         *
         * @param storage
         */
        function DnsEngine(storage) {
            this.ruleStorage = storage;
            this.rulesCount = 0;
            this.lookupTable = new Map();
            this.networkEngine = new NetworkEngine(storage, true);
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.HostRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule) {
                    if (indexedRule.rule instanceof HostRule) {
                        this.addRule(indexedRule.rule, indexedRule.index);
                    }
                    else if (indexedRule.rule instanceof NetworkRule
                        && indexedRule.rule.isHostLevelNetworkRule()) {
                        this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                    }
                }
            }
        }
        /**
         * Match searches over all filtering and host rules loaded to the engine
         *
         * @param hostname to check
         * @return dns result object
         */
        DnsEngine.prototype.match = function (hostname) {
            var result = new DnsResult();
            if (!hostname) {
                return result;
            }
            var url = "http://".concat(hostname, "/");
            var request = new Request$1(url, url, exports.RequestType.Document);
            request.isHostnameRequest = true;
            var networkRule = this.networkEngine.match(request);
            if (networkRule) {
                // Network rules always have higher priority
                result.basicRule = networkRule;
                return result;
            }
            var hash = fastHash(hostname);
            var rulesIndexes = this.lookupTable.get(hash);
            if (rulesIndexes) {
                for (var j = 0; j < rulesIndexes.length; j += 1) {
                    var rule = this.ruleStorage.retrieveHostRule(rulesIndexes[j]);
                    if (rule && rule.match(hostname)) {
                        result.hostRules.push(rule);
                    }
                }
            }
            return result;
        };
        /**
         * Adds rule to engine
         *
         * @param rule
         * @param storageIdx
         */
        DnsEngine.prototype.addRule = function (rule, storageIdx) {
            var _this = this;
            rule.getHostnames().forEach(function (hostname) {
                var hash = fastHash(hostname);
                // Add the rule to the lookup table
                var rulesIndexes = _this.lookupTable.get(hash);
                if (!rulesIndexes) {
                    rulesIndexes = [];
                }
                rulesIndexes.push(storageIdx);
                _this.lookupTable.set(hash, rulesIndexes);
            });
            this.rulesCount += 1;
        };
        return DnsEngine;
    }());

    var lru = {exports: {}};

    (function (module, exports) {
    	!function(g,c){c(exports);}(commonjsGlobal,function(g){const c=Symbol("newer"),e=Symbol("older");class n{constructor(a,b){typeof a!=="number"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size));}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a;}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error("overflow")}this.newest=b,this.size=this._keymap.size;}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear();}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!=="object"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c];}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a="",b=this.oldest;b;)a+=String(b.key)+":"+b.value,b=b[c],b&&(a+=" < ");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0;}function i(a){this.entry=a;}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a;}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a;}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}};});
    	
    } (lru, lru.exports));

    /**
     * CosmeticLookupTable lets quickly lookup cosmetic rules for the specified hostname.
     * It is primarily used by the {@see CosmeticEngine}.
     */
    var CosmeticLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function CosmeticLookupTable(storage) {
            this.byHostname = new Map();
            this.wildcardRules = [];
            this.genericRules = [];
            this.allowlist = new Map();
            this.ruleStorage = storage;
        }
        /**
         * Adds rule to the appropriate collection
         * @param rule
         * @param storageIdx
         */
        CosmeticLookupTable.prototype.addRule = function (rule, storageIdx) {
            if (rule.isAllowlist()) {
                var key = rule.getContent();
                var existingRules = this.allowlist.get(key) || [];
                existingRules.push(storageIdx);
                this.allowlist.set(key, existingRules);
                return;
            }
            if (rule.isGeneric()) {
                this.genericRules.push(rule);
                return;
            }
            var domains = rule.getPermittedDomains();
            if (domains) {
                var hasWildcardDomain = domains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
                if (hasWildcardDomain) {
                    this.wildcardRules.push(rule);
                    return;
                }
                for (var _i = 0, domains_1 = domains; _i < domains_1.length; _i++) {
                    var domain = domains_1[_i];
                    var tldResult = parse(domain);
                    // tldResult.domain equals to eTLD domain,
                    // e.g. sub.example.uk.org would result in example.uk.org
                    var parsedDomain = tldResult.domain || domain;
                    var key = fastHash(parsedDomain);
                    var rules = this.byHostname.get(key) || [];
                    rules.push(storageIdx);
                    this.byHostname.set(key, rules);
                }
            }
        };
        /**
         * Finds rules by hostname
         * @param request
         * @param subdomains
         */
        CosmeticLookupTable.prototype.findByHostname = function (request) {
            var result = [];
            var subdomains = request.subdomains;
            var _loop_1 = function (i) {
                var subdomain = subdomains[i];
                var rulesIndexes = this_1.byHostname.get(fastHash(subdomain));
                if (rulesIndexes) {
                    // Filtering out duplicates
                    rulesIndexes = rulesIndexes.filter(function (v, index) { return rulesIndexes.indexOf(v) === index; });
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this_1.ruleStorage.retrieveRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            };
            var this_1 = this;
            // Iterate over all sub-domains
            for (var i = 0; i < subdomains.length; i += 1) {
                _loop_1(i);
            }
            result.push.apply(result, this.wildcardRules.filter(function (r) { return r.match(request); }));
            return result.filter(function (rule) { return !rule.isAllowlist(); });
        };
        /**
         * Checks if the rule is disabled on the specified hostname.
         * @param request
         * @param rule
         */
        CosmeticLookupTable.prototype.isAllowlisted = function (request, rule) {
            var rulesIndexes = this.allowlist.get(rule.getContent());
            if (!rulesIndexes) {
                return false;
            }
            for (var j = 0; j < rulesIndexes.length; j += 1) {
                var r = this.ruleStorage.retrieveRule(rulesIndexes[j]);
                if (r && r.match(request)) {
                    return true;
                }
            }
            return false;
        };
        return CosmeticLookupTable;
    }());

    /**
     * Enumeration with the cosmetic rules markers.
     *
     * All cosmetic rules have similar structure:
     * ```
     * rule = [domains] "marker" content
     * domains = [domain0, domain1[, ...[, domainN]]]
     * ```
     *
     * For instance, element hiding rules look like:
     * `example.org##.banner`
     *
     * In this case:
     * * `[domains]` is `example.org` (comma-separated list of domains)
     * * `marker` is `##` (marker of element hiding rules)
     * * `content` is `.banner` (CSS selector)
     */
    exports.CosmeticRuleMarker = void 0;
    (function (CosmeticRuleMarker) {
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-elemhide-rules */
        CosmeticRuleMarker["ElementHiding"] = "##";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules-exceptions */
        CosmeticRuleMarker["ElementHidingException"] = "#@#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors */
        CosmeticRuleMarker["ElementHidingExtCSS"] = "#?#";
        /** Basically the same as {@link CosmeticRuleMarker.ElementHidingException} */
        CosmeticRuleMarker["ElementHidingExtCSSException"] = "#@?#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules */
        CosmeticRuleMarker["Css"] = "#$#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules-exceptions */
        CosmeticRuleMarker["CssException"] = "#@$#";
        /**
         * CSS rules that use extended CSS selectors:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors
         */
        CosmeticRuleMarker["CssExtCSS"] = "#$?#";
        /** Basically the same as {@link CosmeticRuleMarker.CssException} */
        CosmeticRuleMarker["CssExtCSSException"] = "#@$?#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules */
        CosmeticRuleMarker["Js"] = "#%#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules-exceptions-1 */
        CosmeticRuleMarker["JsException"] = "#@%#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules */
        CosmeticRuleMarker["Html"] = "$$";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules-exceptions-1 */
        CosmeticRuleMarker["HtmlException"] = "$@$";
    })(exports.CosmeticRuleMarker || (exports.CosmeticRuleMarker = {}));
    /**
     * findCosmeticRuleMarker looks for a cosmetic rule marker in the rule text
     * and returns the start index of the marker and the marker found.
     * If nothing found, it returns -1 and null.
     *
     * @privateRemarks
     *
     * The idea is to search for the rule marker as quickly as possible.
     * If we were simply using `Array.includes` we had to call it a dozen of times (for every marker),
     * and that'd have been much slower.
     *
     * @param ruleText - rule text to scan.
     */
    function findCosmeticRuleMarker(ruleText) {
        var maxIndex = ruleText.length - 1;
        for (var i = 0; i < maxIndex; i += 1) {
            var char = ruleText.charAt(i);
            switch (char) {
                case '#':
                    if (i + 4 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '$'
                            && ruleText.charAt(i + 3) === '?'
                            && ruleText.charAt(i + 4) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssExtCSSException];
                        }
                    }
                    if (i + 3 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingExtCSSException];
                        }
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '$' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssException];
                        }
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '%' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.JsException];
                        }
                        if (ruleText.charAt(i + 1) === '$'
                            && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssExtCSS];
                        }
                    }
                    if (i + 2 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingException];
                        }
                        if (ruleText.charAt(i + 1) === '?' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingExtCSS];
                        }
                        if (ruleText.charAt(i + 1) === '%' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.Js];
                        }
                        if (ruleText.charAt(i + 1) === '$' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.Css];
                        }
                    }
                    if (i + 1 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '#') {
                            // Handling false positives while looking for cosmetic rules in host files.
                            //
                            // For instance, it could look like this:
                            // 127.0.0.1 localhost ## this is just a comment
                            if (i > 0 && ruleText.charAt(i - 1) === ' ') {
                                return [-1, null];
                            }
                            return [i, exports.CosmeticRuleMarker.ElementHiding];
                        }
                    }
                    break;
                case '$':
                    if (i + 2 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '$') {
                            return [i, exports.CosmeticRuleMarker.HtmlException];
                        }
                    }
                    if (i + 1 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '$') {
                            return [i, exports.CosmeticRuleMarker.Html];
                        }
                    }
                    break;
            }
        }
        return [-1, null];
    }
    /**
     * Detects is the rule is extended css rule
     * @param marker - string to check
     */
    function isExtCssMarker(marker) {
        var EXTENDED_CSS_MARKERS = [
            exports.CosmeticRuleMarker.CssExtCSS,
            exports.CosmeticRuleMarker.CssExtCSSException,
            exports.CosmeticRuleMarker.ElementHidingExtCSS,
            exports.CosmeticRuleMarker.ElementHidingExtCSSException,
        ];
        return EXTENDED_CSS_MARKERS.indexOf(marker) !== -1;
    }
    /**
     * AdGuard scriptlet rule mask
     */
    var ADG_SCRIPTLET_MASK = '//scriptlet';

    var CosmeticRuleModifiers;
    (function (CosmeticRuleModifiers) {
        CosmeticRuleModifiers["Path"] = "path";
        CosmeticRuleModifiers["Domain"] = "domain";
    })(CosmeticRuleModifiers || (CosmeticRuleModifiers = {}));
    var CosmeticRuleModifiersSyntax = {
        OpenBracket: '[',
        CloseBracket: ']',
        SpecialSymbol: '$',
        Delimiter: ',',
        Assigner: '=',
        EscapeCharacter: '\\',
    };

    var cosmeticRuleModifiersList = Object.values(CosmeticRuleModifiers);
    /**
     * Helper class for parsing text of cosmetic rules
     * used by CosmeticRule and [Filter compiler](https://github.com/AdguardTeam/FiltersCompiler)
     *
     *
     * The cosmetic rule contains of the following parts:
     *
     * `pattern##content`
     *
     * `pattern` contains the list of the rule modifiers and domains.
     *
     * `##` is a marker (might be a different marker depending on the rule type).
     * You can find the list of markers in the CosmeticRuleMarker enumeration.
     *
     * `content` might be a CSS selector, a scriptlet or something else, depending on the rule type.
     */
    var CosmeticRuleParser = /** @class */ (function () {
        function CosmeticRuleParser() {
        }
        /**
         * Parse the rule's pattern, cosmetic marker and the content parts from the rule text.
         * If the content is empty, throws a SyntaxError.
         *
         * @param ruleText
         * @returns Object with pattern, marker and content text parts
         */
        CosmeticRuleParser.parseRuleTextByMarker = function (ruleText) {
            var _a = findCosmeticRuleMarker(ruleText), markerIndex = _a[0], marker = _a[1];
            if (marker === null) {
                throw new SyntaxError('Not a cosmetic rule');
            }
            var content = ruleText.substring(markerIndex + marker.length).trim();
            if (!content) {
                throw new SyntaxError('Rule content is empty');
            }
            var pattern;
            if (markerIndex > 0) {
                pattern = ruleText.substring(0, markerIndex);
            }
            return {
                pattern: pattern,
                marker: marker,
                content: content,
            };
        };
        /**
         * Extracts the rule modifiers and domains from the rule pattern.
         * @param rulePattern
         * @returns Object with modifiers and domains text parts
         */
        CosmeticRuleParser.parseRulePatternText = function (rulePattern) {
            var OpenBracket = CosmeticRuleModifiersSyntax.OpenBracket, CloseBracket = CosmeticRuleModifiersSyntax.CloseBracket, SpecialSymbol = CosmeticRuleModifiersSyntax.SpecialSymbol, EscapeCharacter = CosmeticRuleModifiersSyntax.EscapeCharacter;
            if (!rulePattern.startsWith("".concat(OpenBracket + SpecialSymbol))) {
                return { domainsText: rulePattern };
            }
            var closeBracketIndex;
            // The first two characters cannot be closing brackets
            for (var i = 2; i < rulePattern.length; i += 1) {
                if (rulePattern[i] === CloseBracket && rulePattern[i - 1] !== EscapeCharacter) {
                    closeBracketIndex = i;
                    break;
                }
            }
            if (!closeBracketIndex) {
                throw new SyntaxError('Can\'t parse modifiers list');
            }
            // Handle this case: `[$]`
            if (closeBracketIndex === 2) {
                throw new SyntaxError('Modifiers list can\'t be empty');
            }
            var modifiersText = rulePattern.slice(2, closeBracketIndex);
            var domainsText;
            if (closeBracketIndex < rulePattern.length - 1) {
                domainsText = rulePattern.slice(closeBracketIndex + 1);
            }
            return {
                modifiersText: modifiersText,
                domainsText: domainsText,
            };
        };
        /**
         * Parses the list of modifiers. Parsing is done in the same way as it's done in the NetworkRule, i.e.
         * we have a comma-separated list of modifier-value pairs.
         * If we encounter an invalid modifier, this method throws a SyntaxError.
         *
         * @param modifiersText - list of modifiers splited by comma
         * @returns - modifiers collection object
         */
        CosmeticRuleParser.parseRuleModifiers = function (modifiersText) {
            if (!modifiersText) {
                return null;
            }
            var EscapeCharacter = CosmeticRuleModifiersSyntax.EscapeCharacter, Delimiter = CosmeticRuleModifiersSyntax.Delimiter, Assigner = CosmeticRuleModifiersSyntax.Assigner;
            var modifiersTextArray = splitByDelimiterWithEscapeCharacter(modifiersText, Delimiter, EscapeCharacter, false, false);
            var modifiers = Object.create(null);
            for (var i = 0; i < modifiersTextArray.length; i += 1) {
                var modifierText = modifiersTextArray[i];
                var assignerIndex = modifierText.indexOf(Assigner);
                if (assignerIndex === -1) {
                    throw new SyntaxError('Modifier must have assigned value');
                }
                var modifierKey = modifierText.substring(0, assignerIndex);
                if (cosmeticRuleModifiersList.includes(modifierKey)) {
                    var modifierValue = modifierText.substring(assignerIndex + 1);
                    modifiers[modifierKey] = modifierValue;
                }
                else {
                    throw new SyntaxError("'".concat(modifierKey, "' is not valid modifier"));
                }
            }
            return modifiers;
        };
        /**
         * Parses the rule pattern and extracts the permitted/restricted domains and the unescaped path modifier value,
         * If domains are declared through $domain modifier and pattern domain list, this method throws a SyntaxError.
         * @param rulePattern - rule pattern text
         *
         * @returns Object with permitted/restricted domains list and the path modifier string value
         */
        CosmeticRuleParser.parseRulePattern = function (rulePattern) {
            var _a = CosmeticRuleParser.parseRulePatternText(rulePattern), domainsText = _a.domainsText, modifiersText = _a.modifiersText;
            var domains = domainsText;
            var path;
            var modifiers = CosmeticRuleParser.parseRuleModifiers(modifiersText);
            if (modifiers) {
                if (modifiers.path) {
                    path = modifiers.path;
                    if (SimpleRegex.isRegexPattern(path)) {
                        path = SimpleRegex.unescapeRegexSpecials(path, SimpleRegex.reModifierPatternEscapedSpecialCharacters);
                    }
                }
                if (modifiers.domain) {
                    if (domains) {
                        throw new SyntaxError('The $domain modifier is not allowed in a domain-specific rule');
                    }
                    else {
                        domains = modifiers.domain;
                    }
                }
            }
            var permittedDomains;
            var restrictedDomains;
            // Skip wildcard domain
            if (domains && domains !== SimpleRegex.MASK_ANY_CHARACTER) {
                var separator = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.domain) ? PIPE_SEPARATOR : COMMA_SEPARATOR;
                var domainModifier = new DomainModifier(domains, separator);
                if (domainModifier.permittedDomains) {
                    permittedDomains = domainModifier.permittedDomains;
                }
                if (domainModifier.restrictedDomains) {
                    restrictedDomains = domainModifier.restrictedDomains;
                }
            }
            return {
                path: path,
                permittedDomains: permittedDomains,
                restrictedDomains: restrictedDomains,
            };
        };
        return CosmeticRuleParser;
    }());

    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Scriptlets helper class
     */
    // eslint-disable-next-line max-classes-per-file
    var ScriptletParser = /** @class */ (function () {
        function ScriptletParser() {
        }
        /**
         * Iterate over iterable argument and evaluate current state with transitions
         *
         * @param {Array|Collection|string} iterable
         * @param {Object} transitions transition functions
         * @param {string} initState first transition name
         * @param {any} args arguments which should be passed to transition functions
         * @returns {string} transition
         */
        ScriptletParser.iterateWithTransitions = function (iterable, transitions, initState, args) {
            var state = initState;
            for (var i = 0; i < iterable.length; i += 1) {
                state = transitions[state](iterable, i, args);
            }
            return state;
        };
        /**
         * Parse and validate scriptlet rule
         * @param {*} ruleContent
         * @returns {{name: string, args: Array<string>}}
         */
        ScriptletParser.parseRule = function (ruleContent) {
            var _a;
            var transitions = (_a = {},
                _a[ScriptletParser.TRANSITION.OPENED] = ScriptletParser.opened,
                _a[ScriptletParser.TRANSITION.PARAM] = ScriptletParser.param,
                _a[ScriptletParser.TRANSITION.CLOSED] = function () { },
                _a);
            var sep = { symb: null };
            var saver = new ScriptletParser.WordSaver();
            var state = ScriptletParser.iterateWithTransitions(ruleContent, transitions, ScriptletParser.TRANSITION.OPENED, { sep: sep, saver: saver });
            if (state !== 'closed') {
                throw new Error("Invalid scriptlet ".concat(ruleContent));
            }
            var args = saver.getAll();
            return {
                name: args[0],
                args: args.slice(1),
            };
        };
        /**
         * Helper class to accumulate an array of strings char by char
         */
        ScriptletParser.WordSaver = /** @class */ (function () {
            function class_1() {
                /**
                 * String cursor
                 */
                this.str = '';
                /**
                 * Strings array
                 */
                this.collectedStrings = [];
            }
            /**
             * Saves symbol to cursor
             *
             * @param s
             */
            class_1.prototype.saveSymbol = function (s) {
                this.str += s;
            };
            /**
             * Saves cursor to strings
             */
            class_1.prototype.saveStr = function () {
                this.collectedStrings.push(this.str);
                this.str = '';
            };
            /**
             * Returns collected strings
             */
            class_1.prototype.getAll = function () {
                return __spreadArray([], this.collectedStrings, true);
            };
            return class_1;
        }());
        /**
         * Transition names
         */
        ScriptletParser.TRANSITION = {
            OPENED: 'opened',
            PARAM: 'param',
            CLOSED: 'closed',
        };
        /**
         * Transition function: the current index position in start, end or between params
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop symb with current separator char
         * @returns {string} transition
         */
        ScriptletParser.opened = function (rule, index, _a) {
            var sep = _a.sep;
            var char = rule[index];
            switch (char) {
                case ' ':
                case '(':
                case ',':
                    return ScriptletParser.TRANSITION.OPENED;
                case '\'':
                case '"':
                    // eslint-disable-next-line no-param-reassign
                    sep.symb = char;
                    return ScriptletParser.TRANSITION.PARAM;
                case ')':
                    return index === rule.length - 1
                        ? ScriptletParser.TRANSITION.CLOSED
                        : ScriptletParser.TRANSITION.OPENED;
            }
            return undefined;
        };
        /**
         * Transition function: the current index position inside param
         *
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop `symb` with current separator char
         * @property {Object} Object.saver helper which allow to save strings by car by char
         * @returns {string} transition
         */
        ScriptletParser.param = function (rule, index, _a) {
            var saver = _a.saver, sep = _a.sep;
            var char = rule[index];
            switch (char) {
                case '\'':
                case '"':
                    if (char === sep.symb && rule[index - 1] !== '\\') {
                        // eslint-disable-next-line no-param-reassign
                        sep.symb = null;
                        saver.saveStr();
                        return ScriptletParser.TRANSITION.OPENED;
                    }
                    saver.saveSymbol(char);
                    return ScriptletParser.TRANSITION.PARAM;
                default:
                    saver.saveSymbol(char);
                    return ScriptletParser.TRANSITION.PARAM;
            }
        };
        return ScriptletParser;
    }());

    /**
     * CosmeticRuleType is an enumeration of the possible
     * cosmetic rule types.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
     */
    exports.CosmeticRuleType = void 0;
    (function (CosmeticRuleType) {
        /**
         * Cosmetic rules that just hide page elements.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules
         */
        CosmeticRuleType[CosmeticRuleType["ElementHiding"] = 0] = "ElementHiding";
        /**
         * Cosmetic rules that allow adding custom CSS styles.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules
         */
        CosmeticRuleType[CosmeticRuleType["Css"] = 1] = "Css";
        /**
         * Cosmetic rules that allow executing custom JS scripts.
         * Some restrictions are applied to this type of rules by default.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
         */
        CosmeticRuleType[CosmeticRuleType["Js"] = 2] = "Js";
        /**
         * Special type of rules that allows filtering HTML code of web pages.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
         */
        CosmeticRuleType[CosmeticRuleType["Html"] = 3] = "Html";
    })(exports.CosmeticRuleType || (exports.CosmeticRuleType = {}));
    /**
     * Pseudo class indicators. They are used to detect if rule is extended or not even if rule does not
     * have extended css marker
     */
    var EXT_CSS_PSEUDO_INDICATORS = ['[-ext-has=', '[-ext-contains=', '[-ext-has-text=',
        '[-ext-matches-css=', '[-ext-matches-css-before=', '[-ext-matches-css-after=', ':has(', ':has-text(',
        ':contains(', ':matches-css(', ':matches-css-before(', ':matches-css-after(', ':-abp-has(', ':-abp-contains(',
        ':if(', ':if-not(', ':xpath(', ':nth-ancestor(', ':upward(', ':remove(',
        ':matches-attr(', ':matches-property(', ':is('];
    /**
     * Implements a basic cosmetic rule.
     *
     * Cosmetic rules syntax are almost similar and looks like this:
     * ```
     * rule = [domains] "marker" content
     * domains = [domain0, domain1[, ...[, domainN]]]
     * ```
     *
     * The rule type is defined by the `marker` value, you can find the list of them
     * in the {@see CosmeticRuleMarker} enumeration.
     *
     * What matters, though, is what's in the `content` part of it.
     *
     * Examples:
     * * `example.org##.banner` -- element hiding rule
     * * `example.org#$#.banner { display: block; }` -- CSS rule
     * * `example.org#%#window.x=1;` -- JS rule
     * * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
     * * `example.org$$div[id="test"]` -- HTML filtering rule
     */
    var CosmeticRule = /** @class */ (function () {
        /**
         * Creates an instance of the {@link CosmeticRule}.
         * It parses the rule and extracts the permitted/restricted domains,
         * and also the cosmetic rule's content.
         *
         * Depending on the rule type, the content might be transformed in
         * one of the helper classes, or kept as string when it's appropriate.
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function CosmeticRule(ruleText, filterListId) {
            this.allowlist = false;
            this.extendedCss = false;
            this.permittedDomains = undefined;
            this.restrictedDomains = undefined;
            /**
             * Js script to execute
             */
            this.script = undefined;
            /**
             * Js script to execute - debug
             */
            this.scriptVerbose = undefined;
            /**
             * Needed to avoid reinvoking scriptVerbose for scriptlets rules
             */
            this.verboseInvokedForDomain = undefined;
            /**
             * Object with script code ready to execute and debug, domain values
             * @private
             */
            this.scriptData = null;
            /**
             * Object with scriptlet function and params
             * @private
             */
            this.scriptletData = null;
            /**
             * If the rule contains scriptlet content
             */
            this.isScriptlet = false;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var _a = CosmeticRuleParser.parseRuleTextByMarker(ruleText), pattern = _a.pattern, marker = _a.marker, content = _a.content;
            this.content = content;
            this.type = CosmeticRule.parseType(marker);
            this.extendedCss = isExtCssMarker(marker);
            if (!this.extendedCss
                && (this.type === exports.CosmeticRuleType.ElementHiding
                    || this.type === exports.CosmeticRuleType.Css)) {
                // additional check if rule is extended css rule by pseudo class indicators
                for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                    if (this.content.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1) {
                        this.extendedCss = true;
                        break;
                    }
                }
            }
            CosmeticRule.validate(ruleText, this.type, content, this.extendedCss);
            if (pattern) {
                // This means that the marker is preceded by the list of domains and modifiers
                // Now it's a good time to parse them.
                var _b = CosmeticRuleParser.parseRulePattern(pattern), path = _b.path, permittedDomains = _b.permittedDomains, restrictedDomains = _b.restrictedDomains;
                if (path) {
                    this.pathModifier = new Pattern(path);
                }
                if (permittedDomains) {
                    this.permittedDomains = permittedDomains;
                }
                if (restrictedDomains) {
                    this.restrictedDomains = restrictedDomains;
                }
            }
            this.allowlist = CosmeticRule.parseAllowlist(marker);
            this.isScriptlet = this.content.startsWith(ADG_SCRIPTLET_MASK);
        }
        /**
         * Parses first pseudo class from the specified CSS selector
         *
         * @param selector
         * @returns pseudo class name if found or null
         */
        CosmeticRule.parsePseudoClass = function (selector) {
            var beginIndex = 0;
            var nameStartIndex = -1;
            var squareBracketIndex = 0;
            while (squareBracketIndex >= 0) {
                nameStartIndex = selector.indexOf(':', beginIndex);
                if (nameStartIndex < 0) {
                    return null;
                }
                if (nameStartIndex > 0 && selector.charAt(nameStartIndex - 1) === '\\') {
                    // Escaped colon character
                    return null;
                }
                squareBracketIndex = selector.indexOf('[', beginIndex);
                while (squareBracketIndex >= 0) {
                    if (nameStartIndex > squareBracketIndex) {
                        var squareEndBracketIndex = selector.indexOf(']', squareBracketIndex + 1);
                        beginIndex = squareEndBracketIndex + 1;
                        if (nameStartIndex < squareEndBracketIndex) {
                            // Means that colon character is somewhere inside attribute selector
                            // Something like a[src^="http://domain.com"]
                            break;
                        }
                        if (squareEndBracketIndex > 0) {
                            squareBracketIndex = selector.indexOf('[', beginIndex);
                        }
                        else {
                            // bad rule, example: a[src="http:
                            return null;
                        }
                    }
                    else {
                        squareBracketIndex = -1;
                        break;
                    }
                }
            }
            var nameEndIndex = indexOfAny(selector, [' ', ',', '\t', '>', '(', '[', '.', '#', ':', '+', '~', '"', '\''], nameStartIndex + 1);
            if (nameEndIndex < 0) {
                nameEndIndex = selector.length;
            }
            var name = selector.substring(nameStartIndex, nameEndIndex);
            if (name.length <= 1) {
                // Either empty name or a pseudo element (like ::content)
                return null;
            }
            return name;
        };
        CosmeticRule.prototype.getText = function () {
            return this.ruleText;
        };
        CosmeticRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Cosmetic rule type (always present)
         */
        CosmeticRule.prototype.getType = function () {
            return this.type;
        };
        /**
         * Allowlist means that this rule is meant to disable other rules.
         * For instance, https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions
         */
        CosmeticRule.prototype.isAllowlist = function () {
            return this.allowlist;
        };
        /**
         * Gets the rule content. The meaning of this field depends on the rule type.
         * For instance, for an element hiding rule, this is just a CSS selector.
         * While, for a CSS rule, this is a CSS selector + style.
         */
        CosmeticRule.prototype.getContent = function () {
            return this.content;
        };
        /**
         * Returns script ready to execute or null
         * Rebuilds scriptlet script if debug or domain params change
         * @param options
         */
        CosmeticRule.prototype.getScript = function (options) {
            var _a, _b;
            if (options === void 0) { options = {}; }
            var _c = options.debug, debug = _c === void 0 ? false : _c, _d = options.request, request = _d === void 0 ? null : _d;
            var scriptData = this.scriptData;
            if (scriptData && !this.isScriptlet) {
                return scriptData.code;
            }
            if (scriptData && scriptData.debug === debug) {
                if (request) {
                    if (request.domain === scriptData.domain) {
                        return scriptData.code;
                    }
                }
                else {
                    return scriptData.code;
                }
            }
            this.initScript(options);
            return (_b = (_a = this.scriptData) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : null;
        };
        /**
         * Gets list of permitted domains.
         */
        CosmeticRule.prototype.getPermittedDomains = function () {
            return this.permittedDomains;
        };
        /**
         * Returns true if the rule is considered "generic"
         * "generic" means that the rule is not restricted to a limited set of domains
         * Please note that it might be forbidden on some domains, though.
         *
         * @return {boolean}
         */
        CosmeticRule.prototype.isGeneric = function () {
            return !this.permittedDomains || this.permittedDomains.length === 0;
        };
        /**
         * Gets list of restricted domains.
         */
        CosmeticRule.prototype.getRestrictedDomains = function () {
            return this.restrictedDomains;
        };
        CosmeticRule.prototype.isExtendedCss = function () {
            return this.extendedCss;
        };
        /**
         * Match returns true if this rule can be used on the specified request.
         *
         * @param request - request to check
         */
        CosmeticRule.prototype.match = function (request) {
            if (!this.permittedDomains && !this.restrictedDomains && !this.pathModifier) {
                return true;
            }
            if (this.matchesRestrictedDomains(request.hostname)) {
                /**
                 * Domain or host is restricted
                 * i.e. ~example.org##rule
                 */
                return false;
            }
            if (this.hasPermittedDomains()) {
                if (!DomainModifier.isDomainOrSubdomainOfAny(request.hostname, this.permittedDomains)) {
                    /**
                     * Domain is not among permitted
                     * i.e. example.org##rule and we're checking example.org
                     */
                    return false;
                }
            }
            if (this.pathModifier) {
                var path = getRelativeUrl(request.urlLowercase);
                if (path) {
                    return this.pathModifier.matchPathPattern(path);
                }
                return false;
            }
            return true;
        };
        CosmeticRule.parseType = function (marker) {
            switch (marker) {
                case exports.CosmeticRuleMarker.ElementHiding:
                case exports.CosmeticRuleMarker.ElementHidingExtCSS:
                    return exports.CosmeticRuleType.ElementHiding;
                case exports.CosmeticRuleMarker.ElementHidingException:
                case exports.CosmeticRuleMarker.ElementHidingExtCSSException:
                    return exports.CosmeticRuleType.ElementHiding;
                case exports.CosmeticRuleMarker.Css:
                case exports.CosmeticRuleMarker.CssExtCSS:
                    return exports.CosmeticRuleType.Css;
                case exports.CosmeticRuleMarker.CssException:
                case exports.CosmeticRuleMarker.CssExtCSSException:
                    return exports.CosmeticRuleType.Css;
                case exports.CosmeticRuleMarker.Js:
                    return exports.CosmeticRuleType.Js;
                case exports.CosmeticRuleMarker.JsException:
                    return exports.CosmeticRuleType.Js;
                case exports.CosmeticRuleMarker.Html:
                    return exports.CosmeticRuleType.Html;
                case exports.CosmeticRuleMarker.HtmlException:
                    return exports.CosmeticRuleType.Html;
                default:
                    throw new SyntaxError('Unsupported rule type');
            }
        };
        /**
         * Determines if rule is allowlist rule
         * @param marker
         * @private
         */
        CosmeticRule.parseAllowlist = function (marker) {
            switch (marker) {
                case exports.CosmeticRuleMarker.ElementHidingException:
                case exports.CosmeticRuleMarker.ElementHidingExtCSSException:
                case exports.CosmeticRuleMarker.CssException:
                case exports.CosmeticRuleMarker.CssExtCSSException:
                case exports.CosmeticRuleMarker.JsException:
                case exports.CosmeticRuleMarker.HtmlException:
                    return true;
                default:
                    return false;
            }
        };
        /**
         * Validate pseudo-classes
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validatePseudoClasses = function (ruleText, ruleContent) {
            var pseudoClass = CosmeticRule.parsePseudoClass(ruleContent);
            if (pseudoClass !== null) {
                if (CosmeticRule.SUPPORTED_PSEUDO_CLASSES.indexOf(pseudoClass) < 0) {
                    throw new SyntaxError("Unknown pseudo class: ".concat(ruleContent));
                }
            }
        };
        /**
         * Simple validation for elemhide rules
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validateElemhideRule = function (ruleText, ruleContent) {
            if (ruleText.startsWith(SimpleRegex.MASK_START_URL)) {
                throw new SyntaxError('Element hiding rule shouldn\'t start with "||"');
            }
            if (CosmeticRule.ELEMHIDE_VALIDATION_REGEX.test(ruleContent)) {
                throw new SyntaxError('Invalid elemhide rule, style presented');
            }
        };
        CosmeticRule.validateJsRules = function (ruleText, ruleContent) {
            if (ruleContent.startsWith(ADG_SCRIPTLET_MASK)) {
                if (!scriptlets_umd.exports.isValidScriptletRule(ruleText)) {
                    throw new SyntaxError('Invalid scriptlet');
                }
            }
        };
        /**
         * Validates css injection rules
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validateCssRules = function (ruleText, ruleContent) {
            // Simple validation for css injection rules
            if (!/{.+}/.test(ruleContent)) {
                throw new SyntaxError('Invalid CSS modifying rule, no style presented');
            }
            // discard css inject rules containing "url"
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1196
            if (/{.*url\(.*\)/gi.test(ruleContent)) {
                throw new SyntaxError('CSS modifying rule with \'url\' was omitted');
            }
            // discard css inject rules containing other unsafe selectors
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1920
            if (/{.*image-set\(.*\)/gi.test(ruleContent)
                || /{.*image\(.*\)/gi.test(ruleContent)
                || /{.*cross-fade\(.*\)/gi.test(ruleContent)) {
                throw new SyntaxError('CSS modifying rule with unsafe style was omitted');
            }
            // Prohibit "\" character in style of CSS injection rules
            // Check slash character only after the index of last opening curly brackets
            if (ruleContent.indexOf('\\', ruleContent.lastIndexOf('{')) > -1) {
                throw new SyntaxError('CSS injection rule with \'\\\' was omitted');
            }
        };
        /**
         * Checks if the rule has permitted domains
         */
        CosmeticRule.prototype.hasPermittedDomains = function () {
            return this.permittedDomains != null && this.permittedDomains.length > 0;
        };
        /**
         * Checks if the rule has restricted domains
         */
        CosmeticRule.prototype.hasRestrictedDomains = function () {
            return this.restrictedDomains != null && this.restrictedDomains.length > 0;
        };
        /**
         * Checks if the hostname matches permitted domains
         * @param hostname
         */
        CosmeticRule.prototype.matchesPermittedDomains = function (hostname) {
            return this.hasPermittedDomains() && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains);
        };
        /**
         * Checks if the hostname matches the restricted domains.
         * @param hostname
         */
        CosmeticRule.prototype.matchesRestrictedDomains = function (hostname) {
            return this.hasRestrictedDomains()
                && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.restrictedDomains);
        };
        /**
         * Validates cosmetic rule text
         * @param ruleText
         * @param type
         * @param content
         * @param isExtCss
         * @private
         */
        CosmeticRule.validate = function (ruleText, type, content, isExtCss) {
            if (type !== exports.CosmeticRuleType.Css
                && type !== exports.CosmeticRuleType.Js
                && type !== exports.CosmeticRuleType.Html) {
                CosmeticRule.validatePseudoClasses(ruleText, content);
                if (hasUnquotedSubstring(content, '{')) {
                    throw new SyntaxError('Invalid cosmetic rule, wrong brackets');
                }
            }
            if (type === exports.CosmeticRuleType.ElementHiding) {
                CosmeticRule.validateElemhideRule(ruleText, content);
            }
            if (type === exports.CosmeticRuleType.Css) {
                CosmeticRule.validateCssRules(ruleText, content);
            }
            if (type === exports.CosmeticRuleType.Js) {
                CosmeticRule.validateJsRules(ruleText, content);
            }
            if ((!isExtCss && hasUnquotedSubstring(content, '/*'))
                || hasUnquotedSubstring(content, ' /*')
                || hasUnquotedSubstring(content, ' //')) {
                throw new SyntaxError('Cosmetic rule should not contain comments');
            }
        };
        /**
         * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
         * This method is supposed to be used in the manifest V3 extension.
         */
        CosmeticRule.prototype.getScriptletData = function () {
            if (this.scriptletData) {
                return this.scriptletData;
            }
            this.initScript();
            return this.scriptletData;
        };
        /**
         * Updates this.scriptData and if scriptlet this.scriptletData with js ready to execute
         *
         * @param options
         */
        CosmeticRule.prototype.initScript = function (options) {
            var _a;
            if (options === void 0) { options = {}; }
            var _b = options.debug, debug = _b === void 0 ? false : _b, _c = options.request, request = _c === void 0 ? null : _c;
            var ruleContent = this.getContent();
            if (!this.isScriptlet) {
                this.scriptData = {
                    code: ruleContent,
                };
                return;
            }
            var scriptletContent = ruleContent.substring(ADG_SCRIPTLET_MASK.length);
            var scriptletParams = ScriptletParser.parseRule(scriptletContent);
            var params = {
                args: scriptletParams.args,
                engine: exports.config.engine || '',
                name: scriptletParams.name,
                ruleText: this.getText(),
                verbose: debug,
                domainName: request === null || request === void 0 ? void 0 : request.domain,
                version: exports.config.version || '',
            };
            this.scriptData = {
                code: (_a = scriptlets_umd.exports.invoke(params)) !== null && _a !== void 0 ? _a : null,
                debug: debug,
                domain: request === null || request === void 0 ? void 0 : request.domain,
            };
            this.scriptletData = {
                func: scriptlets_umd.exports.getScriptletFunction(params.name),
                params: params,
            };
        };
        /**
         * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
         * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
         * <p>
         * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
         */
        CosmeticRule.SUPPORTED_PSEUDO_CLASSES = [':active',
            ':checked', ':contains', ':disabled', ':empty', ':enabled', ':first-child', ':first-of-type',
            ':focus', ':has', ':has-text', ':hover', ':if', ':if-not', ':in-range', ':invalid', ':lang',
            ':last-child', ':last-of-type', ':link', ':matches-css', ':matches-css-before', ':matches-css-after',
            ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type',
            ':only-child', ':only-of-type', ':optional', ':out-of-range', ':read-only',
            ':read-write', ':required', ':root', ':target', ':valid', ':visited',
            ':-abp-has', ':-abp-contains', ':xpath', ':nth-ancestor', ':upward', ':remove',
            ':matches-attr', ':matches-property', ':is', ':where'];
        CosmeticRule.ELEMHIDE_VALIDATION_REGEX = / {.+}/;
        return CosmeticRule;
    }());

    /**
     * CosmeticEngine combines all the cosmetic rules and allows to quickly
     * find all rules matching this or that hostname
     * It is primarily used by the {@see Engine}
     */
    var CosmeticEngine = /** @class */ (function () {
        /**
         * Builds instance of cosmetic engine
         *
         * @param ruleStorage
         * @param skipStorageScan create an instance without storage scanning
         */
        function CosmeticEngine(ruleStorage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = ruleStorage;
            this.rulesCount = 0;
            this.elementHidingLookupTable = new CosmeticLookupTable(ruleStorage);
            this.cssLookupTable = new CosmeticLookupTable(ruleStorage);
            this.jsLookupTable = new CosmeticLookupTable(ruleStorage);
            this.htmlLookupTable = new CosmeticLookupTable(ruleStorage);
            if (skipStorageScan) {
                return;
            }
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.CosmeticRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule
                    && indexedRule.rule instanceof CosmeticRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
        /**
         * Adds rules into appropriate tables
         * @param rule
         * @param storageIdx
         */
        CosmeticEngine.prototype.addRule = function (rule, storageIdx) {
            switch (rule.getType()) {
                case exports.CosmeticRuleType.ElementHiding: {
                    this.elementHidingLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Css: {
                    this.cssLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Js: {
                    this.jsLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Html: {
                    this.htmlLookupTable.addRule(rule, storageIdx);
                    break;
                }
            }
            this.rulesCount += 1;
        };
        /**
         * Checks if bitwise mask matches option
         * @param option
         * @param targetOption
         */
        CosmeticEngine.matchOption = function (option, targetOption) {
            return (option & targetOption) === targetOption;
        };
        /**
         * Prepares cosmetic result by request
         *
         * @param request - request to match
         * @param option mask of enabled cosmetic types
         * @return CosmeticResult
         */
        CosmeticEngine.prototype.match = function (request, option) {
            var includeGeneric = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionGenericCSS);
            var includeSpecific = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionSpecificCSS);
            var includeJs = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionJS);
            var includeHtml = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionHtml);
            var cosmeticResult = new CosmeticResult();
            if (includeGeneric) {
                CosmeticEngine.appendGenericRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
                CosmeticEngine.appendGenericRules(cosmeticResult.CSS, this.cssLookupTable, request);
            }
            if (includeSpecific) {
                CosmeticEngine.appendSpecificRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
                CosmeticEngine.appendSpecificRules(cosmeticResult.CSS, this.cssLookupTable, request);
            }
            if (includeJs) {
                CosmeticEngine.appendGenericRules(cosmeticResult.JS, this.jsLookupTable, request);
                CosmeticEngine.appendSpecificRules(cosmeticResult.JS, this.jsLookupTable, request);
            }
            if (includeHtml) {
                if (includeGeneric) {
                    CosmeticEngine.appendGenericRules(cosmeticResult.Html, this.htmlLookupTable, request);
                }
                CosmeticEngine.appendSpecificRules(cosmeticResult.Html, this.htmlLookupTable, request);
            }
            return cosmeticResult;
        };
        /**
         * Selects generic rules and appends rules content to cosmetic result
         * @param cosmeticResult
         * @param lookupTable
         * @param request
         */
        CosmeticEngine.appendGenericRules = function (cosmeticResult, lookupTable, request) {
            for (var _i = 0, _a = lookupTable.genericRules; _i < _a.length; _i++) {
                var genericRule = _a[_i];
                if (!lookupTable.isAllowlisted(request, genericRule)
                    && genericRule.match(request)) {
                    cosmeticResult.append(genericRule, request);
                }
            }
        };
        /**
         * Selects specific rules and appends rules content to cosmetic result
         * @param cosmeticResult
         * @param lookupTable
         * @param request
         */
        CosmeticEngine.appendSpecificRules = function (cosmeticResult, lookupTable, request) {
            var hostnameRules = lookupTable.findByHostname(request);
            if (hostnameRules.length > 0) {
                for (var _i = 0, hostnameRules_1 = hostnameRules; _i < hostnameRules_1.length; _i++) {
                    var rule = hostnameRules_1[_i];
                    if (!lookupTable.isAllowlisted(request, rule)) {
                        cosmeticResult.append(rule, request);
                    }
                }
            }
        };
        return CosmeticEngine;
    }());

    /**
     * Engine represents the filtering engine with all the loaded rules
     */
    var Engine = /** @class */ (function () {
        /**
         * Creates an instance of an Engine
         * Parses the filtering rules and creates a filtering engine of them
         *
         * @param ruleStorage storage
         * @param skipStorageScan create an instance without storage scanning
         * @throws
         */
        function Engine(ruleStorage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = ruleStorage;
            this.networkEngine = new NetworkEngine(ruleStorage, skipStorageScan);
            this.cosmeticEngine = new CosmeticEngine(ruleStorage, skipStorageScan);
            this.resultCache = new lru.exports.LRUMap(Engine.REQUEST_CACHE_SIZE);
        }
        /**
         * Loads rules to engine
         */
        Engine.prototype.loadRules = function () {
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
            while (scanner.scan()) {
                this.addRule(scanner.getRule());
            }
        };
        /**
         * Async loads rules to engine
         *
         * @param chunkSize size of rules chunk to load at a time
         */
        Engine.prototype.loadRulesAsync = function (chunkSize) {
            return __awaiter(this, void 0, void 0, function () {
                var scanner, counter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
                            counter = 0;
                            _a.label = 1;
                        case 1:
                            if (!scanner.scan()) return [3 /*break*/, 4];
                            counter += 1;
                            if (!(counter >= chunkSize)) return [3 /*break*/, 3];
                            counter = 0;
                            /**
                             * In some cases UI thread becomes blocked while adding rules to engine,
                             * that't why we create filter rules using chunks of the specified length
                             * Rules creation is rather slow operation so we should
                             * use setTimeout calls to give UI thread some time.
                             */
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1); })];
                        case 2:
                            /**
                             * In some cases UI thread becomes blocked while adding rules to engine,
                             * that't why we create filter rules using chunks of the specified length
                             * Rules creation is rather slow operation so we should
                             * use setTimeout calls to give UI thread some time.
                             */
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            this.addRule(scanner.getRule());
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Matches the specified request against the filtering engine and returns the matching result.
         *
         * @param request - request to check
         * @param frameRule - source document rule or null
         * @return matching result
         */
        Engine.prototype.matchRequest = function (request, frameRule) {
            if (frameRule === void 0) { frameRule = null; }
            var cacheKey = "".concat(request.url, "#").concat(request.sourceHostname, "#").concat(request.requestType);
            /**
             * Add frame url text to the key to avoid caching,
             * because allowlist rules are not stored in the engine
             * AG-12694
             */
            if (frameRule) {
                cacheKey += "#".concat(frameRule.getText());
            }
            var res = this.resultCache.get(cacheKey);
            if (res) {
                return res;
            }
            var networkRules = this.networkEngine.matchAll(request);
            var result = new MatchingResult(networkRules, frameRule);
            this.resultCache.set(cacheKey, result);
            return result;
        };
        /**
         * Matches current frame and returns document-level allowlist rule if found.
         *
         * @param frameUrl
         */
        Engine.prototype.matchFrame = function (frameUrl) {
            var sourceRequest = new Request$1(frameUrl, '', exports.RequestType.Document);
            var sourceRules = this.networkEngine.matchAll(sourceRequest);
            sourceRules = MatchingResult.removeBadfilterRules(sourceRules);
            var result = null;
            sourceRules.forEach(function (r) {
                if (r.isDocumentLevelAllowlistRule()) {
                    if (!result || r.isHigherPriority(result)) {
                        result = r;
                    }
                }
            });
            return result;
        };
        /**
         * Gets cosmetic result for the specified hostname and cosmetic options
         *
         * @param request host to check
         * @param option mask of enabled cosmetic types
         * @return cosmetic result
         */
        Engine.prototype.getCosmeticResult = function (request, option) {
            return this.cosmeticEngine.match(request, option);
        };
        /**
         * Gets rules count
         */
        Engine.prototype.getRulesCount = function () {
            return this.networkEngine.rulesCount + this.cosmeticEngine.rulesCount;
        };
        /**
         * Adds rules to engines
         *
         * @param indexedRule
         */
        Engine.prototype.addRule = function (indexedRule) {
            if (indexedRule) {
                if (indexedRule.rule instanceof NetworkRule) {
                    this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                }
                else if (indexedRule.rule instanceof CosmeticRule) {
                    this.cosmeticEngine.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        };
        /**
         * Request's cache size
         * Used as both source rules and others limit.
         * The value is based on benchmark runs.
         */
        Engine.REQUEST_CACHE_SIZE = 500;
        return Engine;
    }());

    /**
     * Rule with index
     */
    var IndexedRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param rule
         * @param index
         */
        function IndexedRule(rule, index) {
            this.rule = rule;
            this.index = index;
        }
        return IndexedRule;
    }());
    /**
     * Rule with storage index
     */
    var IndexedStorageRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param rule
         * @param index
         */
        function IndexedStorageRule(rule, index) {
            this.rule = rule;
            this.index = index;
        }
        return IndexedStorageRule;
    }());

    /**
     * Export logger implementation
     */
    exports.logger = console;
    /**
     * Set logger implementation
     *
     * @param loggerImpl
     */
    function setLogger(loggerImpl) {
        exports.logger = loggerImpl;
    }

    /**
     * Rule builder class
     */
    var RuleFactory = /** @class */ (function () {
        function RuleFactory() {
        }
        /**
         * Creates rule of suitable class from text string
         * It returns null if the line is empty or if it is a comment
         *
         * @param text rule string
         * @param filterListId list id
         * @param ignoreNetwork do not create network rules
         * @param ignoreCosmetic do not create cosmetic rules
         * @param ignoreHost do not create host rules
         * @return IRule object or null
         */
        RuleFactory.createRule = function (text, filterListId, ignoreNetwork, ignoreCosmetic, ignoreHost) {
            if (ignoreNetwork === void 0) { ignoreNetwork = false; }
            if (ignoreCosmetic === void 0) { ignoreCosmetic = false; }
            if (ignoreHost === void 0) { ignoreHost = true; }
            if (!text || RuleFactory.isComment(text)) {
                return null;
            }
            if (RuleFactory.isShort(text)) {
                exports.logger.info("The rule is too short: ".concat(text));
            }
            var line = text.trim();
            try {
                if (RuleFactory.isCosmetic(line)) {
                    if (ignoreCosmetic) {
                        return null;
                    }
                    return new CosmeticRule(line, filterListId);
                }
                if (!ignoreHost) {
                    var hostRule = RuleFactory.createHostRule(line, filterListId);
                    if (hostRule) {
                        return hostRule;
                    }
                }
                if (!ignoreNetwork) {
                    return new NetworkRule(line, filterListId);
                }
            }
            catch (e) {
                // TODO: Throw error
                exports.logger.info("Error: \"".concat(e.message, "\" in the rule: \"").concat(line, "\""));
            }
            return null;
        };
        /**
         * Creates host rule from text
         *
         * @param ruleText
         * @param filterListId
         */
        RuleFactory.createHostRule = function (ruleText, filterListId) {
            var rule = new HostRule(ruleText, filterListId);
            return rule.isInvalid() ? null : rule;
        };
        /**
         * Checks if rule is short
         */
        RuleFactory.isShort = function (rule) {
            if (!rule) {
                return true;
            }
            return !!(rule && rule.length <= 3);
        };
        /**
         * Checks if the rule is cosmetic or not.
         * @param ruleText - rule text to check.
         */
        RuleFactory.isCosmetic = function (ruleText) {
            var marker = findCosmeticRuleMarker(ruleText);
            return marker[0] !== -1;
        };
        /**
         * If text is comment
         *
         * @param text
         */
        RuleFactory.isComment = function (text) {
            if (text.charAt(0) === '!') {
                return true;
            }
            if (text.charAt(0) === '#') {
                if (text.length === 1) {
                    return true;
                }
                // Now we should check that this is not a cosmetic rule
                return !RuleFactory.isCosmetic(text);
            }
            return false;
        };
        return RuleFactory;
    }());

    /**
     * Rule scanner implements an interface for reading filtering rules.
     */
    var RuleScanner = /** @class */ (function () {
        /**
         * NewRuleScanner returns a new RuleScanner to read from r.
         *
         * @param reader source of the filtering rules
         * @param listId filter list ID
         * @param configuration config object
         */
        function RuleScanner(reader, listId, configuration) {
            /**
             *  Current rule
             */
            this.currentRule = null;
            /**
             * Index of the beginning of the current rule
             */
            this.currentRuleIndex = 0;
            /**
             * Current position in the reader
             */
            this.currentPos = 0;
            this.reader = reader;
            this.listId = listId;
            this.ignoreCosmetic = !!configuration.ignoreCosmetic
                || ((configuration.scannerType & ScannerType.CosmeticRules) !== ScannerType.CosmeticRules);
            this.ignoreNetwork = (configuration.scannerType & ScannerType.NetworkRules) !== ScannerType.NetworkRules;
            this.ignoreHost = (configuration.scannerType & ScannerType.HostRules) !== ScannerType.HostRules;
            this.ignoreJS = !!configuration.ignoreJS;
            this.ignoreUnsafe = !!configuration.ignoreUnsafe;
        }
        /**
         * Scan advances the RuleScanner to the next rule, which will then be available
         * through the Rule method.
         *
         * @return false when the scan stops, either by
         * reaching the end of the input or an error.
        */
        RuleScanner.prototype.scan = function () {
            while (true) {
                var lineIndex = this.currentPos;
                var line = this.readNextLine();
                if (line === null) {
                    return false;
                }
                if (line) {
                    var rule = RuleFactory.createRule(line, this.listId, this.ignoreNetwork, this.ignoreCosmetic, this.ignoreHost);
                    if (rule && !this.isIgnored(rule)) {
                        this.currentRule = rule;
                        this.currentRuleIndex = lineIndex;
                        return true;
                    }
                }
            }
        };
        /**
         * @return the most recent rule generated by a call to Scan, and the index of this rule's text.
         */
        RuleScanner.prototype.getRule = function () {
            if (this.currentRule) {
                return new IndexedRule(this.currentRule, this.currentRuleIndex);
            }
            return null;
        };
        /**
         * Reads the next line and returns it
         *
         * @return next line string or null
         */
        RuleScanner.prototype.readNextLine = function () {
            var line = this.reader.readLine();
            if (line != null) {
                this.currentPos += line.length + 1;
                return line.trim();
            }
            return null;
        };
        /**
         * Checks if the rule should be ignored by this scanner
         *
         * @param rule to check
         * @return is rule ignored
         */
        RuleScanner.prototype.isIgnored = function (rule) {
            if (!this.ignoreCosmetic && !this.ignoreJS && !this.ignoreUnsafe) {
                return false;
            }
            if (rule instanceof CosmeticRule) {
                if (this.ignoreCosmetic) {
                    return true;
                }
                // Ignore JS type rules
                return (this.ignoreJS && rule.getType() === exports.CosmeticRuleType.Js);
            }
            if (this.ignoreUnsafe) {
                if (rule instanceof NetworkRule) {
                    if (rule.getAdvancedModifier() && (rule.getAdvancedModifier() instanceof RemoveHeaderModifier)) {
                        return true;
                    }
                }
            }
            return false;
        };
        return RuleScanner;
    }());

    /**
     * Reads string line by line
     */
    var StringLineReader = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param text
         */
        function StringLineReader(text) {
            /**
             * Current position
             */
            this.currentIndex = 0;
            this.text = text;
        }
        /**
         * Reads next line
         *
         * @return text or null on end
         */
        StringLineReader.prototype.readLine = function () {
            if (this.currentIndex === -1) {
                return null;
            }
            var startIndex = this.currentIndex;
            this.currentIndex = this.text.indexOf('\n', startIndex);
            if (this.currentIndex === -1) {
                return this.text.substring(startIndex);
            }
            this.currentIndex += 1;
            // - 1 in order to exclude EOL
            return this.text.substring(startIndex, this.currentIndex - 1);
        };
        return StringLineReader;
    }());

    /**
     * List identifier max value.
     * We use "number" type for storage indexes, so we have some limits for list identifiers,
     * We line number for rule index, so if we save 11 ranks for rules, then we have 6 ranks left for list ids.
     * Check RuleStorageScanner class for more info.
     */
    var LIST_ID_MAX_VALUE = Math.pow(10, 6);
    /**
     * StringRuleList represents a string-based rule list
     */
    var StringRuleList = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param listId
         * @param ruleText
         * @param ignoreCosmetic (Optional) default false
         * @param ignoreJS (Optional) default false
         * @param ignoreUnsafe (Optional) default false
         */
        function StringRuleList(listId, ruleText, ignoreCosmetic, ignoreJS, ignoreUnsafe) {
            if (listId >= LIST_ID_MAX_VALUE) {
                throw new Error("Invalid list identifier, it must be less than ".concat(LIST_ID_MAX_VALUE));
            }
            this.id = listId;
            this.rulesText = ruleText;
            this.ignoreCosmetic = !!ignoreCosmetic;
            this.ignoreJS = !!ignoreJS;
            this.ignoreUnsafe = !!ignoreUnsafe;
        }
        /**
         * Close does nothing as here's nothing to close in the StringRuleList
         */
        // eslint-disable-next-line class-methods-use-this
        StringRuleList.prototype.close = function () {
            // Empty
        };
        /**
         * @return the rule list identifier
         */
        StringRuleList.prototype.getId = function () {
            return this.id;
        };
        /**
         * Creates a new rules scanner that reads the list contents
         * @return scanner object
         */
        StringRuleList.prototype.newScanner = function (scannerType) {
            var reader = new StringLineReader(this.rulesText);
            return new RuleScanner(reader, this.id, {
                scannerType: scannerType,
                ignoreCosmetic: this.ignoreCosmetic,
                ignoreJS: this.ignoreJS,
                ignoreUnsafe: this.ignoreUnsafe,
            });
        };
        /**
         * Finds rule text by its index.
         * If there's no rule by that index or rule is invalid, it will return null
         *
         * @param ruleIdx
         * @return rule text or null
         */
        StringRuleList.prototype.retrieveRuleText = function (ruleIdx) {
            if (ruleIdx < 0 || ruleIdx >= this.rulesText.length) {
                return null;
            }
            var endOfLine = this.rulesText.indexOf('\n', ruleIdx);
            if (endOfLine === -1) {
                endOfLine = this.rulesText.length;
            }
            var line = this.rulesText.substring(ruleIdx, endOfLine).trim();
            if (!line) {
                return null;
            }
            return line;
        };
        return StringRuleList;
    }());

    /**
     * RuleStorageScanner scans multiple RuleScanner instances
     * The rule index is built from the rule index in the list + the list ID
     * In the index number we consider decimal part as listId and integer part as ruleId
    */
    var RuleStorageScanner = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param scanners
         */
        function RuleStorageScanner(scanners) {
            /**
             * Current scanner
             */
            this.currentScanner = null;
            /**
             * Index of the current scanner
             */
            this.currentScannerIdx = -1;
            this.scanners = scanners;
        }
        /**
         * Scan advances the RuleStorageScanner to the next rule, which will then be available
         * through the Rule method. It returns false when the scan stops, either by
         * reaching the end of the input or an error.
         *
         * @return true if there is some result
        */
        RuleStorageScanner.prototype.scan = function () {
            if (this.scanners.length === 0) {
                return false;
            }
            if (!this.currentScanner) {
                this.currentScannerIdx = 0;
                this.currentScanner = this.scanners[this.currentScannerIdx];
            }
            while (true) {
                if (this.currentScanner.scan()) {
                    return true;
                }
                // Take the next scanner or just return false if there's nothing more
                if (this.currentScannerIdx === (this.scanners.length - 1)) {
                    return false;
                }
                this.currentScannerIdx += 1;
                this.currentScanner = this.scanners[this.currentScannerIdx];
            }
        };
        /**
         * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
         * See ruleListIdxToStorageIdx for more information on what this index is.
        */
        RuleStorageScanner.prototype.getRule = function () {
            if (!this.currentScanner) {
                return null;
            }
            var rule = this.currentScanner.getRule();
            if (!rule) {
                return null;
            }
            var index = RuleStorageScanner.ruleListIdxToStorageIdx(rule.rule.getFilterListId(), rule.index);
            return new IndexedStorageRule(rule.rule, index);
        };
        /**
         * ruleListIdxToStorageIdx converts pair of listID and rule list index
         * to "storage index" number
         *
         * @param listId
         * @param ruleIdx
         */
        RuleStorageScanner.ruleListIdxToStorageIdx = function (listId, ruleIdx) {
            return listId / LIST_ID_MAX_VALUE + ruleIdx;
        };
        /**
         * Converts the "storage index" to two integers:
         * listID -- rule list identifier
         * ruleIdx -- index of the rule in the list
         *
         * @param storageIdx
         * @return [listId, ruleIdx]
         */
        RuleStorageScanner.storageIdxToRuleListIdx = function (storageIdx) {
            var listId = Math.round((storageIdx % 1) * LIST_ID_MAX_VALUE);
            var ruleIdx = Math.trunc(storageIdx);
            return [listId, ruleIdx];
        };
        return RuleStorageScanner;
    }());

    /**
     * Rule list's cache
     */
    var ListCache = /** @class */ (function () {
        /**
         * Constructor
         */
        function ListCache() {
            this.cache = new Map();
        }
        /**
         * @param key
         * @return rule for specified key
         */
        ListCache.prototype.get = function (key) {
            return this.cache.get(key);
        };
        /**
         * Sets rule for specified key
         *
         * @param key
         * @param rule
         */
        ListCache.prototype.set = function (key, rule) {
            this.cache.set(key, rule);
        };
        return ListCache;
    }());

    /**
     * RuleStorage is an abstraction that combines several rule lists
     * It can be scanned using RuleStorageScanner, and also it allows
     * retrieving rules by its index

     * The idea is to keep rules in a serialized format (even original format in the case of FileRuleList)
     * and create them in a lazy manner only when we really need them. When the filtering engine is
     * being initialized, we need to scan the rule lists once in order to fill up the lookup tables.
     * We use rule indexes as a unique rule identifier instead of the rule itself.
     * The rule is created (see RetrieveRule) only when there's a chance that it's needed.

     * Rule index is an int64 value that actually consists of two int32 values:
     * One is the rule list identifier, and the second is the index of the rule inside of that list.
    */
    var RuleStorage = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param lists rule lists array
         *
         * @throws on duplicate lists
         */
        function RuleStorage(lists) {
            var _this = this;
            this.lists = lists;
            this.listsMap = new Map();
            this.cache = new Map();
            this.lists.forEach(function (list) {
                var filterListId = list.getId();
                if (_this.listsMap.get(filterListId)) {
                    throw new Error("Duplicate list ID: ".concat(filterListId));
                }
                _this.listsMap.set(filterListId, list);
            });
        }
        /**
         * Creates a new instance of RuleStorageScanner.
         * It can be used to read and parse all the storage contents.
         *
         * @return scanner instance
         */
        RuleStorage.prototype.createRuleStorageScanner = function (scannerType) {
            var scanners = this.lists.map(function (list) { return list.newScanner(scannerType); });
            return new RuleStorageScanner(scanners);
        };
        /**
         * Looks for the filtering rule in this storage
         *
         * @param storageIdx the lookup index that you can get from the rule storage scanner
         * @param ignoreHost rules could be retrieved as host rules
         */
        RuleStorage.prototype.retrieveRule = function (storageIdx, ignoreHost) {
            if (ignoreHost === void 0) { ignoreHost = true; }
            var _a = RuleStorageScanner.storageIdxToRuleListIdx(storageIdx), listId = _a[0], ruleIdx = _a[1];
            var rule = this.getFromCache(listId, ruleIdx);
            if (rule) {
                return rule;
            }
            var list = this.listsMap.get(listId);
            if (!list) {
                // List doesn't exist
                return null;
            }
            var ruleText = list.retrieveRuleText(ruleIdx);
            if (!ruleText) {
                return null;
            }
            var result = RuleFactory.createRule(ruleText, listId, false, false, ignoreHost);
            if (result) {
                this.saveToCache(listId, ruleIdx, result);
            }
            return result;
        };
        /**
         * RetrieveNetworkRule is a helper method that retrieves a network rule from the storage
         *
         * @param storageIdx
         * @return the rule or nil in any other case (not found or error)
         */
        RuleStorage.prototype.retrieveNetworkRule = function (storageIdx) {
            var rule = this.retrieveRule(storageIdx);
            if (!rule) {
                return null;
            }
            if (rule instanceof NetworkRule) {
                return rule;
            }
            return null;
        };
        /**
         * RetrieveHostRule is a helper method that retrieves a host rule from the storage
         *
         * @param storageIdx
         * @return the rule or nil in any other case (not found or error)
         */
        RuleStorage.prototype.retrieveHostRule = function (storageIdx) {
            var rule = this.retrieveRule(storageIdx, false);
            if (!rule) {
                return null;
            }
            if (rule instanceof HostRule) {
                return rule;
            }
            return null;
        };
        /**
         * Saves rule to cache
         *
         * @param listId
         * @param ruleIdx
         * @param rule
         */
        RuleStorage.prototype.saveToCache = function (listId, ruleIdx, rule) {
            var listCache = this.cache.get(listId);
            if (!listCache) {
                listCache = new ListCache();
                this.cache.set(listId, listCache);
            }
            listCache.set(ruleIdx, rule);
        };
        /**
         * Retrieves rule form cache
         *
         * @param listId
         * @param ruleIdx
         */
        RuleStorage.prototype.getFromCache = function (listId, ruleIdx) {
            var listCache = this.cache.get(listId);
            if (!listCache) {
                return undefined;
            }
            return listCache.get(ruleIdx);
        };
        return RuleStorage;
    }());

    /**
     * Rule converter class
     */
    var RuleConverter = /** @class */ (function () {
        function RuleConverter() {
        }
        /**
         * Converts rules text
         *
         * @param rulesText
         * @param conversionOptions
         */
        RuleConverter.convertRules = function (rulesText, conversionOptions) {
            if (conversionOptions === void 0) { conversionOptions = {}; }
            var result = [];
            var lines = rulesText.split(/\r?\n/);
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                try {
                    result.push.apply(result, RuleConverter.convertRule(line, conversionOptions));
                }
                catch (e) {
                    exports.logger.warn(e.message);
                }
            }
            return result.join('\n');
        };
        /**
         * Convert external scriptlet rule to AdGuard scriptlet syntax
         *
         * @param rule
         * @param conversionOptions
         */
        RuleConverter.convertRule = function (rule, conversionOptions) {
            if (conversionOptions === void 0) { conversionOptions = {}; }
            if (rule.startsWith(SimpleRegex.MASK_COMMENT)
                || rule.trim() === '') {
                return [rule.trim()];
            }
            var comment = RuleConverter.convertUboComments(rule);
            if (comment) {
                return [comment];
            }
            var converted = RuleConverter.convertCssInjection(rule);
            converted = RuleConverter.convertPseudoElements(converted);
            converted = RuleConverter.convertRemoveRule(converted);
            converted = RuleConverter.replaceOptions(converted);
            converted = RuleConverter.convertScriptHasTextToScriptTagContent(converted);
            converted = RuleConverter.convertUboMatchesPathRule(converted);
            var removeHeaderRule = RuleConverter.convertUboResponseHeaderRule(converted);
            if (removeHeaderRule) {
                return [removeHeaderRule];
            }
            var scriptletRules = scriptlets_umd.exports.convertScriptletToAdg(converted);
            if (scriptletRules && scriptletRules.every(function (x) { return RuleConverter.isValidScriptletRule(x); })) {
                return scriptletRules;
            }
            var adgRedirectRule = RuleConverter.convertUboAndAbpRedirectsToAdg(converted);
            if (adgRedirectRule) {
                return [adgRedirectRule];
            }
            var ruleWithConvertedOptions = RuleConverter.convertOptions(converted, conversionOptions);
            if (ruleWithConvertedOptions) {
                return ruleWithConvertedOptions;
            }
            return [converted];
        };
        /**
         * Validates scriptlet rule
         *
         * @param ruleText
         */
        RuleConverter.isValidScriptletRule = function (ruleText) {
            try {
                return scriptlets_umd.exports.isValidScriptletRule(ruleText);
            }
            catch (e) {
                return false;
            }
        };
        /**
         * Converts UBO Script rule
         *
         * @param {string} ruleText rule text
         * @returns {string} converted rule
         */
        RuleConverter.convertScriptHasTextToScriptTagContent = function (ruleText) {
            if (!ruleText.startsWith(SimpleRegex.MASK_COMMENT) && RuleConverter.SCRIPT_HAS_TEXT_REGEX.test(ruleText)) {
                return "".concat(ruleText.replace(RuleConverter.SCRIPT_HAS_TEXT_REGEX, RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT)
                    .slice(0, -1), "\"][max-length=\"262144\"]");
            }
            return ruleText;
        };
        /**
         * Converts UBO and ABP redirect rules to AdGuard redirect rules
         * @param rule
         * @return {string} convertedRule
         */
        RuleConverter.convertUboAndAbpRedirectsToAdg = function (rule) {
            var redirects = scriptlets_umd.exports.redirects;
            if (redirects.isUboRedirectCompatibleWithAdg(rule) || redirects.isAbpRedirectCompatibleWithAdg(rule)) {
                return redirects.convertRedirectToAdg(rule);
            }
            return null;
        };
        /**
         * Converts rule options
         * @param rule
         * @param conversionOptions
         * @private
         */
        RuleConverter.convertOptions = function (rule, conversionOptions) {
            if (conversionOptions === void 0) { conversionOptions = {}; }
            var OPTIONS_DELIMITER = '$';
            var ESCAPE_CHARACTER = '\\';
            var NAME_VALUE_SPLITTER = '=';
            /* eslint-disable max-len */
            var conversionMap = new Map([
                ['empty', 'redirect=nooptext'],
                ['mp4', 'redirect=noopmp4-1s'],
                ['inline-script', 'csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:'],
                ['inline-font', 'csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:'],
            ]);
            /* eslint-enable max-len */
            var options;
            var domainPart = '';
            // Start looking from the prev to the last symbol
            // If dollar sign is the last symbol - we simply ignore it.
            for (var i = (rule.length - 2); i >= 0; i -= 1) {
                var currChar = rule.charAt(i);
                if (currChar !== OPTIONS_DELIMITER) {
                    continue;
                }
                if (i > 0 && rule.charAt(i - 1) !== ESCAPE_CHARACTER) {
                    domainPart = rule.substring(0, i);
                    options = rule.substring(i + 1);
                    // Options delimiter was found, doing nothing
                    break;
                }
            }
            if (!options) {
                return null;
            }
            var optionsParts = options.split(',');
            var optionsConverted = false;
            var updatedOptionsParts = optionsParts.map(function (optionsPart) {
                var convertedOptionsPart = conversionMap.get(optionsPart);
                // if option is $mp4, than it should go with $media option together
                if (optionsPart === 'mp4') {
                    // check if media is not already among options
                    if (!optionsParts.some(function (option) { return option === 'media'; })) {
                        convertedOptionsPart = "".concat(convertedOptionsPart, ",media");
                    }
                }
                if (convertedOptionsPart) {
                    optionsConverted = true;
                    return convertedOptionsPart;
                }
                return optionsPart;
            });
            // if has more than one csp modifiers, we merge them into one;
            var cspParts = updatedOptionsParts.filter(function (optionsPart) { return optionsPart.startsWith('csp'); });
            if (cspParts.length > 1) {
                var allButCsp = updatedOptionsParts
                    .filter(function (optionsPart) { return !optionsPart.startsWith('csp'); });
                var cspValues = cspParts.map(function (cspPart) { return cspPart.split(NAME_VALUE_SPLITTER)[1]; });
                var updatedCspOption = "csp".concat(NAME_VALUE_SPLITTER).concat(cspValues.join('; '));
                updatedOptionsParts = allButCsp.concat(updatedCspOption);
            }
            // options without all modifier
            var hasAllOption = updatedOptionsParts.indexOf('all') > -1;
            if (hasAllOption && !conversionOptions.ignoreAllModifier) {
                // $all modifier should be converted in 4 rules
                // ||example.org^$document,popup
                // ||example.org^
                // ||example.org^$inline-font
                // ||example.org^$inline-script
                var allOptionReplacers = [
                    ['document', 'popup'],
                    ['inline-script'],
                    ['inline-font'],
                    [''], //
                ];
                return allOptionReplacers.map(function (replacers) {
                    // remove replacer and all option from the list
                    var optionsButAllAndReplacer = updatedOptionsParts
                        .filter(function (option) { return !(replacers.includes(option) || option === 'all'); });
                    // try get converted values, used for INLINE_SCRIPT_OPTION, INLINE_FONT_OPTION
                    var convertedReplacers = replacers.map(function (replacer) { return conversionMap.get(replacer) || replacer; });
                    // add replacer to the list of options
                    var updatedOptionsString = __spreadArray(__spreadArray([], convertedReplacers, true), optionsButAllAndReplacer, true).filter(function (entity) { return entity; })
                        .join(',');
                    // create a new rule
                    return updatedOptionsString.length < 1 ? domainPart : "".concat(domainPart, "$").concat(updatedOptionsString);
                });
            }
            if (optionsConverted) {
                var updatedOptions = updatedOptionsParts.join(',');
                return ["".concat(domainPart, "$").concat(updatedOptions)];
            }
            return null;
        };
        /**
         * Converts ubo syntax comments (rules starting with #)
         * Note: It's not possible to detect 100% cause rules starting with ## are valid elemhide rules
         *
         * @param rule
         * @return {string}
         */
        RuleConverter.convertUboComments = function (rule) {
            if (rule.startsWith('# ') || rule.startsWith('####')) {
                return "! ".concat(rule);
            }
            return null;
        };
        /**
         * Executes rule css conversion
         *
         * @param rule
         * @param parts
         * @param ruleMark
         */
        RuleConverter.executeConversion = function (rule, parts, ruleMark) {
            var result = rule;
            var domain = parts[0];
            if (domain) {
                var rulePart = parts[1];
                if (rulePart.match(RuleConverter.CSS_RULE_REPLACE_PATTERN)) {
                    var groups = RuleConverter.CSS_RULE_REPLACE_PATTERN.exec(rulePart);
                    if (groups != null) {
                        if (groups.length === 3) {
                            result = domain + ruleMark;
                            result += "".concat(groups[1], " { ").concat(groups[2], " }");
                        }
                    }
                }
            }
            return result;
        };
        /**
         * Adds colon to the pseudo elements written with one colon (:before, :after);
         * e.g.
         *  "hotline.ua##.reset-scroll:before" -> "hotline.ua##.reset-scroll::before"
         * @param rule
         * @private
         */
        RuleConverter.convertPseudoElements = function (rule) {
            var BEFORE = 'before';
            var AFTER = 'after';
            var SINGLE_COLON = ':';
            // does not have parts to convert
            if (!(rule.includes(SINGLE_COLON + BEFORE) || rule.includes(SINGLE_COLON + AFTER))) {
                return rule;
            }
            // not an css rule
            if (!(rule.includes(RuleConverter.MASK_ELEMENT_HIDING)
                || rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)
                || rule.includes(RuleConverter.MASK_CSS)
                || rule.includes(RuleConverter.MASK_CSS_EXCEPTION))) {
                return rule;
            }
            var modifiedRule = '';
            for (var i = 0; i < rule.length; i += 1) {
                if (rule[i] !== SINGLE_COLON) {
                    modifiedRule += rule[i];
                    continue;
                }
                if ((rule.indexOf(BEFORE, i) === i + 1 || rule.indexOf(AFTER, i) === i + 1)
                    && rule[i - 1] !== SINGLE_COLON) {
                    modifiedRule += SINGLE_COLON;
                    modifiedRule += rule[i];
                    continue;
                }
                modifiedRule += rule[i];
            }
            return modifiedRule;
        };
        /**
         * Converts CSS injection
         * example.com##h1:style(background-color: blue !important)
         * into
         * example.com#$#h1 { background-color: blue !important }
         * <p>
         * OR (for exceptions):
         * example.com#@#h1:style(background-color: blue !important)
         * into
         * example.com#@$#h1 { background-color: blue !important }
         *
         * @param {string} rule
         * @return {string} convertedRule
         */
        RuleConverter.convertCssInjection = function (rule) {
            if (rule.includes(':style')) {
                var parts = void 0;
                var resultMask = void 0;
                var resultRule = rule;
                var isExtendedCss = false;
                for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                    isExtendedCss = rule.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1;
                    if (isExtendedCss) {
                        break;
                    }
                }
                if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                    parts = rule.split(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE, 2);
                    resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                }
                else if (rule.includes(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE)) {
                    parts = rule.split(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, 2);
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                    // firstly we check for exception rule in order not to confuse with id selectors
                    // e.g. yourconroenews.com#@##siteNav:style(transform: none !important;)
                }
                else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)) {
                    parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION, 2);
                    if (isExtendedCss) {
                        resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                    }
                    else {
                        resultMask = RuleConverter.MASK_CSS_EXCEPTION;
                    }
                }
                else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING)) {
                    parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING, 2);
                    if (isExtendedCss) {
                        resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                    }
                    else {
                        resultMask = RuleConverter.MASK_CSS;
                    }
                }
                if (parts && resultMask) {
                    resultRule = RuleConverter.executeConversion(rule, parts, resultMask);
                }
                return resultRule;
            }
            return rule;
        };
        /**
         * Converts ':remove()' rule to AdGuard extended css rule
         * example.com###banner:remove() -> example.com#$?##banner { remove: true; }
         * @param {string} rule
         * @return {string} rule or converted rule
         */
        RuleConverter.convertRemoveRule = function (rule) {
            // if rule is already extended css, do not convert it
            if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                return rule;
            }
            if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING) && rule.endsWith(RuleConverter.REMOVE_RULE_PATTERN)) {
                return rule
                    .replace(RuleConverter.MASK_ELEMENT_HIDING, RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE)
                    .replace(RuleConverter.REMOVE_RULE_PATTERN, RuleConverter.REMOVE_RULE_REPLACER);
            }
            return rule;
        };
        /**
         * Converts '^responseheader()' rule to AdGuard's $removeheader modifier
         * "ya.ru##^responseheader(header-name)" -> "||ya.ru^$removeheader=header-name"
         *
         * @param {string} ruleText
         * @return {string} ruleText or converted rule
         */
        RuleConverter.convertUboResponseHeaderRule = function (ruleText) {
            if (ruleText.startsWith(SimpleRegex.MASK_COMMENT) || !ruleText.includes(RuleConverter.UBO_RESPONSE_HEADER)) {
                return null;
            }
            if (RuleConverter.UBO_RESPONSE_HEADER_REGEX.test(ruleText)) {
                return "||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT)
                    .slice(0, -1));
            }
            if (RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX.test(ruleText)) {
                return "@@||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT).slice(0, -1));
            }
            return ruleText;
        };
        /**
         * Converts cosmetic 'matches-path()' rule to AdGuard's $path modifier
         * "ya.ru##:matches-path(/page) p" -> "[$path=/page]ya.ru##p"
         *
         * @param {string} ruleText
         * @return {string} ruleText or converted rule
         */
        RuleConverter.convertUboMatchesPathRule = function (ruleText) {
            if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)) {
                return ruleText;
            }
            var _a = findCosmeticRuleMarker(ruleText), markerIndex = _a[0], marker = _a[1];
            if (!marker) {
                return ruleText;
            }
            var expressionStartIndex = markerIndex + marker.length;
            var matchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_MATCHES_PATH, expressionStartIndex);
            if (matchesPathStartIndex === -1) {
                return ruleText;
            }
            var reversedMatchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_REVERSED_MATCHES_PATH, expressionStartIndex);
            var isReversed = reversedMatchesPathStartIndex !== -1;
            var pathStartIndex = isReversed
                ? reversedMatchesPathStartIndex + RuleConverter.UBO_REVERSED_MATCHES_PATH.length
                : matchesPathStartIndex + RuleConverter.UBO_MATCHES_PATH.length;
            var matchPathOperatorCloseBracketIndex;
            var openBracketCounter = 1;
            var closeBracketCounter = 0;
            for (var i = pathStartIndex; i < ruleText.length; i += 1) {
                if (ruleText[i - 1] !== '\\') {
                    if (ruleText[i] === '(') {
                        openBracketCounter += 1;
                    }
                    else if (ruleText[i] === ')') {
                        closeBracketCounter += 1;
                        if (openBracketCounter === closeBracketCounter) {
                            matchPathOperatorCloseBracketIndex = i;
                            break;
                        }
                    }
                }
            }
            if (!matchPathOperatorCloseBracketIndex) {
                return ruleText;
            }
            var domains = ruleText.slice(0, markerIndex);
            var expressionMiddle = ruleText.slice(expressionStartIndex, isReversed ? reversedMatchesPathStartIndex : matchesPathStartIndex);
            var expressionTail = ruleText.slice(matchPathOperatorCloseBracketIndex + (isReversed ? 2 : 1));
            var path = ruleText.slice(pathStartIndex, matchPathOperatorCloseBracketIndex);
            var isRegex = SimpleRegex.isRegexPattern(path);
            if (isReversed) {
                path = "/^((?!".concat(isRegex ? path.slice(1, path.length - 1) : SimpleRegex.patternToRegexp(path), ").)*$/");
            }
            if (isRegex) {
                path = SimpleRegex.escapeRegexSpecials(path, SimpleRegex.reModifierPatternSpecialCharacters);
            }
            return "[$path=".concat(path, "]").concat(domains).concat(marker).concat(expressionMiddle).concat(expressionTail);
        };
        /**
         * Replaces the options in aliases array
         *
         * @param {string} rule
         * @return {string} convertedRule
         */
        RuleConverter.replaceOptions = function (rule) {
            if (rule.startsWith(SimpleRegex.MASK_COMMENT) || RuleFactory.isCosmetic(rule)) {
                return rule;
            }
            var result = rule;
            RuleConverter.OPTIONS_ALIASES.forEach(function (x) {
                if (result.includes(x.alias) && x.regex.test(result)) {
                    result = result.replace(x.regex, x.replacement);
                }
            });
            return result;
        };
        RuleConverter.CSS_RULE_REPLACE_PATTERN = /(.*):style\((.*)\)/g;
        RuleConverter.FIRST_PARTY_REGEX = /([$,])first-party/i;
        RuleConverter.FIRST_PARTY_REPLACEMENT = '$1~third-party';
        RuleConverter.XHR_REGEX = /([$,]~?)xhr/i;
        RuleConverter.XHR_REPLACEMENT = '$1xmlhttprequest';
        RuleConverter.CSS_REGEX = /([$,]~?)(css)(,|\W|$)/i;
        RuleConverter.CSS_REPLACEMENT = '$1stylesheet$3';
        RuleConverter.FRAME_REGEX = /([$,])frame/i;
        RuleConverter.FRAME_REPLACEMENT = '$1subdocument';
        RuleConverter.SCRIPT_HAS_TEXT_REGEX = /(##\^script:(has-text|contains))\((?!\/.+\/\))/i;
        RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT = '$$$$script[tag-content="';
        RuleConverter.THIRD_PARTY_1P_3P_REGEX = /([$,])(1p|3p)/;
        RuleConverter.THIRD_PARTY_1P_REPLACEMENT = '$1~third-party';
        RuleConverter.THIRD_PARTY_3P_REPLACEMENT = '$1third-party';
        RuleConverter.GHIDE_REGEX = /(.+[^#]\$.*)(ghide)($|,.+)/i;
        RuleConverter.GENERICHIDE = 'generichide';
        RuleConverter.SHIDE_REGEX = /(.+[^#]\$.*)(shide)($|,.+)/i;
        RuleConverter.SPECIFICHIDE = 'specifichide';
        RuleConverter.EHIDE_REGEX = /(.+[^#]\$.*)(ehide)($|,.+)/i;
        RuleConverter.ELEMHIDE = 'elemhide';
        RuleConverter.QUERY_PRUNE_REGEX = /(.+[^#]\$.*)(queryprune)($|,|=.+)/i;
        RuleConverter.REMOVE_PARAM_REPLACEMENT = '$1removeparam$3';
        RuleConverter.DOC_REGEX = /(.+[^#]\$.*)(doc)($|,.+)/i;
        RuleConverter.DOC_REPLACEMENT = '$1document$3';
        RuleConverter.UBO_RESPONSE_HEADER = '#^responseheader(';
        RuleConverter.UBO_RESPONSE_HEADER_REGEX = /##\^responseheader\((?!\/.+\/\))/i;
        RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX = /#@#\^responseheader\((?!\/.+\/\))/i;
        RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT = '^$removeheader=';
        RuleConverter.UBO_MATCHES_PATH = ':matches-path(';
        RuleConverter.UBO_REVERSED_MATCHES_PATH = ':not(:matches-path(';
        /**
         * Rule masks
         */
        RuleConverter.MASK_ELEMENT_HIDING = '##';
        RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION = '#@#';
        RuleConverter.MASK_CSS = '#$#';
        RuleConverter.MASK_CSS_EXCEPTION = '#@$#';
        RuleConverter.MASK_CSS_EXTENDED_CSS_RULE = '#?#';
        RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE = '#@?#';
        RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE = '#$?#';
        RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE = '#@$?#';
        RuleConverter.REMOVE_RULE_PATTERN = ':remove()';
        RuleConverter.REMOVE_RULE_REPLACER = ' { remove: true; }';
        /**
         * Some options have aliases and will be replaced:
         *
         * $first-party -> $~third-party
         * $xhr -> $xmlhttprequest
         * $css -> $stylesheet
         * $frame -> $subdocument
         * $1p -> $~third-party
         * $3p -> $third-party
         * ghide -> generichide
         * ehide -> elemhide
         * doc -> document
         * queryprune -> removeparam
         */
        RuleConverter.OPTIONS_ALIASES = [
            {
                alias: 'first-party',
                regex: RuleConverter.FIRST_PARTY_REGEX,
                replacement: RuleConverter.FIRST_PARTY_REPLACEMENT,
            },
            {
                alias: 'xhr',
                regex: RuleConverter.XHR_REGEX,
                replacement: RuleConverter.XHR_REPLACEMENT,
            },
            {
                alias: 'css',
                regex: RuleConverter.CSS_REGEX,
                replacement: RuleConverter.CSS_REPLACEMENT,
            },
            {
                alias: 'frame',
                regex: RuleConverter.FRAME_REGEX,
                replacement: RuleConverter.FRAME_REPLACEMENT,
            },
            {
                alias: 'queryprune',
                regex: RuleConverter.QUERY_PRUNE_REGEX,
                replacement: RuleConverter.REMOVE_PARAM_REPLACEMENT,
            },
            {
                alias: 'doc',
                regex: RuleConverter.DOC_REGEX,
                replacement: RuleConverter.DOC_REPLACEMENT,
            },
            {
                alias: '1p',
                regex: RuleConverter.THIRD_PARTY_1P_3P_REGEX,
                replacement: RuleConverter.THIRD_PARTY_1P_REPLACEMENT,
            },
            {
                alias: '3p',
                regex: RuleConverter.THIRD_PARTY_1P_3P_REGEX,
                replacement: RuleConverter.THIRD_PARTY_3P_REPLACEMENT,
            },
            {
                alias: 'ghide',
                regex: RuleConverter.GHIDE_REGEX,
                replacement: "$1".concat(RuleConverter.GENERICHIDE, "$3"),
            },
            {
                alias: 'ehide',
                regex: RuleConverter.EHIDE_REGEX,
                replacement: "$1".concat(RuleConverter.ELEMHIDE, "$3"),
            },
            {
                alias: 'shide',
                regex: RuleConverter.SHIDE_REGEX,
                replacement: "$1".concat(RuleConverter.SPECIFICHIDE, "$3"),
            },
        ];
        return RuleConverter;
    }());

    /**
     * Describes an error when rule set source is not available.
     */
    var UnavailableRuleSetSourceError = /** @class */ (function (_super) {
        __extends(UnavailableRuleSetSourceError, _super);
        /**
         * Describes an error when rule set source is not available.
         *
         * @param message Message of error.
         * @param ruleSetId Rule set id, the source of which is not available.
         * @param cause Basic error, describes why the source is unavailable.
         */
        function UnavailableRuleSetSourceError(message, ruleSetId, cause) {
            var _this = _super.call(this, message, { cause: cause }) || this;
            _this.name = 'UnavailableRuleSetSourceError';
            _this.ruleSetId = ruleSetId;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, UnavailableRuleSetSourceError.prototype);
            return _this;
        }
        return UnavailableRuleSetSourceError;
    }(Error));

    /**
     * Keeps converted declarative rules, counters of rules and source map for them.
     */
    var RuleSet = /** @class */ (function () {
        /**
         * Constructor of RuleSet.
         *
         * @param id Id of rule set.
         * @param rulesCount Number of rules.
         * @param regexpRulesCount Number of regexp rules.
         * @param ruleSetContentProvider Rule set content provider.
         */
        function RuleSet(id, rulesCount, regexpRulesCount, ruleSetContentProvider) {
            /**
             * Array of converted declarative rules.
             */
            this.declarativeRules = [];
            /**
             * Number of converted declarative rules.
             * This is needed for the lazy version of the rule set,
             * when content not loaded.
             */
            this.rulesCount = 0;
            /**
             * Converted declarative regexp rules.
             */
            this.regexpRulesCount = 0;
            /**
             * Keeps array of source filter lists
             * TODO: ? May it leads to memory leaks,
             * because one FilterList with its content
             * can be in the several RuleSet's at the same time ?
             */
            this.filterList = new Map();
            /**
             * Whether the content is loaded or not.
             */
            this.initialized = false;
            this.id = id;
            this.rulesCount = rulesCount;
            this.regexpRulesCount = regexpRulesCount;
            this.ruleSetContentProvider = ruleSetContentProvider;
        }
        /**
         * Number of converted declarative rules.
         *
         * @returns Number of converted declarative rules.
         */
        RuleSet.prototype.getRulesCount = function () {
            return this.rulesCount || this.declarativeRules.length;
        };
        /**
         * Number of converted declarative regexp rules.
         *
         * @returns Number of converted declarative regexp rules.
         */
        RuleSet.prototype.getRegexpRulesCount = function () {
            return this.regexpRulesCount;
        };
        /**
         * Rule set id.
         *
         * @returns Rule set id.
         */
        RuleSet.prototype.getId = function () {
            return this.id;
        };
        /**
         * Returns a list of pairs of source text rules and their filter identifiers
         * for a given declarative rule identifier.
         *
         * @param declarativeRuleId {@link DeclarativeRule|declarative rule} Id.
         *
         * @returns Promise with list of source rules.
         */
        RuleSet.prototype.findSourceRules = function (declarativeRuleId) {
            var _this = this;
            if (!this.sourceMap) {
                return Promise.resolve([]);
            }
            var sourcePairs = this.sourceMap.getByDeclarativeRuleId(declarativeRuleId);
            var sourceRules = sourcePairs.map(function (_a) {
                var filterId = _a.filterId, sourceRuleIndex = _a.sourceRuleIndex;
                return __awaiter(_this, void 0, void 0, function () {
                    var filter, sourceRule;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                filter = this.filterList.get(filterId);
                                if (!filter) {
                                    throw new Error("Not found filter list with id: ".concat(filterId));
                                }
                                return [4 /*yield*/, filter.getRuleByIndex(sourceRuleIndex)];
                            case 1:
                                sourceRule = _b.sent();
                                return [2 /*return*/, {
                                        sourceRule: sourceRule,
                                        filterId: filterId,
                                    }];
                        }
                    });
                });
            });
            return Promise.all(sourceRules);
        };
        /**
         * Run inner deserialization from rule set content provider to load
         * the source map, filter list and declarative rules list.
         */
        RuleSet.prototype.loadContent = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a, getSourceMap, getFilterList, getDeclarativeRules, _b, _c, filtersList;
                var _this = this;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (this.initialized) {
                                return [2 /*return*/];
                            }
                            _a = this.ruleSetContentProvider, getSourceMap = _a.getSourceMap, getFilterList = _a.getFilterList, getDeclarativeRules = _a.getDeclarativeRules;
                            _b = this;
                            return [4 /*yield*/, getSourceMap()];
                        case 1:
                            _b.sourceMap = _d.sent();
                            _c = this;
                            return [4 /*yield*/, getDeclarativeRules()];
                        case 2:
                            _c.declarativeRules = _d.sent();
                            return [4 /*yield*/, getFilterList()];
                        case 3:
                            filtersList = _d.sent();
                            filtersList.forEach(function (filter) {
                                _this.filterList.set(filter.getId(), filter);
                            });
                            this.initialized = true;
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Returns a list of pairs of source text rules and their filter identifiers
         * for a given declarative rule identifier.
         *
         * @param declarativeRuleId {@link DeclarativeRule|declarative rule} Id.
         *
         * @returns Promise with list of source rules.
         *
         * @throws Error {@link UnavailableRuleSetSourceError} if rule set source
         * is not available.
         */
        RuleSet.prototype.getRulesById = function (declarativeRuleId) {
            return __awaiter(this, void 0, void 0, function () {
                var originalRules, e_1, id, msg;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            if (!!this.initialized) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.loadContent()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [4 /*yield*/, this.findSourceRules(declarativeRuleId)];
                        case 3:
                            originalRules = _a.sent();
                            return [2 /*return*/, originalRules];
                        case 4:
                            e_1 = _a.sent();
                            id = this.getId();
                            msg = 'Cannot extract source rule for given '
                                + "declarativeRuleId ".concat(declarativeRuleId, " in rule set '").concat(id, "'");
                            throw new UnavailableRuleSetSourceError(msg, id, e_1);
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Serializes rule set to primitives values with lazy load.
         *
         * @returns Serialized rule set.
         *
         * @throws Error {@link UnavailableRuleSetSourceError} if rule set source
         * is not available.
         */
        RuleSet.prototype.serialize = function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var e_2, id, msg, serialized;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.loadContent()];
                        case 1:
                            _b.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            e_2 = _b.sent();
                            id = this.getId();
                            msg = "Cannot serialize rule set '".concat(id, "' because of not ")
                                + 'available source';
                            throw new UnavailableRuleSetSourceError(msg, id, e_2);
                        case 3:
                            serialized = {
                                id: this.id,
                                declarativeRules: this.declarativeRules,
                                regexpRulesCount: this.regexpRulesCount,
                                rulesCount: this.rulesCount,
                                sourceMap: ((_a = this.sourceMap) === null || _a === void 0 ? void 0 : _a.serialize()) || '',
                                filterListsIds: Array.from(this.filterList.keys()),
                            };
                            return [2 /*return*/, serialized];
                    }
                });
            });
        };
        return RuleSet;
    }());

    /**
     * FilterScanner returns indexed, only network rules from IFilter's content.
     */
    var FilterScanner = /** @class */ (function () {
        /**
         * Constructor of FilterScanner.
         *
         * @param filterContent Filter rules.
         * @param filterId Filter id.
         */
        function FilterScanner(filterContent, filterId) {
            this.filterContent = filterContent;
            this.filterId = filterId;
        }
        /**
         * Creates new filter scanner.
         *
         * @param filter From which filter the rules should be scanned.
         *
         * @returns New FilterScanner.
         */
        FilterScanner.createNew = function (filter) {
            return __awaiter(this, void 0, void 0, function () {
                var content;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, filter.getContent()];
                        case 1:
                            content = _a.sent();
                            return [2 /*return*/, new FilterScanner(content, filter.getId())];
                    }
                });
            });
        };
        /**
         * Gets the entire contents of the filter,
         * extracts only the network rules (ignore cosmetic and host rules)
         * and tries to convert each line into an indexed rule.
         *
         * @returns List of indexed rules.
         */
        FilterScanner.prototype.getIndexedRules = function () {
            var _a = this, filterContent = _a.filterContent, filterId = _a.filterId;
            var indexedRules = filterContent
                .map(function (line, idx) {
                if (!line) {
                    return null;
                }
                // TODO: Add error capture
                var rule = RuleFactory.createRule(line, filterId, false, true, // ignore cosmetic rules
                true);
                return rule
                    ? new IndexedRule(rule, idx)
                    : null;
            })
                .filter(function (rule) { return rule !== null; });
            return indexedRules;
        };
        return FilterScanner;
    }());

    /**
     * Contains a list of records with source rule ID, converted rule ID
     * and filter ID.
     * Can return the source filter and rule for the provided conversion rule ID.
     */
    var SourceMap = /** @class */ (function () {
        /**
         * Creates new SourceMap from provided list of sources.
         *
         * @param sources List of sources.
         */
        function SourceMap(sources) {
            var _this = this;
            this.sources = [];
            /**
             * Needs for fast search for source rule.
             */
            this.ruleIdMap = new Map();
            this.sources = sources;
            // For fast search
            this.sources.forEach(function (item) {
                var key = item.declarativeRuleId;
                var sourceRuleIndex = item.sourceRuleIndex, filterId = item.filterId;
                var value = {
                    sourceRuleIndex: sourceRuleIndex,
                    filterId: filterId,
                };
                var existingPairs = _this.ruleIdMap.get(key);
                var newValue = existingPairs
                    ? existingPairs.concat(value)
                    : [value];
                _this.ruleIdMap.set(key, newValue);
            });
        }
        /**
         * Returns source filter id and source text rule id
         * for provided declarative rule id.
         *
         * @param ruleId Converted rule id.
         *
         * @returns List of pairs: source filter id and source rule id.
         */
        SourceMap.prototype.getByDeclarativeRuleId = function (ruleId) {
            return this.ruleIdMap.get(ruleId) || [];
        };
        /**
         * Deserializes array of sources from string.
         *
         * @param sourceString The original map that was serialized into a string.
         *
         * @returns List of sources.
         */
        SourceMap.deserializeSources = function (sourceString) {
            var arr = JSON.parse(sourceString);
            return arr.map(function (item) { return ({
                declarativeRuleId: item[0],
                sourceRuleIndex: item[1],
                filterId: item[2],
            }); });
        };
        /**
         * Serializes source map to JSON string.
         *
         * @todo (TODO:) Can use protocol VLQ.
         *
         * @returns JSON string.
         */
        SourceMap.prototype.serialize = function () {
            // Remove fields names to reduce size of serialized string
            var plainArray = this.sources.map(function (_a) {
                var declarativeRuleId = _a.declarativeRuleId, sourceRuleIndex = _a.sourceRuleIndex, filterId = _a.filterId;
                return ([declarativeRuleId, sourceRuleIndex, filterId]);
            });
            return JSON.stringify(plainArray);
        };
        return SourceMap;
    }());

    /**
     * Describes abstract error when declarative rule is invalid.
     */
    var InvalidDeclarativeRuleError = /** @class */ (function (_super) {
        __extends(InvalidDeclarativeRuleError, _super);
        /**
         * Describes abstract error when declarative rule is invalid.
         *
         * @param message Message of error.
         * @param networkRule {@link NetworkRule}.
         * @param declarativeRule {@link DeclarativeRule}.
         */
        function InvalidDeclarativeRuleError(message, networkRule, declarativeRule) {
            var _this = _super.call(this, message) || this;
            _this.name = 'InvalidDeclarativeRuleError';
            _this.networkRule = networkRule;
            _this.declarativeRule = declarativeRule;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, InvalidDeclarativeRuleError.prototype);
            return _this;
        }
        return InvalidDeclarativeRuleError;
    }(Error));

    /**
     * Describes error when converted rule contains empty list of resources types.
     */
    var EmptyResourcesError = /** @class */ (function (_super) {
        __extends(EmptyResourcesError, _super);
        /**
         * Describes error when converted rule contains empty list of resources types.
         *
         * @param message Message of error.
         * @param networkRule {@link NetworkRule}.
         * @param declarativeRule {@link DeclarativeRule}.
         */
        function EmptyResourcesError(message, networkRule, declarativeRule) {
            var _this = _super.call(this, message, networkRule, declarativeRule) || this;
            _this.name = 'EmptyResourcesError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, EmptyResourcesError.prototype);
            return _this;
        }
        return EmptyResourcesError;
    }(InvalidDeclarativeRuleError));

    /**
     * Describes error when converted rule contains too complex regexp error.
     */
    var TooComplexRegexpError = /** @class */ (function (_super) {
        __extends(TooComplexRegexpError, _super);
        /**
         * Describes error when converted rule contains too complex regexp error.
         *
         * @param message Message of error.
         * @param networkRule {@link NetworkRule}.
         * @param declarativeRule {@link DeclarativeRule}.
         */
        function TooComplexRegexpError(message, networkRule, declarativeRule) {
            var _this = _super.call(this, message, networkRule, declarativeRule) || this;
            _this.name = 'TooComplexRegexpError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, TooComplexRegexpError.prototype);
            return _this;
        }
        return TooComplexRegexpError;
    }(InvalidDeclarativeRuleError));

    /**
     * Describes an error when a source network rule contains some of
     * the unsupported modifiers.
     */
    var UnsupportedModifierError = /** @class */ (function (_super) {
        __extends(UnsupportedModifierError, _super);
        /**
         * Describes an error when a source network rule contains some of
         * the unsupported modifiers.
         * We skip the following modifiers:
         * $removeparam - if it contains a negation, or regexp,
         * or the rule is a allowlist
         * $elemhide
         * $jsinject
         * $cookie
         * $csp
         * $replace
         * $generichide
         * $stealth
         * $mp4.
         *
         * @param message Message of error.
         * @param networkRule {@link NetworkRule}.
         */
        function UnsupportedModifierError(message, networkRule) {
            var _this = _super.call(this, message) || this;
            _this.name = 'UnsupportedModifierError';
            _this.networkRule = networkRule;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, UnsupportedModifierError.prototype);
            return _this;
        }
        return UnsupportedModifierError;
    }(Error));

    /**
     * Describes an error when the converted rule contains an unsupported RE2
     * regexp syntax error.
     *
     * @see https://github.com/google/re2/wiki/Syntax
     */
    var UnsupportedRegexpError = /** @class */ (function (_super) {
        __extends(UnsupportedRegexpError, _super);
        /**
         * Describes an error when the converted rule contains an unsupported RE2
         * regexp syntax error.
         *
         * @param message Message of error.
         * @param networkRule {@link NetworkRule}.
         * @param declarativeRule {@link DeclarativeRule}.
         */
        function UnsupportedRegexpError(message, networkRule, declarativeRule) {
            var _this = _super.call(this, message, networkRule, declarativeRule) || this;
            _this.name = 'UnsupportedRegexpError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, UnsupportedRegexpError.prototype);
            return _this;
        }
        return UnsupportedRegexpError;
    }(InvalidDeclarativeRuleError));

    /*! https://mths.be/punycode v1.4.1 by @mathias */


    /** Highest positive signed 32-bit float value */
    var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'

    /** Regular expressions */
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    var errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
      throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';
      if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        string = parts[1];
      }
      // Avoid `split(regex)` for IE8 compatibility. See #17.
      string = string.replace(regexSeparators, '\x2E');
      var labels = string.split('.');
      var encoded = map(labels, fn).join('.');
      return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
      var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xFC00) == 0xDC00) { // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
      return map(array, function(value) {
        var output = '';
        if (value > 0xFFFF) {
          value -= 0x10000;
          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
          value = 0xDC00 | value & 0x3FF;
        }
        output += stringFromCharCode(value);
        return output;
      }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
      //  0..25 map to ASCII a..z or A..Z
      // 26..35 map to ASCII 0..9
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode(input) {
      // Don't use UCS-2
      var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,
        /** Cached calculation results */
        baseMinusT;

      // Handle the basic code points: let `basic` be the number of input code
      // points before the last delimiter, or `0` if there is none, then copy
      // the first basic code points to the output.

      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }

      for (j = 0; j < basic; ++j) {
        // if it's not a basic code point
        if (input.charCodeAt(j) >= 0x80) {
          error('not-basic');
        }
        output.push(input.charCodeAt(j));
      }

      // Main decoding loop: start just after the last delimiter if any basic code
      // points were copied; start at the beginning otherwise.

      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */ ) {

        // `index` is the index of the next character to be consumed.
        // Decode a generalized variable-length integer into `delta`,
        // which gets added to `i`. The overflow checking is easier
        // if we increase `i` as we go, then subtract off its starting
        // value at the end to obtain `delta`.
        for (oldi = i, w = 1, k = base; /* no condition */ ; k += base) {

          if (index >= inputLength) {
            error('invalid-input');
          }

          digit = basicToDigit(input.charCodeAt(index++));

          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error('overflow');
          }

          i += digit * w;
          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

          if (digit < t) {
            break;
          }

          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error('overflow');
          }

          w *= baseMinusT;

        }

        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);

        // `i` was supposed to wrap around from `out` to `0`,
        // incrementing `n` each time, so we'll fix that now:
        if (floor(i / out) > maxInt - n) {
          error('overflow');
        }

        n += floor(i / out);
        i %= out;

        // Insert `n` at position `i` of the output
        output.splice(i++, 0, n);

      }

      return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
      var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength,
        /** Cached calculation results */
        handledCPCountPlusOne,
        baseMinusT,
        qMinusT;

      // Convert the input in UCS-2 to Unicode
      input = ucs2decode(input);

      // Cache the length
      inputLength = input.length;

      // Initialize the state
      n = initialN;
      delta = 0;
      bias = initialBias;

      // Handle the basic code points
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }

      handledCPCount = basicLength = output.length;

      // `handledCPCount` is the number of code points that have been handled;
      // `basicLength` is the number of basic code points.

      // Finish the basic string - if it is not empty - with a delimiter
      if (basicLength) {
        output.push(delimiter);
      }

      // Main encoding loop:
      while (handledCPCount < inputLength) {

        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }

          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer
            for (q = delta, k = base; /* no condition */ ; k += base) {
              t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }

        ++delta;
        ++n;

      }
      return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ?
          decode(string.slice(4).toLowerCase()) :
          string;
      });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ?
          'xn--' + encode(string) :
          string;
      });
    }
    var version = '1.4.1';
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */

    var ucs2 = {
      decode: ucs2decode,
      encode: ucs2encode
    };
    var punycode = {
      version: version,
      ucs2: ucs2,
      toASCII: toASCII,
      toUnicode: toUnicode,
      encode: encode,
      decode: decode
    };

    var util;
    (function (util) {
        util.assertEqual = (val) => val;
        function assertIs(_arg) { }
        util.assertIs = assertIs;
        function assertNever(_x) {
            throw new Error();
        }
        util.assertNever = assertNever;
        util.arrayToEnum = (items) => {
            const obj = {};
            for (const item of items) {
                obj[item] = item;
            }
            return obj;
        };
        util.getValidEnumValues = (obj) => {
            const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
            const filtered = {};
            for (const k of validKeys) {
                filtered[k] = obj[k];
            }
            return util.objectValues(filtered);
        };
        util.objectValues = (obj) => {
            return util.objectKeys(obj).map(function (e) {
                return obj[e];
            });
        };
        util.objectKeys = typeof Object.keys === "function"
            ? (obj) => Object.keys(obj)
            : (object) => {
                const keys = [];
                for (const key in object) {
                    if (Object.prototype.hasOwnProperty.call(object, key)) {
                        keys.push(key);
                    }
                }
                return keys;
            };
        util.find = (arr, checker) => {
            for (const item of arr) {
                if (checker(item))
                    return item;
            }
            return undefined;
        };
        util.isInteger = typeof Number.isInteger === "function"
            ? (val) => Number.isInteger(val)
            : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
            return array
                .map((val) => (typeof val === "string" ? `'${val}'` : val))
                .join(separator);
        }
        util.joinValues = joinValues;
        util.jsonStringifyReplacer = (_, value) => {
            if (typeof value === "bigint") {
                return value.toString();
            }
            return value;
        };
    })(util || (util = {}));
    const ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set",
    ]);
    const getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
            case "undefined":
                return ZodParsedType.undefined;
            case "string":
                return ZodParsedType.string;
            case "number":
                return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
            case "boolean":
                return ZodParsedType.boolean;
            case "function":
                return ZodParsedType.function;
            case "bigint":
                return ZodParsedType.bigint;
            case "object":
                if (Array.isArray(data)) {
                    return ZodParsedType.array;
                }
                if (data === null) {
                    return ZodParsedType.null;
                }
                if (data.then &&
                    typeof data.then === "function" &&
                    data.catch &&
                    typeof data.catch === "function") {
                    return ZodParsedType.promise;
                }
                if (typeof Map !== "undefined" && data instanceof Map) {
                    return ZodParsedType.map;
                }
                if (typeof Set !== "undefined" && data instanceof Set) {
                    return ZodParsedType.set;
                }
                if (typeof Date !== "undefined" && data instanceof Date) {
                    return ZodParsedType.date;
                }
                return ZodParsedType.object;
            default:
                return ZodParsedType.unknown;
        }
    };
    const ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
    ]);
    const quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
    };
    class ZodError extends Error {
        constructor(issues) {
            super();
            this.issues = [];
            this.addIssue = (sub) => {
                this.issues = [...this.issues, sub];
            };
            this.addIssues = (subs = []) => {
                this.issues = [...this.issues, ...subs];
            };
            const actualProto = new.target.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(this, actualProto);
            }
            else {
                this.__proto__ = actualProto;
            }
            this.name = "ZodError";
            this.issues = issues;
        }
        get errors() {
            return this.issues;
        }
        format(_mapper) {
            const mapper = _mapper ||
                function (issue) {
                    return issue.message;
                };
            const fieldErrors = { _errors: [] };
            const processError = (error) => {
                for (const issue of error.issues) {
                    if (issue.code === "invalid_union") {
                        issue.unionErrors.map(processError);
                    }
                    else if (issue.code === "invalid_return_type") {
                        processError(issue.returnTypeError);
                    }
                    else if (issue.code === "invalid_arguments") {
                        processError(issue.argumentsError);
                    }
                    else if (issue.path.length === 0) {
                        fieldErrors._errors.push(mapper(issue));
                    }
                    else {
                        let curr = fieldErrors;
                        let i = 0;
                        while (i < issue.path.length) {
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (!terminal) {
                                curr[el] = curr[el] || { _errors: [] };
                            }
                            else {
                                curr[el] = curr[el] || { _errors: [] };
                                curr[el]._errors.push(mapper(issue));
                            }
                            curr = curr[el];
                            i++;
                        }
                    }
                }
            };
            processError(this);
            return fieldErrors;
        }
        toString() {
            return this.message;
        }
        get message() {
            return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
            return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
            const fieldErrors = {};
            const formErrors = [];
            for (const sub of this.issues) {
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                }
                else {
                    formErrors.push(mapper(sub));
                }
            }
            return { formErrors, fieldErrors };
        }
        get formErrors() {
            return this.flatten();
        }
    }
    ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
    };
    const errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
            case ZodIssueCode.invalid_type:
                if (issue.received === ZodParsedType.undefined) {
                    message = "Required";
                }
                else {
                    message = `Expected ${issue.expected}, received ${issue.received}`;
                }
                break;
            case ZodIssueCode.invalid_literal:
                message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
                break;
            case ZodIssueCode.unrecognized_keys:
                message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
                break;
            case ZodIssueCode.invalid_union:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_union_discriminator:
                message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
                break;
            case ZodIssueCode.invalid_enum_value:
                message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
                break;
            case ZodIssueCode.invalid_arguments:
                message = `Invalid function arguments`;
                break;
            case ZodIssueCode.invalid_return_type:
                message = `Invalid function return type`;
                break;
            case ZodIssueCode.invalid_date:
                message = `Invalid date`;
                break;
            case ZodIssueCode.invalid_string:
                if (typeof issue.validation === "object") {
                    if ("startsWith" in issue.validation) {
                        message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                    }
                    else if ("endsWith" in issue.validation) {
                        message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                    }
                    else {
                        util.assertNever(issue.validation);
                    }
                }
                else if (issue.validation !== "regex") {
                    message = `Invalid ${issue.validation}`;
                }
                else {
                    message = "Invalid";
                }
                break;
            case ZodIssueCode.too_small:
                if (issue.type === "array")
                    message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
                else if (issue.type === "string")
                    message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
                else if (issue.type === "number")
                    message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
                else if (issue.type === "date")
                    message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;
                else
                    message = "Invalid input";
                break;
            case ZodIssueCode.too_big:
                if (issue.type === "array")
                    message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
                else if (issue.type === "string")
                    message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
                else if (issue.type === "number")
                    message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
                else if (issue.type === "date")
                    message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;
                else
                    message = "Invalid input";
                break;
            case ZodIssueCode.custom:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_intersection_types:
                message = `Intersection results could not be merged`;
                break;
            case ZodIssueCode.not_multiple_of:
                message = `Number must be a multiple of ${issue.multipleOf}`;
                break;
            default:
                message = _ctx.defaultError;
                util.assertNever(issue);
        }
        return { message };
    };
    let overrideErrorMap = errorMap;
    function setErrorMap(map) {
        overrideErrorMap = map;
    }
    function getErrorMap() {
        return overrideErrorMap;
    }
    const makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...(issueData.path || [])];
        const fullIssue = {
            ...issueData,
            path: fullPath,
        };
        let errorMessage = "";
        const maps = errorMaps
            .filter((m) => !!m)
            .slice()
            .reverse();
        for (const map of maps) {
            errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message || errorMessage,
        };
    };
    const EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
            issueData: issueData,
            data: ctx.data,
            path: ctx.path,
            errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap,
            ].filter((x) => !!x),
        });
        ctx.common.issues.push(issue);
    }
    class ParseStatus {
        constructor() {
            this.value = "valid";
        }
        dirty() {
            if (this.value === "valid")
                this.value = "dirty";
        }
        abort() {
            if (this.value !== "aborted")
                this.value = "aborted";
        }
        static mergeArray(status, results) {
            const arrayValue = [];
            for (const s of results) {
                if (s.status === "aborted")
                    return INVALID;
                if (s.status === "dirty")
                    status.dirty();
                arrayValue.push(s.value);
            }
            return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
            const syncPairs = [];
            for (const pair of pairs) {
                syncPairs.push({
                    key: await pair.key,
                    value: await pair.value,
                });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
            const finalObject = {};
            for (const pair of pairs) {
                const { key, value } = pair;
                if (key.status === "aborted")
                    return INVALID;
                if (value.status === "aborted")
                    return INVALID;
                if (key.status === "dirty")
                    status.dirty();
                if (value.status === "dirty")
                    status.dirty();
                if (typeof value.value !== "undefined" || pair.alwaysSet) {
                    finalObject[key.value] = value.value;
                }
            }
            return { status: status.value, value: finalObject };
        }
    }
    const INVALID = Object.freeze({
        status: "aborted",
    });
    const DIRTY = (value) => ({ status: "dirty", value });
    const OK = (value) => ({ status: "valid", value });
    const isAborted = (x) => x.status === "aborted";
    const isDirty = (x) => x.status === "dirty";
    const isValid = (x) => x.status === "valid";
    const isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;
    var errorUtil;
    (function (errorUtil) {
        errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    class ParseInputLazyPath {
        constructor(parent, value, path, key) {
            this.parent = parent;
            this.data = value;
            this._path = path;
            this._key = key;
        }
        get path() {
            return this._path.concat(this._key);
        }
    }
    const handleResult = (ctx, result) => {
        if (isValid(result)) {
            return { success: true, data: result.value };
        }
        else {
            if (!ctx.common.issues.length) {
                throw new Error("Validation failed but no issues detected.");
            }
            const error = new ZodError(ctx.common.issues);
            return { success: false, error };
        }
    };
    function processCreateParams(params) {
        if (!params)
            return {};
        const { errorMap, invalid_type_error, required_error, description } = params;
        if (errorMap && (invalid_type_error || required_error)) {
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap)
            return { errorMap: errorMap, description };
        const customMap = (iss, ctx) => {
            if (iss.code !== "invalid_type")
                return { message: ctx.defaultError };
            if (typeof ctx.data === "undefined") {
                return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
            }
            return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
    }
    class ZodType {
        constructor(def) {
            this.spa = this.safeParseAsync;
            this.superRefine = this._refinement;
            this._def = def;
            this.parse = this.parse.bind(this);
            this.safeParse = this.safeParse.bind(this);
            this.parseAsync = this.parseAsync.bind(this);
            this.safeParseAsync = this.safeParseAsync.bind(this);
            this.spa = this.spa.bind(this);
            this.refine = this.refine.bind(this);
            this.refinement = this.refinement.bind(this);
            this.superRefine = this.superRefine.bind(this);
            this.optional = this.optional.bind(this);
            this.nullable = this.nullable.bind(this);
            this.nullish = this.nullish.bind(this);
            this.array = this.array.bind(this);
            this.promise = this.promise.bind(this);
            this.or = this.or.bind(this);
            this.and = this.and.bind(this);
            this.transform = this.transform.bind(this);
            this.default = this.default.bind(this);
            this.describe = this.describe.bind(this);
            this.isNullable = this.isNullable.bind(this);
            this.isOptional = this.isOptional.bind(this);
        }
        get description() {
            return this._def.description;
        }
        _getType(input) {
            return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
            return (ctx || {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            });
        }
        _processInputParams(input) {
            return {
                status: new ParseStatus(),
                ctx: {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent,
                },
            };
        }
        _parseSync(input) {
            const result = this._parse(input);
            if (isAsync(result)) {
                throw new Error("Synchronous parse encountered promise.");
            }
            return result;
        }
        _parseAsync(input) {
            const result = this._parse(input);
            return Promise.resolve(result);
        }
        parse(data, params) {
            const result = this.safeParse(data, params);
            if (result.success)
                return result.data;
            throw result.error;
        }
        safeParse(data, params) {
            var _a;
            const ctx = {
                common: {
                    issues: [],
                    async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data),
            };
            const result = this._parseSync({ data, path: ctx.path, parent: ctx });
            return handleResult(ctx, result);
        }
        async parseAsync(data, params) {
            const result = await this.safeParseAsync(data, params);
            if (result.success)
                return result.data;
            throw result.error;
        }
        async safeParseAsync(data, params) {
            const ctx = {
                common: {
                    issues: [],
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                    async: true,
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data),
            };
            const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
            const result = await (isAsync(maybeAsyncResult)
                ? maybeAsyncResult
                : Promise.resolve(maybeAsyncResult));
            return handleResult(ctx, result);
        }
        refine(check, message) {
            const getIssueProperties = (val) => {
                if (typeof message === "string" || typeof message === "undefined") {
                    return { message };
                }
                else if (typeof message === "function") {
                    return message(val);
                }
                else {
                    return message;
                }
            };
            return this._refinement((val, ctx) => {
                const result = check(val);
                const setError = () => ctx.addIssue({
                    code: ZodIssueCode.custom,
                    ...getIssueProperties(val),
                });
                if (typeof Promise !== "undefined" && result instanceof Promise) {
                    return result.then((data) => {
                        if (!data) {
                            setError();
                            return false;
                        }
                        else {
                            return true;
                        }
                    });
                }
                if (!result) {
                    setError();
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        refinement(check, refinementData) {
            return this._refinement((val, ctx) => {
                if (!check(val)) {
                    ctx.addIssue(typeof refinementData === "function"
                        ? refinementData(val, ctx)
                        : refinementData);
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        _refinement(refinement) {
            return new ZodEffects({
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: { type: "refinement", refinement },
            });
        }
        optional() {
            return ZodOptional.create(this);
        }
        nullable() {
            return ZodNullable.create(this);
        }
        nullish() {
            return this.optional().nullable();
        }
        array() {
            return ZodArray.create(this);
        }
        promise() {
            return ZodPromise.create(this);
        }
        or(option) {
            return ZodUnion.create([this, option]);
        }
        and(incoming) {
            return ZodIntersection.create(this, incoming);
        }
        transform(transform) {
            return new ZodEffects({
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: { type: "transform", transform },
            });
        }
        default(def) {
            const defaultValueFunc = typeof def === "function" ? def : () => def;
            return new ZodDefault({
                innerType: this,
                defaultValue: defaultValueFunc,
                typeName: ZodFirstPartyTypeKind.ZodDefault,
            });
        }
        brand() {
            return new ZodBranded({
                typeName: ZodFirstPartyTypeKind.ZodBranded,
                type: this,
                ...processCreateParams(undefined),
            });
        }
        describe(description) {
            const This = this.constructor;
            return new This({
                ...this._def,
                description,
            });
        }
        isOptional() {
            return this.safeParse(undefined).success;
        }
        isNullable() {
            return this.safeParse(null).success;
        }
    }
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    class ZodString extends ZodType {
        constructor() {
            super(...arguments);
            this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
                validation,
                code: ZodIssueCode.invalid_string,
                ...errorUtil.errToObj(message),
            });
            this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
            this.trim = () => new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "trim" }],
            });
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.string) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.string,
                    received: ctx.parsedType,
                }
                );
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks) {
                if (check.kind === "min") {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "email") {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "uuid") {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "cuid") {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "url") {
                    try {
                        new URL(input.data);
                    }
                    catch (_a) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "regex") {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "trim") {
                    input.data = input.data.trim();
                }
                else if (check.kind === "startsWith") {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: { startsWith: check.value },
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "endsWith") {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: { endsWith: check.value },
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else {
                    util.assertNever(check);
                }
            }
            return { status: status.value, value: input.data };
        }
        _addCheck(check) {
            return new ZodString({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        email(message) {
            return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
        }
        url(message) {
            return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
        }
        uuid(message) {
            return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
        }
        cuid(message) {
            return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
        }
        regex(regex, message) {
            return this._addCheck({
                kind: "regex",
                regex: regex,
                ...errorUtil.errToObj(message),
            });
        }
        startsWith(value, message) {
            return this._addCheck({
                kind: "startsWith",
                value: value,
                ...errorUtil.errToObj(message),
            });
        }
        endsWith(value, message) {
            return this._addCheck({
                kind: "endsWith",
                value: value,
                ...errorUtil.errToObj(message),
            });
        }
        min(minLength, message) {
            return this._addCheck({
                kind: "min",
                value: minLength,
                ...errorUtil.errToObj(message),
            });
        }
        max(maxLength, message) {
            return this._addCheck({
                kind: "max",
                value: maxLength,
                ...errorUtil.errToObj(message),
            });
        }
        length(len, message) {
            return this.min(len, message).max(len, message);
        }
        get isEmail() {
            return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
            return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isUUID() {
            return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
            return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get minLength() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min;
        }
        get maxLength() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max;
        }
    }
    ZodString.create = (params) => {
        return new ZodString({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodString,
            ...processCreateParams(params),
        });
    };
    function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return (valInt % stepInt) / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
        constructor() {
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
            this.step = this.multipleOf;
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.number) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.number,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            let ctx = undefined;
            const status = new ParseStatus();
            for (const check of this._def.checks) {
                if (check.kind === "int") {
                    if (!util.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "min") {
                    const tooSmall = check.inclusive
                        ? input.data < check.value
                        : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    const tooBig = check.inclusive
                        ? input.data > check.value
                        : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "multipleOf") {
                    if (floatSafeRemainder(input.data, check.value) !== 0) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else {
                    util.assertNever(check);
                }
            }
            return { status: status.value, value: input.data };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil.toString(message),
                    },
                ],
            });
        }
        _addCheck(check) {
            return new ZodNumber({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        int(message) {
            return this._addCheck({
                kind: "int",
                message: errorUtil.toString(message),
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value: value,
                message: errorUtil.toString(message),
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max;
        }
        get isInt() {
            return !!this._def.checks.find((ch) => ch.kind === "int");
        }
    }
    ZodNumber.create = (params) => {
        return new ZodNumber({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodNumber,
            ...processCreateParams(params),
        });
    };
    class ZodBigInt extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.bigint) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodBigInt.create = (params) => {
        return new ZodBigInt({
            typeName: ZodFirstPartyTypeKind.ZodBigInt,
            ...processCreateParams(params),
        });
    };
    class ZodBoolean extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.boolean) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.boolean,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodBoolean.create = (params) => {
        return new ZodBoolean({
            typeName: ZodFirstPartyTypeKind.ZodBoolean,
            ...processCreateParams(params),
        });
    };
    class ZodDate extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.date) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.date,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (isNaN(input.data.getTime())) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_date,
                });
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks) {
                if (check.kind === "min") {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            minimum: check.value,
                            type: "date",
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            maximum: check.value,
                            type: "date",
                        });
                        status.dirty();
                    }
                }
                else {
                    util.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: new Date(input.data.getTime()),
            };
        }
        _addCheck(check) {
            return new ZodDate({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        min(minDate, message) {
            return this._addCheck({
                kind: "min",
                value: minDate.getTime(),
                message: errorUtil.toString(message),
            });
        }
        max(maxDate, message) {
            return this._addCheck({
                kind: "max",
                value: maxDate.getTime(),
                message: errorUtil.toString(message),
            });
        }
        get minDate() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min != null ? new Date(min) : null;
        }
        get maxDate() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max != null ? new Date(max) : null;
        }
    }
    ZodDate.create = (params) => {
        return new ZodDate({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodDate,
            ...processCreateParams(params),
        });
    };
    class ZodUndefined extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.undefined,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodUndefined.create = (params) => {
        return new ZodUndefined({
            typeName: ZodFirstPartyTypeKind.ZodUndefined,
            ...processCreateParams(params),
        });
    };
    class ZodNull extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.null) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.null,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodNull.create = (params) => {
        return new ZodNull({
            typeName: ZodFirstPartyTypeKind.ZodNull,
            ...processCreateParams(params),
        });
    };
    class ZodAny extends ZodType {
        constructor() {
            super(...arguments);
            this._any = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodAny.create = (params) => {
        return new ZodAny({
            typeName: ZodFirstPartyTypeKind.ZodAny,
            ...processCreateParams(params),
        });
    };
    class ZodUnknown extends ZodType {
        constructor() {
            super(...arguments);
            this._unknown = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodUnknown.create = (params) => {
        return new ZodUnknown({
            typeName: ZodFirstPartyTypeKind.ZodUnknown,
            ...processCreateParams(params),
        });
    };
    class ZodNever extends ZodType {
        _parse(input) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.never,
                received: ctx.parsedType,
            });
            return INVALID;
        }
    }
    ZodNever.create = (params) => {
        return new ZodNever({
            typeName: ZodFirstPartyTypeKind.ZodNever,
            ...processCreateParams(params),
        });
    };
    class ZodVoid extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.void,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodVoid.create = (params) => {
        return new ZodVoid({
            typeName: ZodFirstPartyTypeKind.ZodVoid,
            ...processCreateParams(params),
        });
    };
    class ZodArray extends ZodType {
        _parse(input) {
            const { ctx, status } = this._processInputParams(input);
            const def = this._def;
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (def.minLength !== null) {
                if (ctx.data.length < def.minLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minLength.value,
                        type: "array",
                        inclusive: true,
                        message: def.minLength.message,
                    });
                    status.dirty();
                }
            }
            if (def.maxLength !== null) {
                if (ctx.data.length > def.maxLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxLength.value,
                        type: "array",
                        inclusive: true,
                        message: def.maxLength.message,
                    });
                    status.dirty();
                }
            }
            if (ctx.common.async) {
                return Promise.all(ctx.data.map((item, i) => {
                    return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
                })).then((result) => {
                    return ParseStatus.mergeArray(status, result);
                });
            }
            const result = ctx.data.map((item, i) => {
                return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            });
            return ParseStatus.mergeArray(status, result);
        }
        get element() {
            return this._def.type;
        }
        min(minLength, message) {
            return new ZodArray({
                ...this._def,
                minLength: { value: minLength, message: errorUtil.toString(message) },
            });
        }
        max(maxLength, message) {
            return new ZodArray({
                ...this._def,
                maxLength: { value: maxLength, message: errorUtil.toString(message) },
            });
        }
        length(len, message) {
            return this.min(len, message).max(len, message);
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodArray.create = (schema, params) => {
        return new ZodArray({
            type: schema,
            minLength: null,
            maxLength: null,
            typeName: ZodFirstPartyTypeKind.ZodArray,
            ...processCreateParams(params),
        });
    };
    var objectUtil;
    (function (objectUtil) {
        objectUtil.mergeShapes = (first, second) => {
            return {
                ...first,
                ...second,
            };
        };
    })(objectUtil || (objectUtil = {}));
    const AugmentFactory = (def) => (augmentation) => {
        return new ZodObject({
            ...def,
            shape: () => ({
                ...def.shape(),
                ...augmentation,
            }),
        });
    };
    function deepPartialify(schema) {
        if (schema instanceof ZodObject) {
            const newShape = {};
            for (const key in schema.shape) {
                const fieldSchema = schema.shape[key];
                newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
            }
            return new ZodObject({
                ...schema._def,
                shape: () => newShape,
            });
        }
        else if (schema instanceof ZodArray) {
            return ZodArray.create(deepPartialify(schema.element));
        }
        else if (schema instanceof ZodOptional) {
            return ZodOptional.create(deepPartialify(schema.unwrap()));
        }
        else if (schema instanceof ZodNullable) {
            return ZodNullable.create(deepPartialify(schema.unwrap()));
        }
        else if (schema instanceof ZodTuple) {
            return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
        }
        else {
            return schema;
        }
    }
    class ZodObject extends ZodType {
        constructor() {
            super(...arguments);
            this._cached = null;
            this.nonstrict = this.passthrough;
            this.augment = AugmentFactory(this._def);
            this.extend = AugmentFactory(this._def);
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const shape = this._def.shape();
            const keys = util.objectKeys(shape);
            return (this._cached = { shape, keys });
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.object) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const { status, ctx } = this._processInputParams(input);
            const { shape, keys: shapeKeys } = this._getCached();
            const extraKeys = [];
            if (!(this._def.catchall instanceof ZodNever &&
                this._def.unknownKeys === "strip")) {
                for (const key in ctx.data) {
                    if (!shapeKeys.includes(key)) {
                        extraKeys.push(key);
                    }
                }
            }
            const pairs = [];
            for (const key of shapeKeys) {
                const keyValidator = shape[key];
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                    alwaysSet: key in ctx.data,
                });
            }
            if (this._def.catchall instanceof ZodNever) {
                const unknownKeys = this._def.unknownKeys;
                if (unknownKeys === "passthrough") {
                    for (const key of extraKeys) {
                        pairs.push({
                            key: { status: "valid", value: key },
                            value: { status: "valid", value: ctx.data[key] },
                        });
                    }
                }
                else if (unknownKeys === "strict") {
                    if (extraKeys.length > 0) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.unrecognized_keys,
                            keys: extraKeys,
                        });
                        status.dirty();
                    }
                }
                else if (unknownKeys === "strip") ;
                else {
                    throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
                }
            }
            else {
                const catchall = this._def.catchall;
                for (const key of extraKeys) {
                    const value = ctx.data[key];
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)
                        ),
                        alwaysSet: key in ctx.data,
                    });
                }
            }
            if (ctx.common.async) {
                return Promise.resolve()
                    .then(async () => {
                    const syncPairs = [];
                    for (const pair of pairs) {
                        const key = await pair.key;
                        syncPairs.push({
                            key,
                            value: await pair.value,
                            alwaysSet: pair.alwaysSet,
                        });
                    }
                    return syncPairs;
                })
                    .then((syncPairs) => {
                    return ParseStatus.mergeObjectSync(status, syncPairs);
                });
            }
            else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get shape() {
            return this._def.shape();
        }
        strict(message) {
            errorUtil.errToObj;
            return new ZodObject({
                ...this._def,
                unknownKeys: "strict",
                ...(message !== undefined
                    ? {
                        errorMap: (issue, ctx) => {
                            var _a, _b, _c, _d;
                            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                            if (issue.code === "unrecognized_keys")
                                return {
                                    message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                                };
                            return {
                                message: defaultError,
                            };
                        },
                    }
                    : {}),
            });
        }
        strip() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "strip",
            });
        }
        passthrough() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "passthrough",
            });
        }
        setKey(key, schema) {
            return this.augment({ [key]: schema });
        }
        merge(merging) {
            const merged = new ZodObject({
                unknownKeys: merging._def.unknownKeys,
                catchall: merging._def.catchall,
                shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
                typeName: ZodFirstPartyTypeKind.ZodObject,
            });
            return merged;
        }
        catchall(index) {
            return new ZodObject({
                ...this._def,
                catchall: index,
            });
        }
        pick(mask) {
            const shape = {};
            util.objectKeys(mask).map((key) => {
                if (this.shape[key])
                    shape[key] = this.shape[key];
            });
            return new ZodObject({
                ...this._def,
                shape: () => shape,
            });
        }
        omit(mask) {
            const shape = {};
            util.objectKeys(this.shape).map((key) => {
                if (util.objectKeys(mask).indexOf(key) === -1) {
                    shape[key] = this.shape[key];
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => shape,
            });
        }
        deepPartial() {
            return deepPartialify(this);
        }
        partial(mask) {
            const newShape = {};
            if (mask) {
                util.objectKeys(this.shape).map((key) => {
                    if (util.objectKeys(mask).indexOf(key) === -1) {
                        newShape[key] = this.shape[key];
                    }
                    else {
                        newShape[key] = this.shape[key].optional();
                    }
                });
                return new ZodObject({
                    ...this._def,
                    shape: () => newShape,
                });
            }
            else {
                for (const key in this.shape) {
                    const fieldSchema = this.shape[key];
                    newShape[key] = fieldSchema.optional();
                }
            }
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        required() {
            const newShape = {};
            for (const key in this.shape) {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        keyof() {
            return createZodEnum(util.objectKeys(this.shape));
        }
    }
    ZodObject.create = (shape, params) => {
        return new ZodObject({
            shape: () => shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    ZodObject.strictCreate = (shape, params) => {
        return new ZodObject({
            shape: () => shape,
            unknownKeys: "strict",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    ZodObject.lazycreate = (shape, params) => {
        return new ZodObject({
            shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    class ZodUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const options = this._def.options;
            function handleResults(results) {
                for (const result of results) {
                    if (result.result.status === "valid") {
                        return result.result;
                    }
                }
                for (const result of results) {
                    if (result.result.status === "dirty") {
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                }
                const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors,
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return Promise.all(options.map(async (option) => {
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: [],
                        },
                        parent: null,
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx,
                        }),
                        ctx: childCtx,
                    };
                })).then(handleResults);
            }
            else {
                let dirty = undefined;
                const issues = [];
                for (const option of options) {
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: [],
                        },
                        parent: null,
                    };
                    const result = option._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    });
                    if (result.status === "valid") {
                        return result;
                    }
                    else if (result.status === "dirty" && !dirty) {
                        dirty = { result, ctx: childCtx };
                    }
                    if (childCtx.common.issues.length) {
                        issues.push(childCtx.common.issues);
                    }
                }
                if (dirty) {
                    ctx.common.issues.push(...dirty.ctx.common.issues);
                    return dirty.result;
                }
                const unionErrors = issues.map((issues) => new ZodError(issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors,
                });
                return INVALID;
            }
        }
        get options() {
            return this._def.options;
        }
    }
    ZodUnion.create = (types, params) => {
        return new ZodUnion({
            options: types,
            typeName: ZodFirstPartyTypeKind.ZodUnion,
            ...processCreateParams(params),
        });
    };
    class ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const discriminator = this.discriminator;
            const discriminatorValue = ctx.data[discriminator];
            const option = this.options.get(discriminatorValue);
            if (!option) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union_discriminator,
                    options: this.validDiscriminatorValues,
                    path: [discriminator],
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
            }
            else {
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        get discriminator() {
            return this._def.discriminator;
        }
        get validDiscriminatorValues() {
            return Array.from(this.options.keys());
        }
        get options() {
            return this._def.options;
        }
        static create(discriminator, types, params) {
            const options = new Map();
            try {
                types.forEach((type) => {
                    const discriminatorValue = type.shape[discriminator].value;
                    options.set(discriminatorValue, type);
                });
            }
            catch (e) {
                throw new Error("The discriminator value could not be extracted from all the provided schemas");
            }
            if (options.size !== types.length) {
                throw new Error("Some of the discriminator values are not unique");
            }
            return new ZodDiscriminatedUnion({
                typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                discriminator,
                options,
                ...processCreateParams(params),
            });
        }
    }
    function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
            return { valid: true, data: a };
        }
        else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
            const bKeys = util.objectKeys(b);
            const sharedKeys = util
                .objectKeys(a)
                .filter((key) => bKeys.indexOf(key) !== -1);
            const newObj = { ...a, ...b };
            for (const key of sharedKeys) {
                const sharedValue = mergeValues(a[key], b[key]);
                if (!sharedValue.valid) {
                    return { valid: false };
                }
                newObj[key] = sharedValue.data;
            }
            return { valid: true, data: newObj };
        }
        else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
            if (a.length !== b.length) {
                return { valid: false };
            }
            const newArray = [];
            for (let index = 0; index < a.length; index++) {
                const itemA = a[index];
                const itemB = b[index];
                const sharedValue = mergeValues(itemA, itemB);
                if (!sharedValue.valid) {
                    return { valid: false };
                }
                newArray.push(sharedValue.data);
            }
            return { valid: true, data: newArray };
        }
        else if (aType === ZodParsedType.date &&
            bType === ZodParsedType.date &&
            +a === +b) {
            return { valid: true, data: a };
        }
        else {
            return { valid: false };
        }
    }
    class ZodIntersection extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const handleParsed = (parsedLeft, parsedRight) => {
                if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                    return INVALID;
                }
                const merged = mergeValues(parsedLeft.value, parsedRight.value);
                if (!merged.valid) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_intersection_types,
                    });
                    return INVALID;
                }
                if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                    status.dirty();
                }
                return { status: status.value, value: merged.data };
            };
            if (ctx.common.async) {
                return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    }),
                ]).then(([left, right]) => handleParsed(left, right));
            }
            else {
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }));
            }
        }
    }
    ZodIntersection.create = (left, right, params) => {
        return new ZodIntersection({
            left: left,
            right: right,
            typeName: ZodFirstPartyTypeKind.ZodIntersection,
            ...processCreateParams(params),
        });
    };
    class ZodTuple extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (ctx.data.length < this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: true,
                    type: "array",
                });
                return INVALID;
            }
            const rest = this._def.rest;
            if (!rest && ctx.data.length > this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: this._def.items.length,
                    inclusive: true,
                    type: "array",
                });
                status.dirty();
            }
            const items = ctx.data
                .map((item, itemIndex) => {
                const schema = this._def.items[itemIndex] || this._def.rest;
                if (!schema)
                    return null;
                return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
            })
                .filter((x) => !!x);
            if (ctx.common.async) {
                return Promise.all(items).then((results) => {
                    return ParseStatus.mergeArray(status, results);
                });
            }
            else {
                return ParseStatus.mergeArray(status, items);
            }
        }
        get items() {
            return this._def.items;
        }
        rest(rest) {
            return new ZodTuple({
                ...this._def,
                rest,
            });
        }
    }
    ZodTuple.create = (schemas, params) => {
        if (!Array.isArray(schemas)) {
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple({
            items: schemas,
            typeName: ZodFirstPartyTypeKind.ZodTuple,
            rest: null,
            ...processCreateParams(params),
        });
    };
    class ZodRecord extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const pairs = [];
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            for (const key in ctx.data) {
                pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                });
            }
            if (ctx.common.async) {
                return ParseStatus.mergeObjectAsync(status, pairs);
            }
            else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get element() {
            return this._def.valueType;
        }
        static create(first, second, third) {
            if (second instanceof ZodType) {
                return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third),
                });
            }
            return new ZodRecord({
                keyType: ZodString.create(),
                valueType: first,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(second),
            });
        }
    }
    class ZodMap extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.map) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.map,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            const pairs = [...ctx.data.entries()].map(([key, value], index) => {
                return {
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                    value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
                };
            });
            if (ctx.common.async) {
                const finalMap = new Map();
                return Promise.resolve().then(async () => {
                    for (const pair of pairs) {
                        const key = await pair.key;
                        const value = await pair.value;
                        if (key.status === "aborted" || value.status === "aborted") {
                            return INVALID;
                        }
                        if (key.status === "dirty" || value.status === "dirty") {
                            status.dirty();
                        }
                        finalMap.set(key.value, value.value);
                    }
                    return { status: status.value, value: finalMap };
                });
            }
            else {
                const finalMap = new Map();
                for (const pair of pairs) {
                    const key = pair.key;
                    const value = pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            }
        }
    }
    ZodMap.create = (keyType, valueType, params) => {
        return new ZodMap({
            valueType,
            keyType,
            typeName: ZodFirstPartyTypeKind.ZodMap,
            ...processCreateParams(params),
        });
    };
    class ZodSet extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.set) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.set,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const def = this._def;
            if (def.minSize !== null) {
                if (ctx.data.size < def.minSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minSize.value,
                        type: "set",
                        inclusive: true,
                        message: def.minSize.message,
                    });
                    status.dirty();
                }
            }
            if (def.maxSize !== null) {
                if (ctx.data.size > def.maxSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxSize.value,
                        type: "set",
                        inclusive: true,
                        message: def.maxSize.message,
                    });
                    status.dirty();
                }
            }
            const valueType = this._def.valueType;
            function finalizeSet(elements) {
                const parsedSet = new Set();
                for (const element of elements) {
                    if (element.status === "aborted")
                        return INVALID;
                    if (element.status === "dirty")
                        status.dirty();
                    parsedSet.add(element.value);
                }
                return { status: status.value, value: parsedSet };
            }
            const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
            if (ctx.common.async) {
                return Promise.all(elements).then((elements) => finalizeSet(elements));
            }
            else {
                return finalizeSet(elements);
            }
        }
        min(minSize, message) {
            return new ZodSet({
                ...this._def,
                minSize: { value: minSize, message: errorUtil.toString(message) },
            });
        }
        max(maxSize, message) {
            return new ZodSet({
                ...this._def,
                maxSize: { value: maxSize, message: errorUtil.toString(message) },
            });
        }
        size(size, message) {
            return this.min(size, message).max(size, message);
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodSet.create = (valueType, params) => {
        return new ZodSet({
            valueType,
            minSize: null,
            maxSize: null,
            typeName: ZodFirstPartyTypeKind.ZodSet,
            ...processCreateParams(params),
        });
    };
    class ZodFunction extends ZodType {
        constructor() {
            super(...arguments);
            this.validate = this.implement;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.function) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.function,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            function makeArgsIssue(args, error) {
                return makeIssue({
                    data: args,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap,
                    ].filter((x) => !!x),
                    issueData: {
                        code: ZodIssueCode.invalid_arguments,
                        argumentsError: error,
                    },
                });
            }
            function makeReturnsIssue(returns, error) {
                return makeIssue({
                    data: returns,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap,
                    ].filter((x) => !!x),
                    issueData: {
                        code: ZodIssueCode.invalid_return_type,
                        returnTypeError: error,
                    },
                });
            }
            const params = { errorMap: ctx.common.contextualErrorMap };
            const fn = ctx.data;
            if (this._def.returns instanceof ZodPromise) {
                return OK(async (...args) => {
                    const error = new ZodError([]);
                    const parsedArgs = await this._def.args
                        .parseAsync(args, params)
                        .catch((e) => {
                        error.addIssue(makeArgsIssue(args, e));
                        throw error;
                    });
                    const result = await fn(...parsedArgs);
                    const parsedReturns = await this._def.returns._def.type
                        .parseAsync(result, params)
                        .catch((e) => {
                        error.addIssue(makeReturnsIssue(result, e));
                        throw error;
                    });
                    return parsedReturns;
                });
            }
            else {
                return OK((...args) => {
                    const parsedArgs = this._def.args.safeParse(args, params);
                    if (!parsedArgs.success) {
                        throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                    }
                    const result = fn(...parsedArgs.data);
                    const parsedReturns = this._def.returns.safeParse(result, params);
                    if (!parsedReturns.success) {
                        throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                    }
                    return parsedReturns.data;
                });
            }
        }
        parameters() {
            return this._def.args;
        }
        returnType() {
            return this._def.returns;
        }
        args(...items) {
            return new ZodFunction({
                ...this._def,
                args: ZodTuple.create(items).rest(ZodUnknown.create()),
            });
        }
        returns(returnType) {
            return new ZodFunction({
                ...this._def,
                returns: returnType,
            });
        }
        implement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        strictImplement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        static create(args, returns, params) {
            return new ZodFunction({
                args: (args
                    ? args
                    : ZodTuple.create([]).rest(ZodUnknown.create())),
                returns: returns || ZodUnknown.create(),
                typeName: ZodFirstPartyTypeKind.ZodFunction,
                ...processCreateParams(params),
            });
        }
    }
    class ZodLazy extends ZodType {
        get schema() {
            return this._def.getter();
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const lazySchema = this._def.getter();
            return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
    }
    ZodLazy.create = (getter, params) => {
        return new ZodLazy({
            getter: getter,
            typeName: ZodFirstPartyTypeKind.ZodLazy,
            ...processCreateParams(params),
        });
    };
    class ZodLiteral extends ZodType {
        _parse(input) {
            if (input.data !== this._def.value) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_literal,
                    expected: this._def.value,
                });
                return INVALID;
            }
            return { status: "valid", value: input.data };
        }
        get value() {
            return this._def.value;
        }
    }
    ZodLiteral.create = (value, params) => {
        return new ZodLiteral({
            value: value,
            typeName: ZodFirstPartyTypeKind.ZodLiteral,
            ...processCreateParams(params),
        });
    };
    function createZodEnum(values, params) {
        return new ZodEnum({
            values: values,
            typeName: ZodFirstPartyTypeKind.ZodEnum,
            ...processCreateParams(params),
        });
    }
    class ZodEnum extends ZodType {
        _parse(input) {
            if (typeof input.data !== "string") {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    expected: util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type,
                });
                return INVALID;
            }
            if (this._def.values.indexOf(input.data) === -1) {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues,
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get options() {
            return this._def.values;
        }
        get enum() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Values() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Enum() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
    }
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
        _parse(input) {
            const nativeEnumValues = util.getValidEnumValues(this._def.values);
            const ctx = this._getOrReturnCtx(input);
            if (ctx.parsedType !== ZodParsedType.string &&
                ctx.parsedType !== ZodParsedType.number) {
                const expectedValues = util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    expected: util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type,
                });
                return INVALID;
            }
            if (nativeEnumValues.indexOf(input.data) === -1) {
                const expectedValues = util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues,
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get enum() {
            return this._def.values;
        }
    }
    ZodNativeEnum.create = (values, params) => {
        return new ZodNativeEnum({
            values: values,
            typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
            ...processCreateParams(params),
        });
    };
    class ZodPromise extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.promise &&
                ctx.common.async === false) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.promise,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const promisified = ctx.parsedType === ZodParsedType.promise
                ? ctx.data
                : Promise.resolve(ctx.data);
            return OK(promisified.then((data) => {
                return this._def.type.parseAsync(data, {
                    path: ctx.path,
                    errorMap: ctx.common.contextualErrorMap,
                });
            }));
        }
    }
    ZodPromise.create = (schema, params) => {
        return new ZodPromise({
            type: schema,
            typeName: ZodFirstPartyTypeKind.ZodPromise,
            ...processCreateParams(params),
        });
    };
    class ZodEffects extends ZodType {
        innerType() {
            return this._def.schema;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const effect = this._def.effect || null;
            if (effect.type === "preprocess") {
                const processed = effect.transform(ctx.data);
                if (ctx.common.async) {
                    return Promise.resolve(processed).then((processed) => {
                        return this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx,
                        });
                    });
                }
                else {
                    return this._def.schema._parseSync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            }
            const checkCtx = {
                addIssue: (arg) => {
                    addIssueToContext(ctx, arg);
                    if (arg.fatal) {
                        status.abort();
                    }
                    else {
                        status.dirty();
                    }
                },
                get path() {
                    return ctx.path;
                },
            };
            checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
            if (effect.type === "refinement") {
                const executeRefinement = (acc
                ) => {
                    const result = effect.refinement(acc, checkCtx);
                    if (ctx.common.async) {
                        return Promise.resolve(result);
                    }
                    if (result instanceof Promise) {
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    }
                    return acc;
                };
                if (ctx.common.async === false) {
                    const inner = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    executeRefinement(inner.value);
                    return { status: status.value, value: inner.value };
                }
                else {
                    return this._def.schema
                        ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                        .then((inner) => {
                        if (inner.status === "aborted")
                            return INVALID;
                        if (inner.status === "dirty")
                            status.dirty();
                        return executeRefinement(inner.value).then(() => {
                            return { status: status.value, value: inner.value };
                        });
                    });
                }
            }
            if (effect.type === "transform") {
                if (ctx.common.async === false) {
                    const base = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (!isValid(base))
                        return base;
                    const result = effect.transform(base.value, checkCtx);
                    if (result instanceof Promise) {
                        throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                    }
                    return { status: status.value, value: result };
                }
                else {
                    return this._def.schema
                        ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                        .then((base) => {
                        if (!isValid(base))
                            return base;
                        return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                    });
                }
            }
            util.assertNever(effect);
        }
    }
    ZodEffects.create = (schema, effect, params) => {
        return new ZodEffects({
            schema,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect,
            ...processCreateParams(params),
        });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects({
            schema,
            effect: { type: "preprocess", transform: preprocess },
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            ...processCreateParams(params),
        });
    };
    class ZodOptional extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.undefined) {
                return OK(undefined);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodOptional.create = (type, params) => {
        return new ZodOptional({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params),
        });
    };
    class ZodNullable extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.null) {
                return OK(null);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodNullable.create = (type, params) => {
        return new ZodNullable({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodNullable,
            ...processCreateParams(params),
        });
    };
    class ZodDefault extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            let data = ctx.data;
            if (ctx.parsedType === ZodParsedType.undefined) {
                data = this._def.defaultValue();
            }
            return this._def.innerType._parse({
                data,
                path: ctx.path,
                parent: ctx,
            });
        }
        removeDefault() {
            return this._def.innerType;
        }
    }
    ZodDefault.create = (type, params) => {
        return new ZodOptional({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params),
        });
    };
    class ZodNaN extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.nan) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.nan,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return { status: "valid", value: input.data };
        }
    }
    ZodNaN.create = (params) => {
        return new ZodNaN({
            typeName: ZodFirstPartyTypeKind.ZodNaN,
            ...processCreateParams(params),
        });
    };
    const BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const data = ctx.data;
            return this._def.type._parse({
                data,
                path: ctx.path,
                parent: ctx,
            });
        }
        unwrap() {
            return this._def.type;
        }
    }
    const custom = (check, params = {}, fatal) => {
        if (check)
            return ZodAny.create().superRefine((data, ctx) => {
                if (!check(data)) {
                    const p = typeof params === "function" ? params(data) : params;
                    const p2 = typeof p === "string" ? { message: p } : p;
                    ctx.addIssue({ code: "custom", ...p2, fatal });
                }
            });
        return ZodAny.create();
    };
    const late = {
        object: ZodObject.lazycreate,
    };
    var ZodFirstPartyTypeKind;
    (function (ZodFirstPartyTypeKind) {
        ZodFirstPartyTypeKind["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    const instanceOfType = (cls, params = {
        message: `Input not instance of ${cls.name}`,
    }) => custom((data) => data instanceof cls, params, true);
    const stringType = ZodString.create;
    const numberType = ZodNumber.create;
    const nanType = ZodNaN.create;
    const bigIntType = ZodBigInt.create;
    const booleanType = ZodBoolean.create;
    const dateType = ZodDate.create;
    const undefinedType = ZodUndefined.create;
    const nullType = ZodNull.create;
    const anyType = ZodAny.create;
    const unknownType = ZodUnknown.create;
    const neverType = ZodNever.create;
    const voidType = ZodVoid.create;
    const arrayType = ZodArray.create;
    const objectType = ZodObject.create;
    const strictObjectType = ZodObject.strictCreate;
    const unionType = ZodUnion.create;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    const intersectionType = ZodIntersection.create;
    const tupleType = ZodTuple.create;
    const recordType = ZodRecord.create;
    const mapType = ZodMap.create;
    const setType = ZodSet.create;
    const functionType = ZodFunction.create;
    const lazyType = ZodLazy.create;
    const literalType = ZodLiteral.create;
    const enumType = ZodEnum.create;
    const nativeEnumType = ZodNativeEnum.create;
    const promiseType = ZodPromise.create;
    const effectsType = ZodEffects.create;
    const optionalType = ZodOptional.create;
    const nullableType = ZodNullable.create;
    const preprocessType = ZodEffects.createWithPreprocess;
    const ostring = () => stringType().optional();
    const onumber = () => numberType().optional();
    const oboolean = () => booleanType().optional();
    const NEVER = INVALID;
    var mod = Object.freeze({
        __proto__: null,
        getParsedType: getParsedType,
        ZodParsedType: ZodParsedType,
        defaultErrorMap: errorMap,
        setErrorMap: setErrorMap,
        getErrorMap: getErrorMap,
        makeIssue: makeIssue,
        EMPTY_PATH: EMPTY_PATH,
        addIssueToContext: addIssueToContext,
        ParseStatus: ParseStatus,
        INVALID: INVALID,
        DIRTY: DIRTY,
        OK: OK,
        isAborted: isAborted,
        isDirty: isDirty,
        isValid: isValid,
        isAsync: isAsync,
        ZodType: ZodType,
        ZodString: ZodString,
        ZodNumber: ZodNumber,
        ZodBigInt: ZodBigInt,
        ZodBoolean: ZodBoolean,
        ZodDate: ZodDate,
        ZodUndefined: ZodUndefined,
        ZodNull: ZodNull,
        ZodAny: ZodAny,
        ZodUnknown: ZodUnknown,
        ZodNever: ZodNever,
        ZodVoid: ZodVoid,
        ZodArray: ZodArray,
        get objectUtil () { return objectUtil; },
        ZodObject: ZodObject,
        ZodUnion: ZodUnion,
        ZodDiscriminatedUnion: ZodDiscriminatedUnion,
        ZodIntersection: ZodIntersection,
        ZodTuple: ZodTuple,
        ZodRecord: ZodRecord,
        ZodMap: ZodMap,
        ZodSet: ZodSet,
        ZodFunction: ZodFunction,
        ZodLazy: ZodLazy,
        ZodLiteral: ZodLiteral,
        ZodEnum: ZodEnum,
        ZodNativeEnum: ZodNativeEnum,
        ZodPromise: ZodPromise,
        ZodEffects: ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional: ZodOptional,
        ZodNullable: ZodNullable,
        ZodDefault: ZodDefault,
        ZodNaN: ZodNaN,
        BRAND: BRAND,
        ZodBranded: ZodBranded,
        custom: custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late: late,
        get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        'enum': enumType,
        'function': functionType,
        'instanceof': instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        'null': nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean: oboolean,
        onumber: onumber,
        optional: optionalType,
        ostring: ostring,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        transformer: effectsType,
        tuple: tupleType,
        'undefined': undefinedType,
        union: unionType,
        unknown: unknownType,
        'void': voidType,
        NEVER: NEVER,
        ZodIssueCode: ZodIssueCode,
        quotelessJson: quotelessJson,
        ZodError: ZodError
    });

    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-DomainType
     */
    exports.DomainType = void 0;
    (function (DomainType) {
        DomainType["FirstParty"] = "firstParty";
        DomainType["ThirdParty"] = "thirdParty";
    })(exports.DomainType || (exports.DomainType = {}));
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType
     */
    exports.ResourceType = void 0;
    (function (ResourceType) {
        ResourceType["MainFrame"] = "main_frame";
        ResourceType["SubFrame"] = "sub_frame";
        ResourceType["Stylesheet"] = "stylesheet";
        ResourceType["Script"] = "script";
        ResourceType["Image"] = "image";
        ResourceType["Font"] = "font";
        ResourceType["Object"] = "object";
        ResourceType["XmlHttpRequest"] = "xmlhttprequest";
        ResourceType["Ping"] = "ping";
        ResourceType["CspReport"] = "csp_report";
        ResourceType["Media"] = "media";
        ResourceType["WebSocket"] = "websocket";
        ResourceType["WebTransport"] = "webtransport";
        ResourceType["WebBundle"] = "webbundle";
        ResourceType["Other"] = "other";
    })(exports.ResourceType || (exports.ResourceType = {}));
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-QueryKeyValue
     */
    var QueryKeyValueValidator = mod.strictObject({
        key: mod.string(),
        replaceOnly: mod.boolean().optional(),
        value: mod.string(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-QueryTransform
     */
    var QueryTransformValidator = mod.strictObject({
        addOrReplaceParams: QueryKeyValueValidator.array().optional(),
        removeParams: mod.string().array().optional(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-URLTransform
     */
    var URLTransformValidator = mod.strictObject({
        fragment: mod.string().optional(),
        host: mod.string().optional(),
        password: mod.string().optional(),
        path: mod.string().optional(),
        port: mod.string().optional(),
        query: mod.string().optional(),
        queryTransform: QueryTransformValidator.optional(),
        scheme: mod.string().optional(),
        username: mod.string().optional(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-Redirect
     */
    var RedirectValidator = mod.strictObject({
        extensionPath: mod.string().optional(),
        regexSubstitution: mod.string().optional(),
        transform: URLTransformValidator.optional(),
        url: mod.string().optional(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-HeaderOperation
     */
    exports.HeaderOperation = void 0;
    (function (HeaderOperation) {
        HeaderOperation["Append"] = "append";
        HeaderOperation["Set"] = "set";
        HeaderOperation["Remove"] = "remove";
    })(exports.HeaderOperation || (exports.HeaderOperation = {}));
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ModifyHeaderInfo
     */
    var ModifyHeaderInfoValidator = mod.strictObject({
        header: mod.string(),
        operation: mod.nativeEnum(exports.HeaderOperation),
        value: mod.string().optional(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleActionType
     */
    exports.RuleActionType = void 0;
    (function (RuleActionType) {
        RuleActionType["BLOCK"] = "block";
        RuleActionType["REDIRECT"] = "redirect";
        RuleActionType["ALLOW"] = "allow";
        RuleActionType["UPGRADE_SCHEME"] = "upgradeScheme";
        RuleActionType["MODIFY_HEADERS"] = "modifyHeaders";
        RuleActionType["ALLOW_ALL_REQUESTS"] = "allowAllRequests";
    })(exports.RuleActionType || (exports.RuleActionType = {}));
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleAction
     */
    var RuleActionValidator = mod.strictObject({
        redirect: RedirectValidator.optional(),
        requestHeaders: ModifyHeaderInfoValidator.array().optional(),
        responseHeaders: ModifyHeaderInfoValidator.array().optional(),
        type: mod.nativeEnum(exports.RuleActionType),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RequestMethod
     */
    exports.RequestMethod = void 0;
    (function (RequestMethod) {
        RequestMethod["Connect"] = "connect";
        RequestMethod["Delete"] = "delete";
        RequestMethod["Get"] = "get";
        RequestMethod["Head"] = "head";
        RequestMethod["Options"] = "options";
        RequestMethod["Patch"] = "patch";
        RequestMethod["Post"] = "post";
        RequestMethod["Put"] = "put";
    })(exports.RequestMethod || (exports.RequestMethod = {}));
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleCondition
     */
    var RuleConditionValidator = mod.strictObject({
        domainType: mod.nativeEnum(exports.DomainType).optional(),
        excludedInitiatorDomains: mod.string().array().optional(),
        excludedRequestDomains: mod.string().array().optional(),
        excludedRequestMethods: mod.nativeEnum(exports.RequestMethod).array().optional(),
        excludedResourceTypes: mod.nativeEnum(exports.ResourceType).array().optional(),
        excludedTabIds: mod.number().array().optional(),
        initiatorDomains: mod.string().array().optional(),
        isUrlFilterCaseSensitive: mod.boolean().optional(),
        regexFilter: mod.string().optional(),
        requestDomains: mod.string().array().optional(),
        requestMethods: mod.string().array().optional(),
        resourceTypes: mod.nativeEnum(exports.ResourceType).array().optional(),
        tabIds: mod.number().array().optional(),
        urlFilter: mod.string().optional(),
    });
    /**
     * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-Rule
     */
    var DeclarativeRuleValidator = mod.strictObject({
        action: RuleActionValidator,
        condition: RuleConditionValidator,
        id: mod.number(),
        priority: mod.number().optional(),
    });

    /**
     * Describes error when maximum number of rules is equal or less than 0.
     */
    var EmptyOrNegativeNumberOfRulesError = /** @class */ (function (_super) {
        __extends(EmptyOrNegativeNumberOfRulesError, _super);
        /**
         * Describes error when maximum number of rules is equal or less than 0.
         *
         * @param message Message of error.
         */
        function EmptyOrNegativeNumberOfRulesError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'EmptyOrNegativeNumberOfRulesError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, EmptyOrNegativeNumberOfRulesError.prototype);
            return _this;
        }
        return EmptyOrNegativeNumberOfRulesError;
    }(Error));

    /**
     * Describes error when maximum number of rules is less than 0.
     */
    var NegativeNumberOfRegexpRulesError = /** @class */ (function (_super) {
        __extends(NegativeNumberOfRegexpRulesError, _super);
        /**
         * Describes error when maximum number of rules is less than 0.
         *
         * @param message Message of error.
         */
        function NegativeNumberOfRegexpRulesError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'NegativeNumberOfRegexpRulesError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, NegativeNumberOfRegexpRulesError.prototype);
            return _this;
        }
        return NegativeNumberOfRegexpRulesError;
    }(Error));

    /**
     * Describes error when the resources path does not start with a slash
     * or it ends with a slash.
     */
    var ResourcesPathError = /** @class */ (function (_super) {
        __extends(ResourcesPathError, _super);
        /**
         * Describes error when the resources path does not start with a slash
         * or it ends with a slash.
         *
         * @param message Message of error.
         */
        function ResourcesPathError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'ResourcesPathError';
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, ResourcesPathError.prototype);
            return _this;
        }
        return ResourcesPathError;
    }(Error));

    /**
     * @file Describes how to convert one {@link NetworkRule} into one or many
     * {@link DeclarativeRule|declarative rules} .
     */
    var _a$1;
    /**
     * Map request types to declarative types.
     */
    var DECLARATIVE_RESOURCE_TYPES_MAP = (_a$1 = {},
        _a$1[exports.ResourceType.MainFrame] = exports.RequestType.Document,
        _a$1[exports.ResourceType.SubFrame] = exports.RequestType.SubDocument,
        _a$1[exports.ResourceType.Stylesheet] = exports.RequestType.Stylesheet,
        _a$1[exports.ResourceType.Script] = exports.RequestType.Script,
        _a$1[exports.ResourceType.Image] = exports.RequestType.Image,
        _a$1[exports.ResourceType.Font] = exports.RequestType.Font,
        _a$1[exports.ResourceType.Object] = exports.RequestType.Object,
        _a$1[exports.ResourceType.XmlHttpRequest] = exports.RequestType.XmlHttpRequest,
        _a$1[exports.ResourceType.Ping] = exports.RequestType.Ping,
        // TODO: what should match this resource type?
        // [ResourceType.CSP_REPORT]: RequestType.Document,
        _a$1[exports.ResourceType.Media] = exports.RequestType.Media,
        _a$1[exports.ResourceType.WebSocket] = exports.RequestType.WebSocket,
        _a$1[exports.ResourceType.Other] = exports.RequestType.Other,
        _a$1);
    /**
     * Rule priority. Defaults to 1. When specified, should be >= 1. The higher the
     * number, the higher the priority.
     */
    var DeclarativeRulePriority;
    (function (DeclarativeRulePriority) {
        DeclarativeRulePriority[DeclarativeRulePriority["DocumentException"] = 4] = "DocumentException";
        DeclarativeRulePriority[DeclarativeRulePriority["ImportantException"] = 3] = "ImportantException";
        DeclarativeRulePriority[DeclarativeRulePriority["Important"] = 2] = "Important";
        DeclarativeRulePriority[DeclarativeRulePriority["Exception"] = 1] = "Exception";
    })(DeclarativeRulePriority || (DeclarativeRulePriority = {}));
    /**
     * Abstract rule converter class.
     * Contains the generic logic for converting a {@link NetworkRule}
     * into a {@link DeclarativeRule}.
     */
    var DeclarativeRuleConverter = /** @class */ (function () {
        /**
         * Creates an instance of DeclarativeRuleConverter.
         *
         * @param webAccessibleResourcesPath Path to web accessible resources.
         */
        function DeclarativeRuleConverter(webAccessibleResourcesPath) {
            this.webAccessibleResourcesPath = webAccessibleResourcesPath;
        }
        /**
         * Gets resource type matching request type.
         *
         * @param requestTypes Request type.
         *
         * @returns List of resource types.
         */
        DeclarativeRuleConverter.getResourceTypes = function (requestTypes) {
            return Object.entries(DECLARATIVE_RESOURCE_TYPES_MAP)
                // Skips the first element
                .filter(function (_a) {
                var requestType = _a[1];
                return (requestTypes & requestType) === requestType;
            })
                .map(function (_a) {
                var resourceTypeKey = _a[0];
                return resourceTypeKey;
            });
        };
        /**
         * Checks if the string contains only ASCII characters.
         *
         * @param str String to test.
         *
         * @returns True if string contains only ASCII characters.
         */
        DeclarativeRuleConverter.isASCII = function (str) {
            // eslint-disable-next-line no-control-regex
            return /^[\x00-\x7F]+$/.test(str);
        };
        /**
         * Converts to punycode if string contains non ASCII characters.
         *
         * @param str String to convert.
         *
         * @returns A transformed string containing only ASCII characters or
         * the original string.
         */
        DeclarativeRuleConverter.prepareASCII = function (str) {
            return DeclarativeRuleConverter.isASCII(str)
                ? str
                : punycode.toASCII(str);
        };
        /**
         * Converts a list of strings into strings containing only ASCII characters.
         *
         * @param strings List of strings.
         *
         * @returns List of string containing only ASCII characters.
         */
        DeclarativeRuleConverter.toASCII = function (strings) {
            return strings.map(function (s) {
                return DeclarativeRuleConverter.prepareASCII(s);
            });
        };
        /**
         * Rule priority. Defaults to 1. When specified, should be >= 1.
         *
         * Document exceptions > allowlist + $important > $important >
         * allowlist > basic rules.
         *
         * @param rule Network rule.
         *
         * @returns Priority of the rule or null.
         */
        DeclarativeRuleConverter.getPriority = function (rule) {
            if (rule.isDocumentAllowlistRule()) {
                return DeclarativeRulePriority.DocumentException;
            }
            var isImportant = rule.isOptionEnabled(exports.NetworkRuleOption.Important);
            var isAllowlist = rule.isAllowlist();
            if (isImportant) {
                return isAllowlist
                    ? DeclarativeRulePriority.ImportantException
                    : DeclarativeRulePriority.Important;
            }
            if (isAllowlist) {
                return DeclarativeRulePriority.Exception;
            }
            return null;
        };
        /**
         * Rule redirect action.
         *
         * @param rule Network rule.
         *
         * @throws Error {@link ResourcesPathError} when a network rule has
         * a $redirect modifier and no path to web-accessible resources
         * is specified.
         *
         * @returns Redirect, which describes where and how the request
         * should be redirected.
         */
        DeclarativeRuleConverter.prototype.getRedirectAction = function (rule) {
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Redirect)) {
                var resourcesPath = this.webAccessibleResourcesPath;
                if (!resourcesPath) {
                    var ruleText = rule.getText();
                    var msg = "Empty web accessible resources path: ".concat(ruleText);
                    throw new ResourcesPathError(msg);
                }
                var advancedModifier = rule.getAdvancedModifier();
                var redirectTo = advancedModifier;
                var filename = scriptlets_umd.exports.redirects.getRedirectFilename(redirectTo.getValue());
                return { extensionPath: "".concat(resourcesPath, "/").concat(filename) };
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                var advancedModifier = rule.getAdvancedModifier();
                var removeParamModifier = advancedModifier;
                var value = removeParamModifier.getValue();
                if (value === '') {
                    return { transform: { query: '' } };
                }
                return {
                    transform: {
                        queryTransform: {
                            removeParams: DeclarativeRuleConverter.toASCII([value]),
                        },
                    },
                };
            }
            return {};
        };
        /**
         * Rule action.
         *
         * @param rule Network rule.
         *
         * @throws Error {@link ResourcesPathError} when specified an empty
         * path to the web accessible resources.
         *
         * @returns The action of a rule that describes what should be done
         * with the request.
         */
        DeclarativeRuleConverter.prototype.getAction = function (rule) {
            // TODO: RuleActionType
            //  - 'upgradeScheme' = 'upgradeScheme',
            //  - 'modifyHeaders' = 'modifyHeaders',
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Redirect)
                || rule.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                return {
                    type: exports.RuleActionType.REDIRECT,
                    redirect: this.getRedirectAction(rule),
                };
            }
            if (rule.isAllowlist()) {
                if (rule.isDocumentLevelAllowlistRule() || rule.isDocumentAllowlistRule()) {
                    return { type: exports.RuleActionType.ALLOW_ALL_REQUESTS };
                }
                return { type: exports.RuleActionType.ALLOW };
            }
            return { type: exports.RuleActionType.BLOCK };
        };
        /**
         * Rule condition.
         *
         * @param rule Network rule.
         *
         * @returns A rule condition that describes to which request the declarative
         * rule should be applied.
         */
        DeclarativeRuleConverter.getCondition = function (rule) {
            var condition = {};
            var pattern = rule.getPattern();
            if (pattern) {
                // set regexFilter
                if (rule.isRegexRule()) {
                    condition.regexFilter = DeclarativeRuleConverter.prepareASCII(pattern);
                }
                else {
                    // A pattern beginning with ||* is not allowed. Use * instead.
                    var patternWithoutVerticals = pattern.startsWith('||*')
                        ? pattern.substring(2)
                        : pattern;
                    condition.urlFilter = DeclarativeRuleConverter.prepareASCII(patternWithoutVerticals);
                }
            }
            // set domainType
            if (rule.isOptionEnabled(exports.NetworkRuleOption.ThirdParty)) {
                condition.domainType = exports.DomainType.ThirdParty;
            }
            else if (rule.isOptionDisabled(exports.NetworkRuleOption.ThirdParty)) {
                condition.domainType = exports.DomainType.FirstParty;
            }
            // set initiatorDomains
            var permittedDomains = rule.getPermittedDomains();
            if (permittedDomains && permittedDomains.length > 0) {
                condition.initiatorDomains = this.toASCII(permittedDomains);
            }
            // set excludedInitiatorDomains
            var excludedDomains = rule.getRestrictedDomains();
            if (excludedDomains && excludedDomains.length > 0) {
                condition.excludedInitiatorDomains = this.toASCII(excludedDomains);
            }
            // set excludedRequestDomains
            var denyAllowDomains = rule.getDenyAllowDomains();
            if (denyAllowDomains && denyAllowDomains.length > 0) {
                condition.excludedRequestDomains = this.toASCII(denyAllowDomains);
            }
            // set excludedResourceTypes
            var restrictedRequestTypes = rule.getRestrictedRequestTypes();
            var hasExcludedResourceTypes = restrictedRequestTypes !== 0;
            if (hasExcludedResourceTypes) {
                condition.excludedResourceTypes = this.getResourceTypes(restrictedRequestTypes);
            }
            // set resourceTypes
            var permittedRequestTypes = rule.getPermittedRequestTypes();
            if (!hasExcludedResourceTypes && permittedRequestTypes !== 0) {
                condition.resourceTypes = this.getResourceTypes(permittedRequestTypes);
            }
            // set isUrlFilterCaseSensitive
            condition.isUrlFilterCaseSensitive = rule.isOptionEnabled(exports.NetworkRuleOption.MatchCase);
            return condition;
        };
        /**
         * Converts the network rule into an array of declarative rules.
         *
         * Method to use only in class heirs.
         *
         * @protected
         *
         * @param rule Network rule.
         * @param id Rule identifier.
         *
         * @throws An {@link UnsupportedModifierError} if the network rule
         * contains an unsupported modifier
         * OR a {@link TooComplexRegexpError} if regexp is too complex
         * OR an {@link EmptyResourcesError} if there is empty resources in the rule
         * OR an {@link UnsupportedRegexpError} if regexp is not supported in
         * the RE2 syntax.
         * OR a {@link ResourcesPathError} when specified an empty
         * path to the web accessible resources.
         *
         * @returns A list of declarative rules.
         */
        DeclarativeRuleConverter.prototype.convertRule = function (rule, id) {
            var unsupportedErr = DeclarativeRuleConverter.checkNetworkRuleApplicable(rule);
            if (unsupportedErr) {
                throw unsupportedErr;
            }
            var declarativeRule = {
                id: id,
                action: this.getAction(rule),
                condition: DeclarativeRuleConverter.getCondition(rule),
            };
            var priority = DeclarativeRuleConverter.getPriority(rule);
            if (priority) {
                declarativeRule.priority = priority;
            }
            var conversionErr = DeclarativeRuleConverter.checkDeclarativeRuleApplicable(rule, declarativeRule);
            if (conversionErr) {
                throw conversionErr;
            }
            return [declarativeRule];
        };
        /**
         * Checks if a network rule can be converted to a declarative format or not.
         * We skip the following modifiers:
         * $removeparam - if it contains a negation, or regexp,
         * or the rule is a allowlist;
         * $elemhide;
         * $jsinject;
         * $cookie;
         * $csp;
         * $replace;
         * $generichide;
         * $stealth;
         * $mp4.
         *
         * @param rule - Network rule.
         *
         * @returns UnsupportedModifierError if not applicable OR null.
         */
        DeclarativeRuleConverter.checkNetworkRuleApplicable = function (rule) {
            var checkRemoveParamModifierFn = function (r) {
                // TODO: Check Rule.requestDomains, maybe we can use them for
                // generate allowrule for $removeparam
                if (r.isAllowlist()) {
                    var msg = 'Network allowlist rule with $removeparam modifier '
                        + "is not supported: \"".concat(rule.getText(), "\"");
                    return new UnsupportedModifierError(msg, r);
                }
                var removeParam = r.getAdvancedModifier();
                if (!removeParam.getMV3Validity()) {
                    var msg = 'Network rule with $removeparam modifier with '
                        + "negation or regexp is not supported: \"".concat(r.getText(), "\"");
                    return new UnsupportedModifierError(msg, r);
                }
                return null;
            };
            var unsupportedOptions = [
                {
                    option: exports.NetworkRuleOption.RemoveParam,
                    name: '$removeparam',
                    customCheck: checkRemoveParamModifierFn,
                },
                { option: exports.NetworkRuleOption.Elemhide, name: '$elemhide' },
                { option: exports.NetworkRuleOption.Jsinject, name: '$jsinject' },
                { option: exports.NetworkRuleOption.Cookie, name: '$cookie' },
                { option: exports.NetworkRuleOption.Csp, name: '$csp' },
                { option: exports.NetworkRuleOption.Replace, name: '$replace' },
                { option: exports.NetworkRuleOption.Generichide, name: '$generichide' },
                { option: exports.NetworkRuleOption.Stealth, name: '$stealth' },
                { option: exports.NetworkRuleOption.Mp4, name: '$mp4' },
            ];
            for (var i = 0; i < unsupportedOptions.length; i += 1) {
                var _a = unsupportedOptions[i], option = _a.option, name_1 = _a.name, customCheck = _a.customCheck;
                if (!rule.isSingleOptionEnabled(option)) {
                    continue;
                }
                if (customCheck) {
                    var err = customCheck(rule);
                    if (!err) {
                        continue;
                    }
                    return err;
                }
                var msg = "Unsupported option \"".concat(name_1, "\" found in the rule: \"").concat(rule.getText(), "\"");
                return new UnsupportedModifierError(msg, rule);
            }
            return null;
        };
        /**
         * Checks if the converted declarative rule passes the regexp validation
         * (too complex regexps are not allowed also back reference,
         * possessive and negative lookahead are not supported)
         * and if it contains resource types.
         *
         * @param networkRule Network rule.
         * @param declarativeRule Declarative rule.
         *
         * @returns Error {@link TooComplexRegexpError} if regexp is too complex
         * OR Error {@link EmptyResourcesError} if there is empty resources
         * in the rule
         * OR Error {@link UnsupportedRegexpError} if regexp is not supported
         * in the RE2 syntax @see https://github.com/google/re2/wiki/Syntax
         * OR null.
         */
        DeclarativeRuleConverter.checkDeclarativeRuleApplicable = function (networkRule, declarativeRule) {
            var _a = declarativeRule.condition, regexFilter = _a.regexFilter, resourceTypes = _a.resourceTypes;
            if ((resourceTypes === null || resourceTypes === void 0 ? void 0 : resourceTypes.length) === 0) {
                var ruleText = networkRule.getText();
                var msg = "Conversion resourceTypes is empty: \"".concat(ruleText, "\"");
                return new EmptyResourcesError(msg, networkRule, declarativeRule);
            }
            // More complex regex than allowed as part of the "regexFilter" key.
            if (regexFilter === null || regexFilter === void 0 ? void 0 : regexFilter.match(/\|/g)) {
                var regexArr = regexFilter.split('|');
                // TODO: Find how exactly the complexity of a rule is calculated.
                // The values maxGroups & maxGroupLength are obtained by testing.
                var maxGroups = 15;
                var maxGroupLength_1 = 31;
                if (regexArr.length > maxGroups
                    || regexArr.some(function (i) { return i.length > maxGroupLength_1; })) {
                    var ruleText = networkRule.getText();
                    var msg = "More complex regex than allowed: \"".concat(ruleText, "\"");
                    return new TooComplexRegexpError(msg, networkRule, declarativeRule);
                }
            }
            // Back reference, possessive and negative lookahead are not supported
            // See more: https://github.com/google/re2/wiki/Syntax
            if (regexFilter === null || regexFilter === void 0 ? void 0 : regexFilter.match(/\\[1-9]|(?<!\\)\?|{\S+}/g)) {
                var msg = "Invalid regex in the: \"".concat(networkRule.getText(), "\"");
                return new UnsupportedRegexpError(msg, networkRule, declarativeRule);
            }
            return null;
        };
        return DeclarativeRuleConverter;
    }());

    /**
     * Describes how to convert all rules that are not grouped
     * for separate conversion.
     *
     * @see {@link RulesGroup}
     */
    var RegularRulesConverter = /** @class */ (function (_super) {
        __extends(RegularRulesConverter, _super);
        function RegularRulesConverter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Converts ungrouped, basic indexed rules into declarative rules.
         *
         * @param filterId Filter id.
         * @param rules List of indexed rules.
         * @param offsetId Offset for the IDs of the converted rules.
         *
         * @returns Converted rules.
         */
        RegularRulesConverter.prototype.convertRules = function (filterId, rules, offsetId) {
            var _this = this;
            var sourceMapValues = [];
            var declarativeRules = [];
            var errors = [];
            var regexpRulesCount = 0;
            rules.forEach(function (_a) {
                var rule = _a.rule, index = _a.index;
                var id = offsetId + index;
                var converted = [];
                try {
                    converted = _this.convertRule(rule, id);
                }
                catch (e) {
                    if (e instanceof EmptyResourcesError
                        || e instanceof TooComplexRegexpError
                        || e instanceof UnsupportedModifierError
                        || e instanceof UnsupportedRegexpError) {
                        errors.push(e);
                        return;
                    }
                    var msg = 'Non-categorized error during a conversion rule: '
                        + "".concat(rule.getText(), " (index - ").concat(index, ", id - ").concat(id, ")");
                    errors.push(new Error(msg, { cause: e }));
                    return;
                }
                converted.forEach(function (dRule) {
                    declarativeRules.push(dRule);
                    sourceMapValues.push({
                        declarativeRuleId: dRule.id,
                        sourceRuleIndex: index,
                        filterId: filterId,
                    });
                    if (dRule.condition.regexFilter) {
                        regexpRulesCount += 1;
                    }
                });
            });
            return {
                sourceMapValues: sourceMapValues,
                declarativeRules: declarativeRules,
                regexpRulesCount: regexpRulesCount,
                errors: errors,
            };
        };
        return RegularRulesConverter;
    }(DeclarativeRuleConverter));

    /**
     * Describes how to convert $removeparam rules.
     */
    var RemoveParamRulesConverter = /** @class */ (function (_super) {
        __extends(RemoveParamRulesConverter, _super);
        function RemoveParamRulesConverter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Converts indexed rules grouped by $removeparam into declarative rules:
         * for each rule looks for similar rules and groups them into a new rule.
         *
         * @param filterId Filter id.
         * @param rules List of indexed rules.
         * @param offsetId Offset for the IDs of the converted rules.
         *
         * @returns Converted rules.
         */
        // eslint-disable-next-line class-methods-use-this
        RemoveParamRulesConverter.prototype.convertRules = function (filterId, rules, offsetId) {
            var _this = this;
            var sourceMapValues = [];
            var rulesTemplates = new Map();
            var errors = [];
            var regexpRulesCount = 0;
            var getRuleTemplate = function (rule) {
                var _a, _b, _c;
                // Deep copy without relation to source rule
                var template = JSON.parse(JSON.stringify(rule));
                template.id = 0;
                (_c = (_b = (_a = template.action.redirect) === null || _a === void 0 ? void 0 : _a.transform) === null || _b === void 0 ? void 0 : _b.queryTransform) === null || _c === void 0 ? true : delete _c.removeParams;
                return JSON.stringify(template);
            };
            var findRulePairId = function (rule) {
                var _a, _b, _c, _d, _e, _f, _g;
                var template = getRuleTemplate(rule);
                var ruleToJoin = rulesTemplates.get(template);
                if (!ruleToJoin) {
                    return null;
                }
                // If found rule-sibling to join
                var params = ((_c = (_b = (_a = rule.action.redirect) === null || _a === void 0 ? void 0 : _a.transform) === null || _b === void 0 ? void 0 : _b.queryTransform) === null || _c === void 0 ? void 0 : _c.removeParams) || [];
                // Then combine remove params
                (_g = (_f = (_e = (_d = ruleToJoin.action.redirect) === null || _d === void 0 ? void 0 : _d.transform) === null || _e === void 0 ? void 0 : _e.queryTransform) === null || _f === void 0 ? void 0 : _f.removeParams) === null || _g === void 0 ? void 0 : _g.push.apply(_g, params);
                return ruleToJoin.id;
            };
            rules.forEach(function (_a) {
                var rule = _a.rule, index = _a.index;
                var id = offsetId + index;
                var converted = [];
                try {
                    converted = _this.convertRule(rule, id);
                }
                catch (e) {
                    if (e instanceof EmptyResourcesError
                        || e instanceof TooComplexRegexpError
                        || e instanceof UnsupportedModifierError
                        || e instanceof UnsupportedRegexpError) {
                        errors.push(e);
                        return;
                    }
                    var msg = 'Non-categorized error during a conversion rule: '
                        + "".concat(rule.getText(), " (index - ").concat(index, ", id - ").concat(id, ")");
                    errors.push(new Error(msg, { cause: e }));
                    return;
                }
                converted.forEach(function (dRule) {
                    var dRuleSiblingId = findRulePairId(dRule);
                    if (dRuleSiblingId === null) {
                        var template = getRuleTemplate(dRule);
                        rulesTemplates.set(template, dRule);
                    }
                    sourceMapValues.push({
                        declarativeRuleId: dRuleSiblingId !== null
                            ? dRuleSiblingId
                            : dRule.id,
                        sourceRuleIndex: index,
                        filterId: filterId,
                    });
                    if (dRule.condition.regexFilter && dRuleSiblingId !== null) {
                        regexpRulesCount += 1;
                    }
                });
            });
            return {
                sourceMapValues: sourceMapValues,
                declarativeRules: Array.from(rulesTemplates.values()),
                regexpRulesCount: regexpRulesCount,
                errors: errors,
            };
        };
        return RemoveParamRulesConverter;
    }(DeclarativeRuleConverter));

    /**
     * Describes an error when the maximum number of regexp rules is reached.
     */
    var TooManyRegexpRulesError = /** @class */ (function (_super) {
        __extends(TooManyRegexpRulesError, _super);
        /**
         * Describes an error when the maximum number of regexp rules is reached.
         *
         * @param message Message of error.
         * @param excludedRulesIds List of excluded source (important!)
         * {@link Source} rules ids.
         * @param numberOfMaximumRules Number of maximum rules.
         * @param numberOfExcludedDeclarativeRules Number of excluded declarative
         * rules.
         */
        function TooManyRegexpRulesError(message, excludedRulesIds, numberOfMaximumRules, numberOfExcludedDeclarativeRules) {
            var _this = _super.call(this, message) || this;
            _this.name = 'TooManyRegexpRulesError';
            _this.excludedRulesIds = excludedRulesIds;
            _this.numberOfMaximumRules = numberOfMaximumRules;
            _this.numberOfExcludedDeclarativeRules = numberOfExcludedDeclarativeRules;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, TooManyRegexpRulesError.prototype);
            return _this;
        }
        return TooManyRegexpRulesError;
    }(Error));

    /**
     * Describes an error when the maximum number of rules is reached.
     */
    var TooManyRulesError = /** @class */ (function (_super) {
        __extends(TooManyRulesError, _super);
        /**
         * Describes an error when the maximum number of rules is reached.
         *
         * @param message Message of error.
         * @param excludedRulesIds List of excluded source (important!)
         * {@link Source} rules ids.
         * @param numberOfMaximumRules Number of maximum rules.
         * @param numberOfExcludedDeclarativeRules Number of excluded declarative
         * rules.
         */
        function TooManyRulesError(message, excludedRulesIds, numberOfMaximumRules, numberOfExcludedDeclarativeRules) {
            var _this = _super.call(this, message) || this;
            _this.name = 'TooManyRulesError';
            _this.excludedRulesIds = excludedRulesIds;
            _this.numberOfMaximumRules = numberOfMaximumRules;
            _this.numberOfExcludedDeclarativeRules = numberOfExcludedDeclarativeRules;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, TooManyRulesError.prototype);
            return _this;
        }
        return TooManyRulesError;
    }(Error));

    /**
     * Just a dummy for $badfilter-rules, because they don't need to be converted.
     */
    var BadFilterRulesConverter = /** @class */ (function (_super) {
        __extends(BadFilterRulesConverter, _super);
        function BadFilterRulesConverter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Skips converting bad rules.
         *
         * @param filterId Filter id.
         * @param rules List of indexed rules.
         * @param offsetId Offset for the IDs of the converted rules.
         *
         * @returns Empty converted rules.
         */
        // eslint-disable-next-line class-methods-use-this
        BadFilterRulesConverter.prototype.convertRules = function (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        filterId, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        rules, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        offsetId) {
            return {
                sourceMapValues: [],
                declarativeRules: [],
                regexpRulesCount: 0,
                errors: [],
            };
        };
        return BadFilterRulesConverter;
    }(DeclarativeRuleConverter));

    var RulesGroup;
    (function (RulesGroup) {
        RulesGroup[RulesGroup["Regular"] = 0] = "Regular";
        RulesGroup[RulesGroup["RemoveParam"] = 1] = "RemoveParam";
        RulesGroup[RulesGroup["BadFilter"] = 2] = "BadFilter";
    })(RulesGroup || (RulesGroup = {}));
    /**
     * Contains logic on how to divide the rules into certain groups.
     *
     * @see {@link RulesGroup}
     */
    var DeclarativeRulesGrouper = /** @class */ (function () {
        function DeclarativeRulesGrouper() {
        }
        /**
         * Returns group of the indexed rule.
         *
         * @param indexedRule Indexed rule.
         *
         * @returns Group of the indexed rule.
         */
        DeclarativeRulesGrouper.getRuleGroup = function (indexedRule) {
            var rule = indexedRule.rule;
            if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                return RulesGroup.RemoveParam;
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                return RulesGroup.BadFilter;
            }
            return RulesGroup.Regular;
        };
        /**
         * Splits the list of indexed rules into an index with groups.
         *
         * @param rules List of indexed rules.
         *
         * @returns Index with grouped, indexed rules.
         */
        DeclarativeRulesGrouper.splitRulesByGroups = function (rules) {
            var _a;
            var rulesToProcess = (_a = {},
                _a[RulesGroup.RemoveParam] = [],
                _a[RulesGroup.BadFilter] = [],
                _a[RulesGroup.Regular] = [],
                _a);
            // Categorizing rule groups
            rules.forEach(function (indexedRule) {
                var group = DeclarativeRulesGrouper.getRuleGroup(indexedRule);
                rulesToProcess[group].push(indexedRule);
            });
            return rulesToProcess;
        };
        return DeclarativeRulesGrouper;
    }());

    /**
     * @file Describes the conversion process from {@link IndexedRule} to
     * declarative rules {@link DeclarativeRule} via applying $badfilter-rules
     * {@link DeclarativeRulesConverter#applyBadFilter} and checks for specified
     * limitations {@link DeclarativeRulesConverter#checkLimitations}.
     */
    var _a;
    /**
     * Describes how to convert {@link IndexedRule|indexed rules} into list of
     * {@link DeclarativeRule|declarative rules}.
     */
    var DeclarativeRulesConverter = /** @class */ (function () {
        function DeclarativeRulesConverter() {
        }
        /**
         * Converts list of filters ids with indexed rules to declarative rules:
         * applies $badfilter rules, then for each group of rules (inside one
         * filter) runs specified converter.
         *
         * TODO: The $removeParam converter can also combine rules across
         * multiple filters.
         *
         * @see {@link DeclarativeRulesConverter.converters}.
         *
         * @param filtersWithRules List of filters ids with indexed rules.
         * @param options Options for conversion.
         *
         * @returns A list of declarative rules, a regexp rule counter,
         * and a list of sourcemap values that contain the relationship between the
         * transformed declarative rule and the source rule.
         */
        DeclarativeRulesConverter.convert = function (filtersWithRules, options) {
            var _this = this;
            var filters = this.applyBadFilter(filtersWithRules);
            var converted = {
                sourceMapValues: [],
                declarativeRules: [],
                regexpRulesCount: 0,
                errors: [],
            };
            filters.forEach(function (_a) {
                var filterId = _a[0], groupedRules = _a[1];
                var lastUsedId = converted.declarativeRules.length > 0
                    ? converted.declarativeRules[converted.declarativeRules.length - 1].id + 1
                    : DeclarativeRulesConverter.START_DECLARATIVE_RULE_ID;
                var _b = _this.convertRules(filterId, groupedRules, lastUsedId, options), sourceMapValues = _b.sourceMapValues, declarativeRules = _b.declarativeRules, regexpRulesCount = _b.regexpRulesCount, errors = _b.errors;
                converted.sourceMapValues = converted.sourceMapValues.concat(sourceMapValues);
                converted.declarativeRules = converted.declarativeRules.concat(declarativeRules);
                converted.regexpRulesCount += regexpRulesCount;
                converted.errors = converted.errors.concat(errors);
            });
            converted = this.checkLimitations(converted, options === null || options === void 0 ? void 0 : options.maxNumberOfRules, options === null || options === void 0 ? void 0 : options.maxNumberOfRegexpRules);
            return converted;
        };
        /**
         * Converts filter's indexed rules into declarative rules.
         *
         * @param filterId Filed id.
         * @param groupsRules Grouped rules.
         * @param lastUsedId To avoid intersections between the identifiers of
         * the converted rules, we start converting new group rules with an offset.
         * @param options Options for conversion.
         *
         * @returns A list of declarative rules, a regexp rule counter,
         * and a list of sourcemap values that contain the relationship between the
         * transformed declarative rule and the source rule.
         */
        DeclarativeRulesConverter.convertRules = function (filterId, groupsRules, lastUsedId, options) {
            var converted = {
                sourceMapValues: [],
                declarativeRules: [],
                regexpRulesCount: 0,
                errors: [],
            };
            // Map because RulesGroup values are numbers
            var groups = Object.keys(groupsRules).map(Number);
            groups.forEach(function (key) {
                var converter = new DeclarativeRulesConverter.converters[key](options === null || options === void 0 ? void 0 : options.resourcesPath);
                var _a = converter.convertRules(filterId, groupsRules[key], lastUsedId), sourceMapValues = _a.sourceMapValues, declarativeRules = _a.declarativeRules, regexpRulesCount = _a.regexpRulesCount, errors = _a.errors;
                converted.sourceMapValues = converted.sourceMapValues.concat(sourceMapValues);
                converted.declarativeRules = converted.declarativeRules.concat(declarativeRules);
                converted.regexpRulesCount += regexpRulesCount;
                converted.errors = converted.errors.concat(errors);
            });
            return converted;
        };
        /**
         * Check that declarative rules matches the specified constraints and
         * cuts rules if needed as from list also from source map.
         *
         * @param converted Converted rules, errors, sourcemap and counters.
         * @param maxNumberOfRules Maximum number of converted rules.
         * @param maxNumberOfRegexpRules Maximum number of converted regexp rules.
         *
         * @returns Transformed converted rules with modified (if abbreviated)
         * counters, declarative rules list, source map and errors.
         */
        DeclarativeRulesConverter.checkLimitations = function (converted, maxNumberOfRules, maxNumberOfRegexpRules) {
            var limitations = [];
            // We apply restrictions only to transformed rules, so we need to filter
            // rule conversion errors if we remove the transformed rule associated
            // with those errors
            var declarativeRules = converted.declarativeRules, sourceMapValues = converted.sourceMapValues, regexpRulesCount = converted.regexpRulesCount, errors = converted.errors;
            var convertedRulesErrors = [];
            for (var i = 0; i < errors.length; i += 1) {
                var e = errors[i];
                // Checks only errors of converted declarative rules
                if (e instanceof InvalidDeclarativeRuleError) {
                    convertedRulesErrors.push(e);
                }
            }
            // TODO: Lazy creation of index
            // Create index of errors for fast search and filtering
            var convertedRulesErrorsIndex = new Map();
            convertedRulesErrors.forEach(function (e) {
                // Checks only errors of converted declarative rules
                if (e instanceof EmptyResourcesError
                    || e instanceof TooComplexRegexpError
                    || e instanceof UnsupportedRegexpError) {
                    var errorsList = convertedRulesErrorsIndex.get(e.declarativeRule.id);
                    var newValue = errorsList
                        ? errorsList.concat(e)
                        : [e];
                    convertedRulesErrorsIndex.set(e.declarativeRule.id, newValue);
                }
            });
            // TODO: Lazy creation of index
            // Create index of sources for fast search and filtering
            var sourcesIndex = new Map();
            sourceMapValues.forEach(function (source) {
                var sources = sourcesIndex.get(source.declarativeRuleId);
                var newValue = sources
                    ? sources.concat(source)
                    : [source];
                sourcesIndex.set(source.declarativeRuleId, newValue);
            });
            // Checks and, if necessary, trims the maximum number of rules
            if (maxNumberOfRules && declarativeRules.length > maxNumberOfRules) {
                var filteredRules = [];
                var excludedRulesIds = [];
                for (var i = 0; i < declarativeRules.length; i += 1) {
                    var rule = declarativeRules[i];
                    if (i < maxNumberOfRules) {
                        filteredRules.push(rule);
                        continue;
                    }
                    // Removing an source for a truncated rule
                    var sources = sourcesIndex.get(rule.id) || [];
                    var sourcesRulesIds = sources.map(function (_a) {
                        var sourceRuleIndex = _a.sourceRuleIndex;
                        return sourceRuleIndex;
                    });
                    sourcesIndex.set(rule.id, []);
                    // Removing an error for a truncated rule
                    convertedRulesErrorsIndex.set(rule.id, []);
                    excludedRulesIds = excludedRulesIds.concat(sourcesRulesIds);
                }
                var msg = 'After conversion, too many declarative rules remain: '
                    + "".concat(declarativeRules.length, " exceeds ")
                    + "the limit provided - ".concat(maxNumberOfRules);
                var err = new TooManyRulesError(msg, excludedRulesIds, maxNumberOfRules, declarativeRules.length - maxNumberOfRules);
                limitations.push(err);
                declarativeRules = filteredRules;
            }
            // Checks and, if necessary, trims the maximum number of regexp rules
            if (maxNumberOfRegexpRules) {
                var filteredRules = [];
                var excludedRulesIds = [];
                var regexpRulesCounter = 0;
                for (var i = 0; i < declarativeRules.length; i += 1) {
                    var rule = declarativeRules[i];
                    var isRegexp = rule.condition.regexFilter !== undefined;
                    if (isRegexp) {
                        regexpRulesCounter += 1;
                        if (regexpRulesCounter > maxNumberOfRegexpRules) {
                            // Removing an source for a truncated rule
                            var sources = sourcesIndex.get(rule.id) || [];
                            var sourcesRulesIds = sources.map(function (_a) {
                                var sourceRuleIndex = _a.sourceRuleIndex;
                                return sourceRuleIndex;
                            });
                            sourcesIndex.set(rule.id, []);
                            // Removing an error for a truncated rule
                            convertedRulesErrorsIndex.set(rule.id, []);
                            excludedRulesIds = excludedRulesIds.concat(sourcesRulesIds);
                            continue;
                        }
                    }
                    filteredRules.push(rule);
                }
                if (regexpRulesCounter > maxNumberOfRegexpRules) {
                    var msg = 'After conversion, too many regexp rules remain: '
                        + "".concat(regexpRulesCounter, " exceeds ")
                        + "the limit provided - ".concat(maxNumberOfRegexpRules);
                    var err = new TooManyRegexpRulesError(msg, excludedRulesIds, maxNumberOfRegexpRules, regexpRulesCounter - maxNumberOfRegexpRules);
                    limitations.push(err);
                }
                declarativeRules = filteredRules;
                regexpRulesCount = Math.min(maxNumberOfRegexpRules, regexpRulesCounter);
            }
            // Make array from index
            sourceMapValues = Array.from(sourcesIndex.values())
                .filter(function (arr) { return arr.length > 0; })
                .flat();
            // Make array from index
            errors = Array.from(convertedRulesErrorsIndex.values())
                .filter(function (arr) { return arr.length > 0; })
                .flat();
            return {
                sourceMapValues: sourceMapValues,
                declarativeRules: declarativeRules,
                regexpRulesCount: regexpRulesCount,
                errors: errors,
                limitations: limitations,
            };
        };
        /**
         * Filters rules that have been affected by $badfilter rules.
         *
         * @param filtersWithRules List with filters ids and indexed rules.
         *
         * @returns List with filters ids and grouped indexed rules.
         */
        DeclarativeRulesConverter.applyBadFilter = function (filtersWithRules) {
            var allBadFilterRules = [];
            // Group rules
            var filterIdsWithGroupedRules = filtersWithRules
                .map(function (_a) {
                var filterId = _a[0], indexedRules = _a[1];
                var rulesToProcess = DeclarativeRulesGrouper.splitRulesByGroups(indexedRules);
                allBadFilterRules = allBadFilterRules.concat(rulesToProcess[RulesGroup.BadFilter]);
                var tuple = [filterId, rulesToProcess];
                return tuple;
            });
            // Define filter function
            var filterByBadFilterFn = function (ruleToTest) {
                var networkRuleToTest = ruleToTest.rule;
                for (var _i = 0, allBadFilterRules_1 = allBadFilterRules; _i < allBadFilterRules_1.length; _i++) {
                    var rule = allBadFilterRules_1[_i].rule;
                    var badFilterRule = rule;
                    if (badFilterRule.negatesBadfilter(networkRuleToTest)) {
                        return false;
                    }
                }
                return true;
            };
            // For each group of filters' rules apply filter function
            return filterIdsWithGroupedRules.map(function (_a) {
                var filterId = _a[0], groupedRules = _a[1];
                var filtered = groupedRules;
                // Map because RulesGroup values are numbers
                var groups = Object.keys(filtered).map(Number);
                groups.forEach(function (key) {
                    filtered[key] = filtered[key].filter(filterByBadFilterFn);
                });
                // Clean up bad filters rules
                filtered[RulesGroup.BadFilter] = [];
                return [filterId, filtered];
            });
        };
        /**
         * The declarative identifier of a rule must be a natural number.
         */
        DeclarativeRulesConverter.START_DECLARATIVE_RULE_ID = 1;
        /**
         * Describes for which group of rules which converter should be used.
         */
        DeclarativeRulesConverter.converters = (_a = {},
            _a[RulesGroup.Regular] = RegularRulesConverter,
            _a[RulesGroup.RemoveParam] = RemoveParamRulesConverter,
            _a[RulesGroup.BadFilter] = BadFilterRulesConverter,
            _a);
        return DeclarativeRulesConverter;
    }());

    /**
     * @file Describes the conversion from a filter list {@link IFilter}
     * to rule sets {@link IRuleSet} with declarative rules {@link DeclarativeRule}.
     */
    /**
     * Converts a list of IFilters to a single rule set or to a list of rule sets.
     */
    var DeclarativeFilterConverter = /** @class */ (function () {
        function DeclarativeFilterConverter() {
        }
        /**
         * Asynchronous scans the list of filters for rules.
         *
         * @param filterList List of {@link IFilter}.
         *
         * @returns Map, where the key is the filter identifier and the value is the
         * indexed filter rules {@link IndexedRule}.
         */
        // eslint-disable-next-line class-methods-use-this
        DeclarativeFilterConverter.prototype.scanRules = function (filterList) {
            return __awaiter(this, void 0, void 0, function () {
                var promises;
                var _this = this;
                return __generator(this, function (_a) {
                    promises = filterList.map(function (filter) { return __awaiter(_this, void 0, void 0, function () {
                        var scanner, tuple;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, FilterScanner.createNew(filter)];
                                case 1:
                                    scanner = _a.sent();
                                    tuple = [filter.getId(), scanner.getIndexedRules()];
                                    return [2 /*return*/, tuple];
                            }
                        });
                    }); });
                    return [2 /*return*/, Promise.all(promises)];
                });
            });
        };
        /**
         * Checks that provided converter options are correct.
         *
         * @param options Contains path to web accessible resources,
         * maximum number of converter rules and regexp rules. @see
         * {@link DeclarativeConverterOptions} for details.
         *
         * @throws An {@link ResourcesPathError} if the resources path does not
         * start with a slash or it ends with a slash
         * OR an {@link EmptyOrNegativeNumberOfRulesError} if maximum number of
         * rules is equal or less than 0.
         * OR an {@link NegativeNumberOfRegexpRulesError} if maximum number of
         * regexp rules is less than 0.
         */
        DeclarativeFilterConverter.checkConverterOptions = function (options) {
            var resourcesPath = options.resourcesPath, maxNumberOfRules = options.maxNumberOfRules, maxNumberOfRegexpRules = options.maxNumberOfRegexpRules;
            if (resourcesPath !== undefined) {
                var firstChar = 0;
                var lastChar = resourcesPath.length > 0
                    ? resourcesPath.length - 1
                    : 0;
                if (resourcesPath[firstChar] !== '/') {
                    var msg = 'Path to web accessible resources should '
                        + "be started with leading slash: ".concat(resourcesPath);
                    throw new ResourcesPathError(msg);
                }
                if (resourcesPath[lastChar] === '/') {
                    var msg = 'Path to web accessible resources should '
                        + "not be ended with slash: ".concat(resourcesPath);
                    throw new ResourcesPathError(msg);
                }
            }
            if (maxNumberOfRules !== undefined && maxNumberOfRules <= 0) {
                var msg = 'Maximum number of rules cannot be equal or less than 0';
                throw new EmptyOrNegativeNumberOfRulesError(msg);
            }
            if (maxNumberOfRegexpRules && maxNumberOfRegexpRules < 0) {
                var msg = 'Maximum number of regexp rules cannot be less than 0';
                throw new NegativeNumberOfRegexpRulesError(msg);
            }
        };
        // eslint-disable-next-line jsdoc/require-param, jsdoc/require-description
        /**
         * @see {@link IFilterConverter#convert}
         */
        DeclarativeFilterConverter.prototype.convert = function (filterList, options) {
            return __awaiter(this, void 0, void 0, function () {
                var converted, filtersWithRules;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (options) {
                                DeclarativeFilterConverter.checkConverterOptions(options);
                            }
                            converted = {
                                ruleSets: [],
                                errors: [],
                                limitations: [],
                            };
                            return [4 /*yield*/, this.scanRules(filterList)];
                        case 1:
                            filtersWithRules = _a.sent();
                            filtersWithRules.forEach(function (filterIdWithRules) {
                                var filterId = filterIdWithRules[0];
                                var _a = DeclarativeRulesConverter.convert([filterIdWithRules], options), sourceMapValues = _a.sourceMapValues, declarativeRules = _a.declarativeRules, regexpRulesCount = _a.regexpRulesCount, errors = _a.errors, limitations = _a.limitations;
                                var ruleSetContent = {
                                    getSourceMap: function () {
                                        return Promise.resolve(new SourceMap(sourceMapValues));
                                    },
                                    getFilterList: function () {
                                        var filter = filterList.find(function (f) { return f.getId() === filterId; });
                                        return Promise.resolve(filter ? [filter] : []);
                                    },
                                    getDeclarativeRules: function () {
                                        return Promise.resolve(declarativeRules);
                                    },
                                };
                                var ruleSet = new RuleSet("ruleset_".concat(filterId), declarativeRules.length, regexpRulesCount, ruleSetContent);
                                converted.ruleSets.push(ruleSet);
                                converted.errors = converted.errors.concat(errors);
                                if (limitations) {
                                    converted.limitations = converted.limitations.concat(limitations);
                                }
                            });
                            return [2 /*return*/, converted];
                    }
                });
            });
        };
        // eslint-disable-next-line jsdoc/require-param, jsdoc/require-description
        /**
         * @see {@link IFilterConverter#convertToSingle}
         */
        DeclarativeFilterConverter.prototype.convertToSingle = function (filterList, options) {
            return __awaiter(this, void 0, void 0, function () {
                var filtersWithRules, combinedConvertedRules, sourceMapValues, declarativeRules, regexpRulesCount, errors, _a, limitations, ruleSetContent, ruleSet;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (options) {
                                DeclarativeFilterConverter.checkConverterOptions(options);
                            }
                            return [4 /*yield*/, this.scanRules(filterList)];
                        case 1:
                            filtersWithRules = _b.sent();
                            combinedConvertedRules = DeclarativeRulesConverter.convert(filtersWithRules, options);
                            sourceMapValues = combinedConvertedRules.sourceMapValues, declarativeRules = combinedConvertedRules.declarativeRules, regexpRulesCount = combinedConvertedRules.regexpRulesCount, errors = combinedConvertedRules.errors, _a = combinedConvertedRules.limitations, limitations = _a === void 0 ? [] : _a;
                            ruleSetContent = {
                                getSourceMap: function () {
                                    return Promise.resolve(new SourceMap(sourceMapValues));
                                },
                                getFilterList: function () {
                                    return Promise.resolve(filterList);
                                },
                                getDeclarativeRules: function () {
                                    return Promise.resolve(declarativeRules);
                                },
                            };
                            ruleSet = new RuleSet(DeclarativeFilterConverter.COMBINED_RULESET_ID, declarativeRules.length, regexpRulesCount, ruleSetContent);
                            return [2 /*return*/, {
                                    ruleSets: [ruleSet],
                                    errors: errors,
                                    limitations: limitations,
                                }];
                    }
                });
            });
        };
        /**
         * Same as chrome.declarativeNetRequest.DYNAMIC_RULESET_ID.
         */
        DeclarativeFilterConverter.COMBINED_RULESET_ID = '_dynamic';
        return DeclarativeFilterConverter;
    }());

    /**
     * Describes an error when filter source is not available.
     */
    var UnavailableFilterSourceError = /** @class */ (function (_super) {
        __extends(UnavailableFilterSourceError, _super);
        /**
         * Describes an error when filter source is not available.
         *
         * @param message Message of error.
         * @param filterId Filter id, the source of which is not available.
         * @param cause Basic error, describes why the source is unavailable.
         */
        function UnavailableFilterSourceError(message, filterId, cause) {
            var _this = _super.call(this, message, { cause: cause }) || this;
            _this.name = 'UnavailableFilterSourceError';
            _this.filterId = filterId;
            // For proper work of the "instanceof" operator
            Object.setPrototypeOf(_this, UnavailableFilterSourceError.prototype);
            return _this;
        }
        return UnavailableFilterSourceError;
    }(Error));

    /**
     * Saves the original rules and can return all original rules or just one,
     * with lazy content loading.
     */
    var Filter = /** @class */ (function () {
        /**
         * Creates new FilterList.
         *
         * @param id Number id of filter.
         * @param source Provider of filter content.
         */
        function Filter(id, source) {
            // Content of filter, lazy load
            this.content = [];
            this.id = id;
            this.source = source;
        }
        /**
         * Filter id.
         *
         * @returns Filter id.
         */
        Filter.prototype.getId = function () {
            return this.id;
        };
        /**
         * Loads content from provider to source.
         */
        Filter.prototype.loadContent = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this;
                            return [4 /*yield*/, this.source.getContent()];
                        case 1:
                            _a.content = _b.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Returns original filtering rule by provided id with lazy load.
         *
         * @param index Rule index.
         *
         * @throws Error {@link UnavailableFilterSourceError} if content is
         * not available.
         *
         * @returns Original filtering rule by provided identifier.
         */
        Filter.prototype.getRuleByIndex = function (index) {
            return __awaiter(this, void 0, void 0, function () {
                var e_1, msg;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.content.length === 0)) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.loadContent()];
                        case 2:
                            _a.sent();
                            if (this.content.length === 0) {
                                throw new Error('Loaded empty content');
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            msg = 'Filter content is unavailable';
                            throw new UnavailableFilterSourceError(msg, this.id, e_1);
                        case 4: return [2 /*return*/, this.content[index]];
                    }
                });
            });
        };
        /**
         * Returns the original filter rules with lazy loading.
         *
         * @throws UnavailableFilterSourceError if content is not available.
         *
         * @returns List of original filter rules.
         */
        Filter.prototype.getContent = function () {
            return __awaiter(this, void 0, void 0, function () {
                var e_2, msg;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.content.length === 0)) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.loadContent()];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_2 = _a.sent();
                            msg = 'Filter content is unavailable';
                            throw new UnavailableFilterSourceError(msg, this.id, e_2);
                        case 4: return [2 /*return*/, this.content];
                    }
                });
            });
        };
        return Filter;
    }());

    /**
     * @file This file describes the file names for the parts of the rule set that
     * will be saved to/loaded from disk.
     */
    var REGEXP_RULES_COUNT_FILENAME = 'regexp-rules-count';
    var RULES_COUNT_FILENAME = 'rules-count';
    var SOURCE_MAP_FILENAME_JSON = 'source-map.json';
    var FILTER_LIST_IDS_FILENAME_JSON = 'filter-list-ids.json';

    /**
     * Module, which can be used to validate filter rules in other libraries
     */
    var RuleValidator = /** @class */ (function () {
        function RuleValidator() {
        }
        /**
         * Creates validation result
         * @param valid
         * @param error
         * @private
         */
        RuleValidator.createValidationResult = function (valid, error) {
            if (error) {
                return { valid: valid, error: error };
            }
            return { valid: valid, error: null };
        };
        RuleValidator.validateRegexp = function (pattern, ruleText) {
            if (pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
                && pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)) {
                try {
                    new RegExp(pattern.slice(1, -1));
                }
                catch (e) {
                    throw new SyntaxError("Rule has invalid regex pattern: \"".concat(ruleText, "\""));
                }
            }
        };
        /**
         * Validates raw rule string
         * @param rawRule
         */
        RuleValidator.validate = function (rawRule) {
            var ruleText = rawRule.trim();
            if (!ruleText || RuleFactory.isComment(ruleText)) {
                return RuleValidator.createValidationResult(true);
            }
            if (RuleFactory.isShort(ruleText)) {
                return RuleValidator.createValidationResult(false, "Rule is too short: ".concat(ruleText));
            }
            try {
                // Validate cosmetic rules
                if (RuleFactory.isCosmetic(ruleText)) {
                    new CosmeticRule(ruleText, 0);
                    return RuleValidator.createValidationResult(true);
                }
                // Validate network rules
                var rule = new NetworkRule(ruleText, 0);
                RuleValidator.validateRegexp(rule.getPattern(), rule.getText());
            }
            catch (e) {
                var errorMessage = "Error: \"".concat(e.message, "\" in the rule: \"").concat(ruleText, "\"");
                return RuleValidator.createValidationResult(false, errorMessage);
            }
            return RuleValidator.createValidationResult(true);
            // TODO validate host rules
        };
        return RuleValidator;
    }());

    /**
     * Module with miscellaneous syntax utils exposed in API
     */
    var RuleSyntaxUtils = /** @class */ (function () {
        function RuleSyntaxUtils() {
        }
        /**
         * Checks if rule can be matched by domain
         * @param ruleText
         * @param domain
         */
        RuleSyntaxUtils.isRuleForDomain = function (ruleText, domain) {
            var rule = RuleFactory.createRule(ruleText, this.DUMMY_FILTER_ID);
            if (!rule) {
                return false;
            }
            return rule.matchesPermittedDomains(domain);
        };
        /**
         * Checks if rule can be matched by url
         * @param ruleText
         * @param url
         */
        RuleSyntaxUtils.isRuleForUrl = function (ruleText, url) {
            var domain = getHostname(url);
            if (!domain) {
                return false;
            }
            return this.isRuleForDomain(ruleText, domain);
        };
        RuleSyntaxUtils.DUMMY_FILTER_ID = 0;
        return RuleSyntaxUtils;
    }());

    exports.CookieModifier = CookieModifier;
    exports.CosmeticResult = CosmeticResult;
    exports.CosmeticRule = CosmeticRule;
    exports.CosmeticRuleParser = CosmeticRuleParser;
    exports.DeclarativeFilterConverter = DeclarativeFilterConverter;
    exports.DeclarativeRuleValidator = DeclarativeRuleValidator;
    exports.DnsEngine = DnsEngine;
    exports.DnsResult = DnsResult;
    exports.EXT_CSS_PSEUDO_INDICATORS = EXT_CSS_PSEUDO_INDICATORS;
    exports.EmptyOrNegativeNumberOfRulesError = EmptyOrNegativeNumberOfRulesError;
    exports.EmptyResourcesError = EmptyResourcesError;
    exports.Engine = Engine;
    exports.FILTER_LIST_IDS_FILENAME_JSON = FILTER_LIST_IDS_FILENAME_JSON;
    exports.Filter = Filter;
    exports.HostRule = HostRule;
    exports.IndexedRule = IndexedRule;
    exports.IndexedStorageRule = IndexedStorageRule;
    exports.InvalidDeclarativeRuleError = InvalidDeclarativeRuleError;
    exports.LIST_ID_MAX_VALUE = LIST_ID_MAX_VALUE;
    exports.MatchingResult = MatchingResult;
    exports.NegativeNumberOfRegexpRulesError = NegativeNumberOfRegexpRulesError;
    exports.NetworkRule = NetworkRule;
    exports.REGEXP_RULES_COUNT_FILENAME = REGEXP_RULES_COUNT_FILENAME;
    exports.RULES_COUNT_FILENAME = RULES_COUNT_FILENAME;
    exports.RemoveHeaderModifier = RemoveHeaderModifier;
    exports.RemoveParamModifier = RemoveParamModifier;
    exports.ReplaceModifier = ReplaceModifier;
    exports.Request = Request$1;
    exports.ResourcesPathError = ResourcesPathError;
    exports.RuleConverter = RuleConverter;
    exports.RuleFactory = RuleFactory;
    exports.RuleSet = RuleSet;
    exports.RuleStorage = RuleStorage;
    exports.RuleSyntaxUtils = RuleSyntaxUtils;
    exports.RuleValidator = RuleValidator;
    exports.SOURCE_MAP_FILENAME_JSON = SOURCE_MAP_FILENAME_JSON;
    exports.SimpleRegex = SimpleRegex;
    exports.SourceMap = SourceMap;
    exports.StringRuleList = StringRuleList;
    exports.TooComplexRegexpError = TooComplexRegexpError;
    exports.TooManyRegexpRulesError = TooManyRegexpRulesError;
    exports.TooManyRulesError = TooManyRulesError;
    exports.UnavailableFilterSourceError = UnavailableFilterSourceError;
    exports.UnavailableRuleSetSourceError = UnavailableRuleSetSourceError;
    exports.UnsupportedModifierError = UnsupportedModifierError;
    exports.UnsupportedRegexpError = UnsupportedRegexpError;
    exports.cleanUrlParamByRegExp = cleanUrlParamByRegExp;
    exports.fastHash = fastHash;
    exports.fastHashBetween = fastHashBetween;
    exports.getRelativeUrl = getRelativeUrl;
    exports.hasUnquotedSubstring = hasUnquotedSubstring;
    exports.indexOfAny = indexOfAny;
    exports.isCompatibleWith = isCompatibleWith;
    exports.isDomainName = isDomainName;
    exports.replaceAll = replaceAll;
    exports.setConfiguration = setConfiguration;
    exports.setLogger = setLogger;
    exports.splitByDelimiterWithEscapeCharacter = splitByDelimiterWithEscapeCharacter;
    exports.startsAtIndexWith = startsAtIndexWith;
    exports.stringArraysEquals = stringArraysEquals;
    exports.stringArraysHaveIntersection = stringArraysHaveIntersection;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ 554:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.9.0 - Fri Mar 25 2022 17:00:23 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof globalThis != "object" || typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
    throw new Error("This script should only be loaded in a browser extension.");
  }

  if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      }); // Keep track if the deprecation warning has been logged at least once.

      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    }; // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = globalThis.browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "adguardApi": () => (/* reexport */ adguardApi)
});

// EXTERNAL MODULE: ../tsurlfilter/dist/tsurlfilter.umd.js
var tsurlfilter_umd = __webpack_require__(54);
;// CONCATENATED MODULE: ../../node_modules/zod/lib/index.mjs
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        return this._path.concat(this._key);
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError(ctx.common.issues);
        return { success: false, error };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this.superRefine = this._refinement;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.default = this.default.bind(this);
        this.describe = this.describe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    optional() {
        return ZodOptional.create(this);
    }
    nullable() {
        return ZodNullable.create(this);
    }
    nullish() {
        return this.optional().nullable();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this);
    }
    or(option) {
        return ZodUnion.create([this, option]);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming);
    }
    transform(transform) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(undefined),
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all(ctx.data.map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = ctx.data.map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return this.min(len, message).max(len, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil || (objectUtil = {}));
const AugmentFactory = (def) => (augmentation) => {
    return new ZodObject({
        ...def,
        shape: () => ({
            ...def.shape(),
            ...augmentation,
        }),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        // const mergedShape = objectUtil.mergeShapes(
        //   this._def.shape(),
        //   merging._def.shape()
        // );
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).map((key) => {
            // only add to shape if key corresponds to an element of the current shape
            if (this.shape[key])
                shape[key] = this.shape[key];
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        if (mask) {
            util.objectKeys(this.shape).map((key) => {
                if (util.objectKeys(mask).indexOf(key) === -1) {
                    newShape[key] = this.shape[key];
                }
                else {
                    newShape[key] = this.shape[key].optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        else {
            for (const key in this.shape) {
                const fieldSchema = this.shape[key];
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required() {
        const newShape = {};
        for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
            }
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.options.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: this.validDiscriminatorValues,
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get validDiscriminatorValues() {
        return Array.from(this.options.keys());
    }
    get options() {
        return this._def.options;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, types, params) {
        // Get all the valid discriminator values
        const options = new Map();
        try {
            types.forEach((type) => {
                const discriminatorValue = type.shape[discriminator].value;
                options.set(discriminatorValue, type);
            });
        }
        catch (e) {
            throw new Error("The discriminator value could not be extracted from all the provided schemas");
        }
        // Assert that all the discriminator values are unique
        if (options.size !== types.length) {
            throw new Error("Some of the discriminator values are not unique");
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                type: "array",
            });
            status.dirty();
        }
        const items = ctx.data
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                // if (base.status === "aborted") return INVALID;
                // if (base.status === "dirty") {
                //   return { status: "dirty", value: base.value };
                // }
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    // if (base.status === "aborted") return INVALID;
                    // if (base.status === "dirty") {
                    //   return { status: "dirty", value: base.value };
                    // }
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : params;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// new approach that works for abstract classes
// but required TS 4.4+
// abstract class Class {
//   constructor(..._: any[]) {}
// }
// const instanceOfType = <T extends typeof Class>(
const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params, true);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const NEVER = INVALID;

var mod = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getParsedType: getParsedType,
    ZodParsedType: ZodParsedType,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    get objectUtil () { return objectUtil; },
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});



;// CONCATENATED MODULE: ../../node_modules/tldts-core/dist/es6/src/options.js
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname,
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function options_setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
}
//# sourceMappingURL=options.js.map
;// CONCATENATED MODULE: ../../node_modules/tldts-core/dist/es6/src/factory.js
/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */







function factory_getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null,
    };
}
function factory_resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function factory_parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (options.extractHostname === false) {
        result.hostname = url;
    }
    else if (options.mixedInputs === true) {
        result.hostname = extractHostname(url, isValidHostname(url));
    }
    else {
        result.hostname = extractHostname(url, false);
    }
    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {
        return result;
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp === true) {
        result.isIp = isIp(result.hostname);
        if (result.isIp === true) {
            return result;
        }
    }
    // Perform optional hostname validation. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain.
    if (options.validateHostname === true &&
        options.extractHostname === true &&
        isValidHostname(result.hostname) === false) {
        result.hostname = null;
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = getDomain(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = getSubdomain(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
    return result;
}
//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ../../node_modules/tldts-core/dist/es6/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../tswebextension/node_modules/tldts/dist/es6/src/data/trie.js
const trie_exceptions = (function () {
    const _0 = { "$": 1, "succ": {} }, _1 = { "$": 0, "succ": { "city": _0 } };
    const exceptions = { "$": 0, "succ": { "ck": { "$": 0, "succ": { "www": _0 } }, "jp": { "$": 0, "succ": { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 } } } };
    ;
    return exceptions;
})();
const trie_rules = (function () {
    const _2 = { "$": 1, "succ": {} }, _3 = { "$": 2, "succ": {} }, _4 = { "$": 1, "succ": { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 } }, _5 = { "$": 0, "succ": { "*": _3 } }, _6 = { "$": 1, "succ": { "blogspot": _3 } }, _7 = { "$": 1, "succ": { "gov": _2 } }, _8 = { "$": 0, "succ": { "*": _2 } }, _9 = { "$": 0, "succ": { "cloud": _3 } }, _10 = { "$": 1, "succ": { "co": _3 } }, _11 = { "$": 2, "succ": { "nodes": _3 } }, _12 = { "$": 0, "succ": { "s3": _3 } }, _13 = { "$": 0, "succ": { "direct": _3 } }, _14 = { "$": 2, "succ": { "id": _3 } }, _15 = { "$": 0, "succ": { "vfs": _3, "webview-assets": _3 } }, _16 = { "$": 0, "succ": { "cloud9": _15 } }, _17 = { "$": 0, "succ": { "dualstack": _12, "cloud9": _15 } }, _18 = { "$": 0, "succ": { "dualstack": _12, "s3": _3, "s3-website": _3, "cloud9": _15 } }, _19 = { "$": 0, "succ": { "apps": _3 } }, _20 = { "$": 0, "succ": { "paas": _3 } }, _21 = { "$": 0, "succ": { "app": _3 } }, _22 = { "$": 2, "succ": { "eu": _3 } }, _23 = { "$": 0, "succ": { "site": _3 } }, _24 = { "$": 0, "succ": { "pages": _3 } }, _25 = { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2 } }, _26 = { "$": 0, "succ": { "j": _3 } }, _27 = { "$": 0, "succ": { "jelastic": _3 } }, _28 = { "$": 0, "succ": { "user": _3 } }, _29 = { "$": 1, "succ": { "ybo": _3 } }, _30 = { "$": 0, "succ": { "cust": _3, "reservd": _3 } }, _31 = { "$": 0, "succ": { "cust": _3 } }, _32 = { "$": 1, "succ": { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 } }, _33 = { "$": 1, "succ": { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 } }, _34 = { "$": 1, "succ": { "gov": _2, "blogspot": _3 } }, _35 = { "$": 1, "succ": { "framer": _3 } }, _36 = { "$": 1, "succ": { "barsy": _3 } }, _37 = { "$": 0, "succ": { "forgot": _3 } }, _38 = { "$": 1, "succ": { "gs": _2 } }, _39 = { "$": 0, "succ": { "nes": _2 } }, _40 = { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2 } }, _41 = { "$": 1, "succ": { "cc": _2, "lib": _2 } };
    const rules = { "$": 0, "succ": { "ac": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 } }, "ad": { "$": 1, "succ": { "nom": _2 } }, "ae": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "aero": { "$": 1, "succ": { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 } }, "af": _4, "ag": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 } }, "ai": { "$": 1, "succ": { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 } }, "al": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 } }, "am": { "$": 1, "succ": { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 } }, "ao": { "$": 1, "succ": { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 } }, "aq": _2, "ar": { "$": 1, "succ": { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 } }, "arpa": { "$": 1, "succ": { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 } }, "as": _7, "asia": { "$": 1, "succ": { "cloudns": _3 } }, "at": { "$": 1, "succ": { "ac": { "$": 1, "succ": { "sth": _2 } }, "co": _6, "gv": _2, "or": _2, "funkfeuer": { "$": 0, "succ": { "wien": _3 } }, "futurecms": { "$": 0, "succ": { "*": _3, "ex": _5, "in": _5 } }, "futurehosting": _3, "futuremailing": _3, "ortsinfo": { "$": 0, "succ": { "ex": _5, "kunden": _5 } }, "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "au": { "$": 1, "succ": { "com": { "$": 1, "succ": { "blogspot": _3, "cloudlets": { "$": 0, "succ": { "mel": _3 } }, "myspreadshop": _3 } }, "net": _2, "org": _2, "edu": { "$": 1, "succ": { "act": _2, "catholic": _2, "nsw": { "$": 1, "succ": { "schools": _2 } }, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "gov": { "$": 1, "succ": { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "aw": { "$": 1, "succ": { "com": _2 } }, "ax": { "$": 1, "succ": { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 } }, "az": { "$": 1, "succ": { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 } }, "ba": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 } }, "bb": { "$": 1, "succ": { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 } }, "bd": _8, "be": { "$": 1, "succ": { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": { "$": 0, "succ": { "ezproxy": _3 } }, "123website": _3, "myspreadshop": _3, "transurl": _5 } }, "bf": _7, "bg": { "$": 1, "succ": { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 } }, "bh": _4, "bi": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 } }, "biz": { "$": 1, "succ": { "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 } }, "bj": { "$": 1, "succ": { "asso": _2, "barreau": _2, "gouv": _2, "blogspot": _3 } }, "bm": _4, "bn": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 } }, "bo": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 } }, "br": { "$": 1, "succ": { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": { "$": 1, "succ": { "blogspot": _3, "virtualcloud": { "$": 0, "succ": { "scale": { "$": 0, "succ": { "users": _3 } } } }, "simplesite": _3 } }, "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": { "$": 1, "succ": { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 } }, "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": { "$": 1, "succ": { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 } }, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 } }, "bs": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 } }, "bt": _4, "bv": _2, "bw": { "$": 1, "succ": { "co": _2, "org": _2 } }, "by": { "$": 1, "succ": { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 } }, "bz": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 } }, "ca": { "$": 1, "succ": { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 } }, "cat": _2, "cc": { "$": 1, "succ": { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": { "$": 0, "succ": { "instances": _3 } } } }, "cd": _7, "cf": _6, "cg": _2, "ch": { "$": 1, "succ": { "square7": _3, "blogspot": _3, "flow": { "$": 0, "succ": { "ae": { "$": 0, "succ": { "alp1": _3 } }, "appengine": _3 } }, "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": { "$": 0, "succ": { "*": _3, "svc": _5 } }, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "ci": { "$": 1, "succ": { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aéroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 } }, "ck": _8, "cl": { "$": 1, "succ": { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "cm": { "$": 1, "succ": { "co": _2, "com": _2, "gov": _2, "net": _2 } }, "cn": { "$": 1, "succ": { "ac": _2, "com": { "$": 1, "succ": { "amazonaws": { "$": 0, "succ": { "compute": _5, "cn-north-1": _12, "eb": { "$": 0, "succ": { "cn-north-1": _3, "cn-northwest-1": _3 } }, "elb": _5 } } } }, "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "公司": _2, "xn--io0a7i": _2, "网络": _2, "xn--od0alg": _2, "網絡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "instantcloud": _3, "quickconnect": _13 } }, "co": { "$": 1, "succ": { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 } }, "com": { "$": 1, "succ": { "devcdnaccesso": _5, "adobeaemcloud": { "$": 2, "succ": { "dev": _5 } }, "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": { "$": 0, "succ": { "compute": _5, "compute-1": _5, "us-east-1": { "$": 2, "succ": { "dualstack": _12, "cloud9": _15 } }, "ap-northeast-1": _17, "ap-northeast-2": _18, "ap-south-1": _18, "ap-southeast-1": _17, "ap-southeast-2": _17, "ca-central-1": _18, "eu-central-1": _18, "eu-west-1": _17, "eu-west-2": _18, "eu-west-3": _18, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _17, "us-east-2": _18, "af-south-1": _16, "ap-east-1": _16, "ap-northeast-3": _16, "eu-north-1": _16, "eu-south-1": _16, "me-south-1": _16, "us-west-1": _16, "us-west-2": _16, "elb": _5 } }, "elasticbeanstalk": { "$": 2, "succ": { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 } }, "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "trycloudflare": _3, "customer-oci": { "$": 0, "succ": { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 } }, "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": { "$": 0, "succ": { "demo": _3, "instance": _3 } }, "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": { "$": 0, "succ": { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 } }, "onfabrica": _3, "fbsbx": _19, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": { "$": 2, "succ": { "r": _5 } }, "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "myravendb": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "clicketcloud": _3, "dopaas": _3, "hidora": _3, "hosted-by-previder": _20, "hosteur": { "$": 0, "succ": { "rag-cloud": _3, "rag-cloud-ch": _3 } }, "ik-server": { "$": 0, "succ": { "jcloud": _3, "jcloud-ver-jpc": _3 } }, "jelastic": { "$": 0, "succ": { "demo": _3 } }, "kilatiron": _3, "massivegrid": _20, "wafaicloud": { "$": 0, "succ": { "jed": _3, "lon": _3, "ryd": _3 } }, "joyent": { "$": 0, "succ": { "cns": _5 } }, "ktistory": _3, "lpusercontent": _3, "lmpm": _21, "linode": { "$": 0, "succ": { "members": _3, "nodebalancer": _5 } }, "linodeobjects": _5, "linodeusercontent": { "$": 0, "succ": { "ip": _3 } }, "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _22, "hostedpi": _3, "mythic-beasts": { "$": 0, "succ": { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 } }, "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": { "$": 0, "succ": { "static": _3 } }, "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": { "$": 0, "succ": { "xen": _3 } }, "pythonanywhere": _22, "qualifioapp": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _21, "onrender": _3, "code": { "$": 0, "succ": { "builder": _5, "dev-builder": _5, "stg-builder": _5 } }, "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": { "$": 2, "succ": { "alpha": _3, "beta": _3 } }, "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": { "$": 0, "succ": { "api": _3 } }, "temp-dns": _3, "dsmynas": _3, "familyds": _3, "tb-hosting": _23, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": { "$": 0, "succ": { "pro": _3 } }, "hk": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _24, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": { "$": 2, "succ": { "js": _3 } }, "wixsite": _3, "xnbay": { "$": 2, "succ": { "u2": _3, "u2-local": _3 } }, "yolasite": _3 } }, "coop": _2, "cr": { "$": 1, "succ": { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 } }, "cu": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 } }, "cv": { "$": 1, "succ": { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 } }, "cw": _25, "cx": { "$": 1, "succ": { "gov": _2, "ath": _3, "info": _3 } }, "cy": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": { "$": 1, "succ": { "blogspot": _3, "scaleforce": _26 } }, "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 } }, "cz": { "$": 1, "succ": { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": { "$": 0, "succ": { "cloud": _5, "custom": _3 } }, "muni": { "$": 0, "succ": { "cloud": { "$": 0, "succ": { "flt": _3, "usr": _3 } } } } } }, "de": { "$": 1, "succ": { "bplaced": _3, "square7": _3, "com": _3, "cosidns": { "$": 0, "succ": { "dyn": _3 } }, "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": { "$": 2, "succ": { "dyn": _3, "dyndns": _3 } }, "dyndns1": _3, "dyn-ip24": _3, "home-webserver": { "$": 2, "succ": { "dyn": _3 } }, "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "günstigbestellen": _3, "xn--gnstigliefern-wob": _3, "günstigliefern": _3, "hs-heilbronn": { "$": 0, "succ": { "it": _24 } }, "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": { "$": 0, "succ": { "customer": _3 } }, "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 } }, "dj": _2, "dk": { "$": 1, "succ": { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "dm": _4, "do": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 } }, "dz": { "$": 1, "succ": { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 } }, "ec": { "$": 1, "succ": { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 } }, "edu": { "$": 1, "succ": { "rit": { "$": 0, "succ": { "git-pages": _3 } } } }, "ee": { "$": 1, "succ": { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 } }, "eg": { "$": 1, "succ": { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 } }, "er": _8, "es": { "$": 1, "succ": { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 } }, "et": { "$": 1, "succ": { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 } }, "eu": { "$": 1, "succ": { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _27, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 } }, "fi": { "$": 1, "succ": { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "häkkinen": _3, "iki": _3, "cloudplatform": { "$": 0, "succ": { "fi": _3 } }, "datacenter": { "$": 0, "succ": { "demo": _3, "paas": _3 } }, "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 } }, "fj": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "fk": _8, "fm": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 } }, "fo": _2, "fr": { "$": 1, "succ": { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "aeroport": _2, "avocat": _2, "avoues": _2, "cci": _2, "chambagri": _2, "chirurgiens-dentistes": _2, "experts-comptables": _2, "geometre-expert": _2, "greta": _2, "huissier-justice": _2, "medecin": _2, "notaires": _2, "pharmacien": _2, "port": _2, "veterinaire": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "myspreadshop": _3, "ynh": _3 } }, "ga": _2, "gb": _2, "gd": { "$": 1, "succ": { "edu": _2, "gov": _2 } }, "ge": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 } }, "gf": _2, "gg": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": { "$": 2, "succ": { "daemon": _3 } } } }, "gh": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 } }, "gi": { "$": 1, "succ": { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 } }, "gl": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 } }, "gm": _2, "gn": { "$": 1, "succ": { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 } }, "gov": _2, "gp": { "$": 1, "succ": { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 } }, "gq": _2, "gr": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 } }, "gs": _2, "gt": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 } }, "gu": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 } }, "gw": _2, "gy": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 } }, "hk": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "公司": _2, "xn--wcvs22d": _2, "教育": _2, "xn--lcvr32d": _2, "敎育": _2, "xn--mxtq1m": _2, "政府": _2, "xn--gmqw5a": _2, "個人": _2, "xn--ciqpn": _2, "个人": _2, "xn--gmq050i": _2, "箇人": _2, "xn--zf0avx": _2, "網络": _2, "xn--io0a7i": _2, "网络": _2, "xn--mk0axi": _2, "组織": _2, "xn--od0alg": _2, "網絡": _2, "xn--od0aq3b": _2, "网絡": _2, "xn--tn0ag": _2, "组织": _2, "xn--uc0atv": _2, "組織": _2, "xn--uc0ay4a": _2, "組织": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 } }, "hm": _2, "hn": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 } }, "hr": { "$": 1, "succ": { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 } }, "ht": { "$": 1, "succ": { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 } }, "hu": { "$": 1, "succ": { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 } }, "id": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": { "$": 1, "succ": { "rss": _5 } }, "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 } }, "ie": { "$": 1, "succ": { "gov": _2, "blogspot": _3, "myspreadshop": _3 } }, "il": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ravpage": _3, "blogspot": _3, "tabitorder": _3 } }, "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 } }, "xn--4dbrk0ce": { "$": 1, "succ": { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 } }, "ישראל": { "$": 1, "succ": { "אקדמיה": _2, "ישוב": _2, "צהל": _2, "ממשל": _2 } }, "im": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ltd": _2, "plc": _2 } }, "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 } }, "in": { "$": 1, "succ": { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 } }, "info": { "$": 1, "succ": { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 } }, "int": { "$": 1, "succ": { "eu": _2 } }, "io": { "$": 1, "succ": { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": { "$": 0, "succ": { "app": _3, "backyards": _5 } }, "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": { "$": 0, "succ": { "uk0": _3 } }, "cleverapps": _3, "dappnode": { "$": 0, "succ": { "dyndns": _3 } }, "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": { "$": 0, "succ": { "id": _3 } }, "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _20, "beebyteapp": { "$": 0, "succ": { "sekd1": _3 } }, "jele": _3, "unispace": { "$": 0, "succ": { "cloud-fr1": _3 } }, "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": _3, "nodeart": { "$": 0, "succ": { "stage": _3 } }, "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": { "$": 2, "succ": { "mock": _3 } }, "protonet": _3, "qoto": _3, "qcx": { "$": 2, "succ": { "sys": _5 } }, "vaporcloud": _3, "vbrplsbx": { "$": 0, "succ": { "g": _3 } }, "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": { "$": 0, "succ": { "devices": _3 } }, "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _19, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": { "$": 0, "succ": { "dev": _30, "disrec": _30, "prod": _31, "testing": _30 } }, "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "basicserver": _3, "virtualserver": _3 } }, "iq": _32, "ir": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2 } }, "is": { "$": 1, "succ": { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 } }, "it": { "$": 1, "succ": { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-süd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-südtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-süd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-südtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosüd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosüdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsüd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsüdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallée-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallée-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valléeaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valléedaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-südtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-südtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-südtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlì": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlì": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlì-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlìcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "südtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": { "$": 0, "succ": { "jc": _3 } }, "tim": { "$": 0, "succ": { "open": { "$": 0, "succ": { "jelastic": _9 } } } }, "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 } }, "je": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "of": _3 } }, "jm": _8, "jo": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 } }, "jobs": _2, "jp": { "$": 1, "succ": { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": { "$": 1, "succ": { "aseinet": _28, "gehirn": _3 } }, "or": _2, "aichi": { "$": 1, "succ": { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 } }, "akita": { "$": 1, "succ": { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 } }, "aomori": { "$": 1, "succ": { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 } }, "chiba": { "$": 1, "succ": { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 } }, "ehime": { "$": 1, "succ": { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 } }, "fukui": { "$": 1, "succ": { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 } }, "fukuoka": { "$": 1, "succ": { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 } }, "fukushima": { "$": 1, "succ": { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 } }, "gifu": { "$": 1, "succ": { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 } }, "gunma": { "$": 1, "succ": { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 } }, "hiroshima": { "$": 1, "succ": { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 } }, "hokkaido": { "$": 1, "succ": { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 } }, "hyogo": { "$": 1, "succ": { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 } }, "ibaraki": { "$": 1, "succ": { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 } }, "ishikawa": { "$": 1, "succ": { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 } }, "iwate": { "$": 1, "succ": { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 } }, "kagawa": { "$": 1, "succ": { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 } }, "kagoshima": { "$": 1, "succ": { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 } }, "kanagawa": { "$": 1, "succ": { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 } }, "kochi": { "$": 1, "succ": { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 } }, "kumamoto": { "$": 1, "succ": { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 } }, "kyoto": { "$": 1, "succ": { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 } }, "mie": { "$": 1, "succ": { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 } }, "miyagi": { "$": 1, "succ": { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 } }, "miyazaki": { "$": 1, "succ": { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 } }, "nagano": { "$": 1, "succ": { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 } }, "nagasaki": { "$": 1, "succ": { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 } }, "nara": { "$": 1, "succ": { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 } }, "niigata": { "$": 1, "succ": { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 } }, "oita": { "$": 1, "succ": { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 } }, "okayama": { "$": 1, "succ": { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 } }, "okinawa": { "$": 1, "succ": { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 } }, "osaka": { "$": 1, "succ": { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 } }, "saga": { "$": 1, "succ": { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 } }, "saitama": { "$": 1, "succ": { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 } }, "shiga": { "$": 1, "succ": { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 } }, "shimane": { "$": 1, "succ": { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 } }, "shizuoka": { "$": 1, "succ": { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 } }, "tochigi": { "$": 1, "succ": { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 } }, "tokushima": { "$": 1, "succ": { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 } }, "tokyo": { "$": 1, "succ": { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 } }, "tottori": { "$": 1, "succ": { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 } }, "toyama": { "$": 1, "succ": { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 } }, "wakayama": { "$": 1, "succ": { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 } }, "yamagata": { "$": 1, "succ": { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 } }, "yamaguchi": { "$": 1, "succ": { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 } }, "yamanashi": { "$": 1, "succ": { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 } }, "xn--4pvxs": _2, "栃木": _2, "xn--vgu402c": _2, "愛知": _2, "xn--c3s14m": _2, "愛媛": _2, "xn--f6qx53a": _2, "兵庫": _2, "xn--8pvr4u": _2, "熊本": _2, "xn--uist22h": _2, "茨城": _2, "xn--djrs72d6uy": _2, "北海道": _2, "xn--mkru45i": _2, "千葉": _2, "xn--0trq7p7nn": _2, "和歌山": _2, "xn--8ltr62k": _2, "長崎": _2, "xn--2m4a15e": _2, "長野": _2, "xn--efvn9s": _2, "新潟": _2, "xn--32vp30h": _2, "青森": _2, "xn--4it797k": _2, "静岡": _2, "xn--1lqs71d": _2, "東京": _2, "xn--5rtp49c": _2, "石川": _2, "xn--5js045d": _2, "埼玉": _2, "xn--ehqz56n": _2, "三重": _2, "xn--1lqs03n": _2, "京都": _2, "xn--qqqt11m": _2, "佐賀": _2, "xn--kbrq7o": _2, "大分": _2, "xn--pssu33l": _2, "大阪": _2, "xn--ntsq17g": _2, "奈良": _2, "xn--uisz3g": _2, "宮城": _2, "xn--6btw5a": _2, "宮崎": _2, "xn--1ctwo": _2, "富山": _2, "xn--6orx2r": _2, "山口": _2, "xn--rht61e": _2, "山形": _2, "xn--rht27z": _2, "山梨": _2, "xn--djty4k": _2, "岩手": _2, "xn--nit225k": _2, "岐阜": _2, "xn--rht3d": _2, "岡山": _2, "xn--klty5x": _2, "島根": _2, "xn--kltx9a": _2, "広島": _2, "xn--kltp7d": _2, "徳島": _2, "xn--uuwu58a": _2, "沖縄": _2, "xn--zbx025d": _2, "滋賀": _2, "xn--ntso0iqx3a": _2, "神奈川": _2, "xn--elqq16h": _2, "福井": _2, "xn--4it168d": _2, "福岡": _2, "xn--klt787d": _2, "福島": _2, "xn--rny31h": _2, "秋田": _2, "xn--7t0a264c": _2, "群馬": _2, "xn--5rtq34k": _2, "香川": _2, "xn--k7yn95e": _2, "高知": _2, "xn--tor131o": _2, "鳥取": _2, "xn--d5qv7z876c": _2, "鹿児島": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3 } }, "ke": { "$": 1, "succ": { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 } }, "kg": { "$": 1, "succ": { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 } }, "kh": _8, "ki": _33, "km": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 } }, "kn": { "$": 1, "succ": { "net": _2, "org": _2, "edu": _2, "gov": _2 } }, "kp": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 } }, "kr": { "$": 1, "succ": { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 } }, "kw": { "$": 1, "succ": { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 } }, "ky": _25, "kz": { "$": 1, "succ": { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": { "$": 0, "succ": { "upaas": _3 } } } }, "la": { "$": 1, "succ": { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 } }, "lb": _4, "lc": { "$": 1, "succ": { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 } }, "li": { "$": 1, "succ": { "blogspot": _3, "caa": _3 } }, "lk": { "$": 1, "succ": { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 } }, "lr": _4, "ls": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 } }, "lt": _34, "lu": { "$": 1, "succ": { "blogspot": _3, "123website": _3 } }, "lv": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 } }, "ly": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 } }, "ma": { "$": 1, "succ": { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 } }, "mc": { "$": 1, "succ": { "tm": _2, "asso": _2 } }, "md": { "$": 1, "succ": { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 } }, "me": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": { "$": 2, "succ": { "localhost": _3 } }, "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "tbits": _3, "transip": _23, "wedeploy": _3, "yombo": _3, "nohost": _3 } }, "mg": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 } }, "mh": _2, "mil": _2, "mk": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 } }, "ml": { "$": 1, "succ": { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 } }, "mm": _8, "mn": { "$": 1, "succ": { "gov": _2, "edu": _2, "org": _2, "nyc": _3 } }, "mo": _4, "mobi": { "$": 1, "succ": { "barsy": _3, "dscloud": _3 } }, "mp": { "$": 1, "succ": { "ju": _3 } }, "mq": _2, "mr": _34, "ms": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 } }, "mt": { "$": 1, "succ": { "com": _6, "edu": _2, "net": _2, "org": _2 } }, "mu": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 } }, "museum": { "$": 1, "succ": { "academy": _2, "agriculture": _2, "air": _2, "airguard": _2, "alabama": _2, "alaska": _2, "amber": _2, "ambulance": _2, "american": _2, "americana": _2, "americanantiques": _2, "americanart": _2, "amsterdam": _2, "and": _2, "annefrank": _2, "anthro": _2, "anthropology": _2, "antiques": _2, "aquarium": _2, "arboretum": _2, "archaeological": _2, "archaeology": _2, "architecture": _2, "art": _2, "artanddesign": _2, "artcenter": _2, "artdeco": _2, "arteducation": _2, "artgallery": _2, "arts": _2, "artsandcrafts": _2, "asmatart": _2, "assassination": _2, "assisi": _2, "association": _2, "astronomy": _2, "atlanta": _2, "austin": _2, "australia": _2, "automotive": _2, "aviation": _2, "axis": _2, "badajoz": _2, "baghdad": _2, "bahn": _2, "bale": _2, "baltimore": _2, "barcelona": _2, "baseball": _2, "basel": _2, "baths": _2, "bauern": _2, "beauxarts": _2, "beeldengeluid": _2, "bellevue": _2, "bergbau": _2, "berkeley": _2, "berlin": _2, "bern": _2, "bible": _2, "bilbao": _2, "bill": _2, "birdart": _2, "birthplace": _2, "bonn": _2, "boston": _2, "botanical": _2, "botanicalgarden": _2, "botanicgarden": _2, "botany": _2, "brandywinevalley": _2, "brasil": _2, "bristol": _2, "british": _2, "britishcolumbia": _2, "broadcast": _2, "brunel": _2, "brussel": _2, "brussels": _2, "bruxelles": _2, "building": _2, "burghof": _2, "bus": _2, "bushey": _2, "cadaques": _2, "california": _2, "cambridge": _2, "can": _2, "canada": _2, "capebreton": _2, "carrier": _2, "cartoonart": _2, "casadelamoneda": _2, "castle": _2, "castres": _2, "celtic": _2, "center": _2, "chattanooga": _2, "cheltenham": _2, "chesapeakebay": _2, "chicago": _2, "children": _2, "childrens": _2, "childrensgarden": _2, "chiropractic": _2, "chocolate": _2, "christiansburg": _2, "cincinnati": _2, "cinema": _2, "circus": _2, "civilisation": _2, "civilization": _2, "civilwar": _2, "clinton": _2, "clock": _2, "coal": _2, "coastaldefence": _2, "cody": _2, "coldwar": _2, "collection": _2, "colonialwilliamsburg": _2, "coloradoplateau": _2, "columbia": _2, "columbus": _2, "communication": _2, "communications": _2, "community": _2, "computer": _2, "computerhistory": _2, "xn--comunicaes-v6a2o": _2, "comunicações": _2, "contemporary": _2, "contemporaryart": _2, "convent": _2, "copenhagen": _2, "corporation": _2, "xn--correios-e-telecomunicaes-ghc29a": _2, "correios-e-telecomunicações": _2, "corvette": _2, "costume": _2, "countryestate": _2, "county": _2, "crafts": _2, "cranbrook": _2, "creation": _2, "cultural": _2, "culturalcenter": _2, "culture": _2, "cyber": _2, "cymru": _2, "dali": _2, "dallas": _2, "database": _2, "ddr": _2, "decorativearts": _2, "delaware": _2, "delmenhorst": _2, "denmark": _2, "depot": _2, "design": _2, "detroit": _2, "dinosaur": _2, "discovery": _2, "dolls": _2, "donostia": _2, "durham": _2, "eastafrica": _2, "eastcoast": _2, "education": _2, "educational": _2, "egyptian": _2, "eisenbahn": _2, "elburg": _2, "elvendrell": _2, "embroidery": _2, "encyclopedic": _2, "england": _2, "entomology": _2, "environment": _2, "environmentalconservation": _2, "epilepsy": _2, "essex": _2, "estate": _2, "ethnology": _2, "exeter": _2, "exhibition": _2, "family": _2, "farm": _2, "farmequipment": _2, "farmers": _2, "farmstead": _2, "field": _2, "figueres": _2, "filatelia": _2, "film": _2, "fineart": _2, "finearts": _2, "finland": _2, "flanders": _2, "florida": _2, "force": _2, "fortmissoula": _2, "fortworth": _2, "foundation": _2, "francaise": _2, "frankfurt": _2, "franziskaner": _2, "freemasonry": _2, "freiburg": _2, "fribourg": _2, "frog": _2, "fundacio": _2, "furniture": _2, "gallery": _2, "garden": _2, "gateway": _2, "geelvinck": _2, "gemological": _2, "geology": _2, "georgia": _2, "giessen": _2, "glas": _2, "glass": _2, "gorge": _2, "grandrapids": _2, "graz": _2, "guernsey": _2, "halloffame": _2, "hamburg": _2, "handson": _2, "harvestcelebration": _2, "hawaii": _2, "health": _2, "heimatunduhren": _2, "hellas": _2, "helsinki": _2, "hembygdsforbund": _2, "heritage": _2, "histoire": _2, "historical": _2, "historicalsociety": _2, "historichouses": _2, "historisch": _2, "historisches": _2, "history": _2, "historyofscience": _2, "horology": _2, "house": _2, "humanities": _2, "illustration": _2, "imageandsound": _2, "indian": _2, "indiana": _2, "indianapolis": _2, "indianmarket": _2, "intelligence": _2, "interactive": _2, "iraq": _2, "iron": _2, "isleofman": _2, "jamison": _2, "jefferson": _2, "jerusalem": _2, "jewelry": _2, "jewish": _2, "jewishart": _2, "jfk": _2, "journalism": _2, "judaica": _2, "judygarland": _2, "juedisches": _2, "juif": _2, "karate": _2, "karikatur": _2, "kids": _2, "koebenhavn": _2, "koeln": _2, "kunst": _2, "kunstsammlung": _2, "kunstunddesign": _2, "labor": _2, "labour": _2, "lajolla": _2, "lancashire": _2, "landes": _2, "lans": _2, "xn--lns-qla": _2, "läns": _2, "larsson": _2, "lewismiller": _2, "lincoln": _2, "linz": _2, "living": _2, "livinghistory": _2, "localhistory": _2, "london": _2, "losangeles": _2, "louvre": _2, "loyalist": _2, "lucerne": _2, "luxembourg": _2, "luzern": _2, "mad": _2, "madrid": _2, "mallorca": _2, "manchester": _2, "mansion": _2, "mansions": _2, "manx": _2, "marburg": _2, "maritime": _2, "maritimo": _2, "maryland": _2, "marylhurst": _2, "media": _2, "medical": _2, "medizinhistorisches": _2, "meeres": _2, "memorial": _2, "mesaverde": _2, "michigan": _2, "midatlantic": _2, "military": _2, "mill": _2, "miners": _2, "mining": _2, "minnesota": _2, "missile": _2, "missoula": _2, "modern": _2, "moma": _2, "money": _2, "monmouth": _2, "monticello": _2, "montreal": _2, "moscow": _2, "motorcycle": _2, "muenchen": _2, "muenster": _2, "mulhouse": _2, "muncie": _2, "museet": _2, "museumcenter": _2, "museumvereniging": _2, "music": _2, "national": _2, "nationalfirearms": _2, "nationalheritage": _2, "nativeamerican": _2, "naturalhistory": _2, "naturalhistorymuseum": _2, "naturalsciences": _2, "nature": _2, "naturhistorisches": _2, "natuurwetenschappen": _2, "naumburg": _2, "naval": _2, "nebraska": _2, "neues": _2, "newhampshire": _2, "newjersey": _2, "newmexico": _2, "newport": _2, "newspaper": _2, "newyork": _2, "niepce": _2, "norfolk": _2, "north": _2, "nrw": _2, "nyc": _2, "nyny": _2, "oceanographic": _2, "oceanographique": _2, "omaha": _2, "online": _2, "ontario": _2, "openair": _2, "oregon": _2, "oregontrail": _2, "otago": _2, "oxford": _2, "pacific": _2, "paderborn": _2, "palace": _2, "paleo": _2, "palmsprings": _2, "panama": _2, "paris": _2, "pasadena": _2, "pharmacy": _2, "philadelphia": _2, "philadelphiaarea": _2, "philately": _2, "phoenix": _2, "photography": _2, "pilots": _2, "pittsburgh": _2, "planetarium": _2, "plantation": _2, "plants": _2, "plaza": _2, "portal": _2, "portland": _2, "portlligat": _2, "posts-and-telecommunications": _2, "preservation": _2, "presidio": _2, "press": _2, "project": _2, "public": _2, "pubol": _2, "quebec": _2, "railroad": _2, "railway": _2, "research": _2, "resistance": _2, "riodejaneiro": _2, "rochester": _2, "rockart": _2, "roma": _2, "russia": _2, "saintlouis": _2, "salem": _2, "salvadordali": _2, "salzburg": _2, "sandiego": _2, "sanfrancisco": _2, "santabarbara": _2, "santacruz": _2, "santafe": _2, "saskatchewan": _2, "satx": _2, "savannahga": _2, "schlesisches": _2, "schoenbrunn": _2, "schokoladen": _2, "school": _2, "schweiz": _2, "science": _2, "scienceandhistory": _2, "scienceandindustry": _2, "sciencecenter": _2, "sciencecenters": _2, "science-fiction": _2, "sciencehistory": _2, "sciences": _2, "sciencesnaturelles": _2, "scotland": _2, "seaport": _2, "settlement": _2, "settlers": _2, "shell": _2, "sherbrooke": _2, "sibenik": _2, "silk": _2, "ski": _2, "skole": _2, "society": _2, "sologne": _2, "soundandvision": _2, "southcarolina": _2, "southwest": _2, "space": _2, "spy": _2, "square": _2, "stadt": _2, "stalbans": _2, "starnberg": _2, "state": _2, "stateofdelaware": _2, "station": _2, "steam": _2, "steiermark": _2, "stjohn": _2, "stockholm": _2, "stpetersburg": _2, "stuttgart": _2, "suisse": _2, "surgeonshall": _2, "surrey": _2, "svizzera": _2, "sweden": _2, "sydney": _2, "tank": _2, "tcm": _2, "technology": _2, "telekommunikation": _2, "television": _2, "texas": _2, "textile": _2, "theater": _2, "time": _2, "timekeeping": _2, "topology": _2, "torino": _2, "touch": _2, "town": _2, "transport": _2, "tree": _2, "trolley": _2, "trust": _2, "trustee": _2, "uhren": _2, "ulm": _2, "undersea": _2, "university": _2, "usa": _2, "usantiques": _2, "usarts": _2, "uscountryestate": _2, "usculture": _2, "usdecorativearts": _2, "usgarden": _2, "ushistory": _2, "ushuaia": _2, "uslivinghistory": _2, "utah": _2, "uvic": _2, "valley": _2, "vantaa": _2, "versailles": _2, "viking": _2, "village": _2, "virginia": _2, "virtual": _2, "virtuel": _2, "vlaanderen": _2, "volkenkunde": _2, "wales": _2, "wallonie": _2, "war": _2, "washingtondc": _2, "watchandclock": _2, "watch-and-clock": _2, "western": _2, "westfalen": _2, "whaling": _2, "wildlife": _2, "williamsburg": _2, "windmill": _2, "workshop": _2, "york": _2, "yorkshire": _2, "yosemite": _2, "youth": _2, "zoological": _2, "zoology": _2, "xn--9dbhblg6di": _2, "ירושלים": _2, "xn--h1aegh": _2, "иком": _2 } }, "mv": { "$": 1, "succ": { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "mw": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 } }, "mx": { "$": 1, "succ": { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 } }, "my": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 } }, "mz": { "$": 1, "succ": { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "na": { "$": 1, "succ": { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 } }, "name": { "$": 1, "succ": { "her": _37, "his": _37 } }, "nc": { "$": 1, "succ": { "asso": _2, "nom": _2 } }, "ne": _2, "net": { "$": 1, "succ": { "adobeaemcloud": _3, "alwaysdata": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": { "$": 0, "succ": { "prod": { "$": 0, "succ": { "cdn": _3 } } } }, "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": { "$": 0, "succ": { "r": _3 } }, "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": { "$": 2, "succ": { "u": _3 } }, "fastlylb": { "$": 2, "succ": { "map": _3 } }, "fastly": { "$": 0, "succ": { "freetls": _3, "map": _3, "prod": { "$": 0, "succ": { "a": _3, "global": _3 } }, "ssl": { "$": 0, "succ": { "a": _3, "b": _3, "global": _3 } } } }, "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": { "$": 2, "succ": { "fra1-de": _3, "west1-us": _3 } }, "elastx": { "$": 0, "succ": { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 } }, "faststacks": _3, "massivegrid": { "$": 0, "succ": { "paas": { "$": 0, "succ": { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 } } } }, "saveincloud": { "$": 0, "succ": { "jelastic": _3, "nordeste-idc": _3 } }, "scaleforce": _26, "tsukaeru": _27, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": { "$": 2, "succ": { "1": _3, "2": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 } }, "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": { "$": 0, "succ": { "webpaas": _5, "hosting": _5 } }, "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": { "$": 2, "succ": { "jelastic": { "$": 0, "succ": { "atl": _3, "njs": _3, "ric": _3 } } } }, "myspreadshop": _3, "srcf": { "$": 0, "succ": { "soc": _3, "user": _3 } }, "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": { "$": 0, "succ": { "beta": _3 } }, "ts": _3, "torproject": { "$": 2, "succ": { "pages": _3 } }, "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": { "$": 2, "succ": { "storage": _3, "website": _3 } }, "za": _3 } }, "nf": { "$": 1, "succ": { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 } }, "ng": { "$": 1, "succ": { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 } }, "ni": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 } }, "nl": { "$": 1, "succ": { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 } }, "no": { "$": 1, "succ": { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _38, "ah": _38, "bu": _38, "fm": _38, "hl": _38, "hm": _38, "jan-mayen": _38, "mr": _38, "nl": _38, "nt": _38, "of": _38, "ol": _38, "oslo": _38, "rl": _38, "sf": _38, "st": _38, "svalbard": _38, "tm": _38, "tr": _38, "va": _38, "vf": _38, "akrehamn": _2, "xn--krehamn-dxa": _2, "åkrehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "ålgård": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brønnøysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drøbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florø": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hønefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jørpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevåg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjøndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjøen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osøyro": _2, "raholt": _2, "xn--rholt-mra": _2, "råholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjøen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjørdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "åfjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "ål": _2, "alesund": _2, "xn--lesund-hua": _2, "ålesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "áltá": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "álaheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "åmli": _2, "amot": _2, "xn--mot-tla": _2, "åmot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andøy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "årdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "ås": _2, "aseral": _2, "xn--seral-lra": _2, "åseral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askøy": _2, "asnes": _2, "xn--snes-poa": _2, "åsnes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-høland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averøy": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bálát": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "báhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bájddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "báidár": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevåg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalváhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkøy": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodø": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bådåddjå": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brønnøy": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bærum": _2, "telemark": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2 } }, "nordland": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2, "heroy": _2, "xn--hery-ira": _2, "herøy": _2 } }, "bievat": _2, "xn--bievt-0qa": _2, "bievát": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bømlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "båtsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "báhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrøy": _2, "donna": _2, "xn--dnna-gra": _2, "dønna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenášši": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnøy": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flå": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "fræna": _2, "froya": _2, "xn--frya-hra": _2, "frøya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "førde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gáŋgaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskål": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjøvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kråanghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hábmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hápmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hámmárfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "ákŋoluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": { "$": 0, "succ": { "heroy": _2, "sande": _2 } }, "xn--mre-og-romsdal-qqb": { "$": 0, "succ": { "xn--hery-ira": _2, "sande": _2 } }, "møre-og-romsdal": { "$": 0, "succ": { "herøy": _2, "sande": _2 } }, "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobøl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtålen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hægebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "høyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "høylandet": _2, "ha": _2, "xn--h-2fa": _2, "hå": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderøy": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jølster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kárášjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gálsá": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmøy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klæbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerø": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krødsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "ráhkkerávju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsøy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvæfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvænangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "návuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kåfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gáivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabát": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaŋgaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindås": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "láhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurøy": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lærdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lødingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lørenskog": _2, "loten": _2, "xn--lten-gra": _2, "løten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "måsøy": _2, "muosat": _2, "xn--muost-0qa": _2, "muosát": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "meløy": _2, "meraker": _2, "xn--merker-kua": _2, "meråker": _2, "moareke": _2, "xn--moreke-jua": _2, "moåreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "målselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "málatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nååmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _39, "buskerud": _39, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjárga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjárga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "ráisa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nærøy": _2, "notteroy": _2, "xn--nttery-byae": _2, "nøtterøy": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "øksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegård": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "ørland": _2, "orskog": _2, "xn--rskog-uua": _2, "ørskog": _2, "orsta": _2, "xn--rsta-fra": _2, "ørsta": _2, "hedmark": { "$": 0, "succ": { "os": _2, "valer": _2, "xn--vler-qoa": _2, "våler": _2 } }, "hordaland": { "$": 0, "succ": { "os": _2 } }, "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterøy": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "østre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "øvre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "øyer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "øygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "øystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsáŋgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radøy": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesøy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risør": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rælingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rødøy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rømskog": _2, "roros": _2, "xn--rros-gra": _2, "røros": _2, "rost": _2, "xn--rst-0na": _2, "røst": _2, "royken": _2, "xn--ryken-vua": _2, "røyken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "røyrvik": _2, "rade": _2, "xn--rde-ula": _2, "råde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sálát": _2, "xn--slat-5na": _2, "sálat": _2, "samnanger": _2, "vestfold": { "$": 0, "succ": { "sande": _2 } }, "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandøy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervøy": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervá": _2, "skjak": _2, "xn--skjk-soa": _2, "skjåk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skånland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skánit": _2, "smola": _2, "xn--smla-hra": _2, "smøla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snåsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snåase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjørdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "søgne": _2, "somna": _2, "xn--smna-gra": _2, "sømna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "søndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sør-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sør-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sør-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sør-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mátta-várjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sørfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sørreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sørum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjøme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranøy": _2, "tromso": _2, "xn--troms-zua": _2, "tromsø": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "træna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trøgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvær": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tønsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsø": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "čáhcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardø": _2, "varggat": _2, "xn--vrggt-xqad": _2, "várggát": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegårshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvågøy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "værøy": _2, "vagan": _2, "xn--vgan-qoa": _2, "vågan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vågsøy": _2, "vaga": _2, "xn--vg-yiab": _2, "vågå": _2, "ostfold": { "$": 0, "succ": { "valer": _2 } }, "xn--stfold-9xa": { "$": 0, "succ": { "xn--vler-qoa": _2 } }, "østfold": { "$": 0, "succ": { "våler": _2 } }, "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "np": _8, "nr": _33, "nu": { "$": 1, "succ": { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 } }, "nz": { "$": 1, "succ": { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "māori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 } }, "om": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 } }, "onion": _2, "org": { "$": 1, "succ": { "altervista": _3, "amune": { "$": 0, "succ": { "tele": _3 } }, "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": { "$": 0, "succ": { "c": _3, "rsc": _3 } }, "cdn77-secure": { "$": 0, "succ": { "origin": { "$": 0, "succ": { "ssl": _3 } } } }, "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": { "$": 2, "succ": { "go": _3, "home": _3 } }, "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": { "$": 2, "succ": { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 } }, "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": { "$": 0, "succ": { "cloud": _3, "os": _21, "stg": { "$": 0, "succ": { "os": _21 } } } }, "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 } }, "pa": { "$": 1, "succ": { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 } }, "pe": { "$": 1, "succ": { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 } }, "pf": { "$": 1, "succ": { "com": _2, "org": _2, "edu": _2 } }, "pg": _8, "ph": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 } }, "pk": { "$": 1, "succ": { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 } }, "pl": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": { "$": 1, "succ": { "ap": _2, "ic": _2, "is": _2, "us": _2, "kmpsp": _2, "kppsp": _2, "kwpsp": _2, "psp": _2, "wskr": _2, "kwp": _2, "mw": _2, "ug": _2, "um": _2, "umig": _2, "ugim": _2, "upow": _2, "uw": _2, "starostwo": _2, "pa": _2, "po": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "so": _2, "sr": _2, "wsa": _2, "sko": _2, "uzs": _2, "wiih": _2, "winb": _2, "pinb": _2, "wios": _2, "witd": _2, "wzmiuw": _2, "piw": _2, "wiw": _2, "griw": _2, "wif": _2, "oum": _2, "sdn": _2, "zp": _2, "uppo": _2, "mup": _2, "wuoz": _2, "konsulat": _2, "oirm": _2 } }, "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 } }, "pm": { "$": 1, "succ": { "own": _3, "name": _3 } }, "pn": { "$": 1, "succ": { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 } }, "post": _2, "pr": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 } }, "pro": { "$": 1, "succ": { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": { "$": 0, "succ": { "bci": _3 } }, "barsy": _3 } }, "ps": { "$": 1, "succ": { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 } }, "pt": { "$": 1, "succ": { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 } }, "pw": { "$": 1, "succ": { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 } }, "py": { "$": 1, "succ": { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "qa": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 } }, "re": { "$": 1, "succ": { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 } }, "ro": { "$": 1, "succ": { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 } }, "rs": { "$": 1, "succ": { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": { "$": 0, "succ": { "shop": _3 } }, "blogspot": _3, "ua": _3, "ox": _3 } }, "ru": { "$": 1, "succ": { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _27, "myjino": { "$": 2, "succ": { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 } }, "cldmail": { "$": 0, "succ": { "hb": _3 } }, "mcdir": { "$": 2, "succ": { "vps": _3 } }, "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 } }, "rw": { "$": 1, "succ": { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "sa": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 } }, "sb": _4, "sc": _4, "sd": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 } }, "se": { "$": 1, "succ": { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": { "$": 0, "succ": { "su": _3 } } } }, "sg": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 } }, "sh": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": { "$": 0, "succ": { "bc": _3, "ent": _3, "eu": _3, "us": _3 } }, "now": _3, "vxl": _3, "wedeploy": _3 } }, "si": { "$": 1, "succ": { "gitapp": _3, "gitpage": _3, "blogspot": _3 } }, "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 } }, "so": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 } }, "sr": _2, "ss": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 } }, "st": { "$": 1, "succ": { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "noho": _3 } }, "su": { "$": 1, "succ": { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 } }, "sv": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 } }, "sx": _7, "sy": _32, "sz": { "$": 1, "succ": { "co": _2, "ac": _2, "org": _2 } }, "tc": { "$": 1, "succ": { "ch": _3, "me": _3, "we": _3 } }, "td": _6, "tel": _2, "tf": { "$": 1, "succ": { "sch": _3 } }, "tg": _2, "th": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 } }, "tj": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 } }, "tk": _2, "tl": _7, "tm": { "$": 1, "succ": { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 } }, "tn": { "$": 1, "succ": { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 } }, "to": { "$": 1, "succ": { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 } }, "tr": { "$": 1, "succ": { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 } }, "tt": { "$": 1, "succ": { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 } }, "tv": { "$": 1, "succ": { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3 } }, "tw": { "$": 1, "succ": { "edu": _2, "gov": _2, "mil": _2, "com": { "$": 1, "succ": { "mymailer": _3 } }, "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "網路": _2, "xn--uc0atv": _2, "組織": _2, "xn--czrw28b": _2, "商業": _2, "url": _3, "blogspot": _3 } }, "tz": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 } }, "ua": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 } }, "ug": { "$": 1, "succ": { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 } }, "uk": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "bytemark": { "$": 0, "succ": { "dh": _3, "vm": _3 } }, "blogspot": _3, "layershift": _26, "barsy": _3, "barsyonline": _3, "retrosnub": _31, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3, "gwiddle": _3 } }, "gov": { "$": 1, "succ": { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 } }, "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": { "$": 1, "succ": { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 } }, "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 } }, "us": { "$": 1, "succ": { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _40, "al": _40, "ar": _40, "as": _40, "az": _40, "ca": _40, "co": _40, "ct": _40, "dc": _40, "de": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _3 } }, "fl": _40, "ga": _40, "gu": _40, "hi": _41, "ia": _40, "id": _40, "il": _40, "in": _40, "ks": _40, "ky": _40, "la": _40, "ma": { "$": 1, "succ": { "k12": { "$": 1, "succ": { "pvt": _2, "chtr": _2, "paroch": _2 } }, "cc": _2, "lib": _2 } }, "md": _40, "me": _40, "mi": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 } }, "mn": _40, "mo": _40, "ms": _40, "mt": _40, "nc": _40, "nd": _41, "ne": _40, "nh": _40, "nj": _40, "nm": _40, "nv": _40, "ny": _40, "oh": _40, "ok": _40, "or": _40, "pa": _40, "pr": _40, "ri": _41, "sc": _40, "sd": _41, "tn": _40, "tx": _40, "ut": _40, "vi": _40, "vt": _40, "va": _40, "wa": _40, "wi": _40, "wv": { "$": 1, "succ": { "cc": _2 } }, "wy": _40, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": { "$": 0, "succ": { "phx": _3 } }, "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 } }, "uy": { "$": 1, "succ": { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 } }, "uz": { "$": 1, "succ": { "co": _2, "com": _2, "net": _2, "org": _2 } }, "va": _2, "vc": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": { "$": 2, "succ": { "d": _3 } }, "0e": _3 } }, "ve": { "$": 1, "succ": { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 } }, "vg": { "$": 1, "succ": { "at": _3 } }, "vi": { "$": 1, "succ": { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 } }, "vn": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "int": _2, "ac": _2, "biz": _2, "info": _2, "name": _2, "pro": _2, "health": _2, "blogspot": _3 } }, "vu": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 } }, "wf": { "$": 1, "succ": { "biz": _3, "sch": _3 } }, "ws": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 } }, "yt": { "$": 1, "succ": { "org": _3 } }, "xn--mgbaam7a8h": _2, "امارات": _2, "xn--y9a3aq": _2, "հայ": _2, "xn--54b7fta0cc": _2, "বাংলা": _2, "xn--90ae": _2, "бг": _2, "xn--mgbcpq6gpa1a": _2, "البحرين": _2, "xn--90ais": _2, "бел": _2, "xn--fiqs8s": _2, "中国": _2, "xn--fiqz9s": _2, "中國": _2, "xn--lgbbat1ad8j": _2, "الجزائر": _2, "xn--wgbh1c": _2, "مصر": _2, "xn--e1a4c": _2, "ею": _2, "xn--qxa6a": _2, "ευ": _2, "xn--mgbah1a3hjkrd": _2, "موريتانيا": _2, "xn--node": _2, "გე": _2, "xn--qxam": _2, "ελ": _2, "xn--j6w193g": { "$": 1, "succ": { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 } }, "香港": { "$": 1, "succ": { "公司": _2, "教育": _2, "政府": _2, "個人": _2, "網絡": _2, "組織": _2 } }, "xn--2scrj9c": _2, "ಭಾರತ": _2, "xn--3hcrj9c": _2, "ଭାରତ": _2, "xn--45br5cyl": _2, "ভাৰত": _2, "xn--h2breg3eve": _2, "भारतम्": _2, "xn--h2brj9c8c": _2, "भारोत": _2, "xn--mgbgu82a": _2, "ڀارت": _2, "xn--rvc1e0am3e": _2, "ഭാരതം": _2, "xn--h2brj9c": _2, "भारत": _2, "xn--mgbbh1a": _2, "بارت": _2, "xn--mgbbh1a71e": _2, "بھارت": _2, "xn--fpcrj9c3d": _2, "భారత్": _2, "xn--gecrj9c": _2, "ભારત": _2, "xn--s9brj9c": _2, "ਭਾਰਤ": _2, "xn--45brj9c": _2, "ভারত": _2, "xn--xkc2dl3a5ee0h": _2, "இந்தியா": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2, "xn--mgbtx2b": _2, "عراق": _2, "xn--mgbayh7gpa": _2, "الاردن": _2, "xn--3e0b707e": _2, "한국": _2, "xn--80ao21a": _2, "қаз": _2, "xn--q7ce6a": _2, "ລາວ": _2, "xn--fzc2c9e2c": _2, "ලංකා": _2, "xn--xkc2al3hye2a": _2, "இலங்கை": _2, "xn--mgbc0a9azcg": _2, "المغرب": _2, "xn--d1alf": _2, "мкд": _2, "xn--l1acc": _2, "мон": _2, "xn--mix891f": _2, "澳門": _2, "xn--mix082f": _2, "澳门": _2, "xn--mgbx4cd0ab": _2, "مليسيا": _2, "xn--mgb9awbf": _2, "عمان": _2, "xn--mgbai9azgqp6j": _2, "پاکستان": _2, "xn--mgbai9a5eva00b": _2, "پاكستان": _2, "xn--ygbi2ammx": _2, "فلسطين": _2, "xn--90a3ac": { "$": 1, "succ": { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 } }, "срб": { "$": 1, "succ": { "пр": _2, "орг": _2, "обр": _2, "од": _2, "упр": _2, "ак": _2 } }, "xn--p1ai": _2, "рф": _2, "xn--wgbl6a": _2, "قطر": _2, "xn--mgberp4a5d4ar": _2, "السعودية": _2, "xn--mgberp4a5d4a87g": _2, "السعودیة": _2, "xn--mgbqly7c0a67fbc": _2, "السعودیۃ": _2, "xn--mgbqly7cvafr": _2, "السعوديه": _2, "xn--mgbpl2fh": _2, "سودان": _2, "xn--yfro4i67o": _2, "新加坡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "சிங்கப்பூர்": _2, "xn--ogbpf8fl": _2, "سورية": _2, "xn--mgbtf8fl": _2, "سوريا": _2, "xn--o3cw4h": { "$": 1, "succ": { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 } }, "ไทย": { "$": 1, "succ": { "ศึกษา": _2, "ธุรกิจ": _2, "รัฐบาล": _2, "ทหาร": _2, "เน็ต": _2, "องค์กร": _2 } }, "xn--pgbs0dh": _2, "تونس": _2, "xn--kpry57d": _2, "台灣": _2, "xn--kprw13d": _2, "台湾": _2, "xn--nnx388a": _2, "臺灣": _2, "xn--j1amh": _2, "укр": _2, "xn--mgb2ddes": _2, "اليمن": _2, "xxx": _2, "ye": _32, "za": { "$": 0, "succ": { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 } }, "zm": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 } }, "zw": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 } }, "aaa": _2, "aarp": _2, "abarth": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": { "$": 1, "succ": { "official": _3 } }, "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "adac": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alfaromeo": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": { "$": 1, "succ": { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": { "$": 2, "succ": { "a": _3 } }, "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "developer": _5, "noop": _3, "northflank": _5, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 } }, "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": { "$": 1, "succ": { "aus": _3, "nz": _3 } }, "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": { "$": 1, "succ": { "cloudsite": _3 } }, "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": { "$": 1, "succ": { "nabu": { "$": 0, "succ": { "ui": _3 } } } }, "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": { "$": 1, "succ": { "banzai": _5, "elementor": _3, "encoway": { "$": 0, "succ": { "eu": _3 } }, "statics": _5, "ravendb": _3, "axarnet": { "$": 0, "succ": { "es-1": _3 } }, "diadem": _3, "jelastic": { "$": 0, "succ": { "vip": _3 } }, "jele": _3, "jenv-aruba": { "$": 0, "succ": { "aruba": { "$": 0, "succ": { "eur": { "$": 0, "succ": { "it1": _3 } } } }, "it1": _3 } }, "keliweb": { "$": 2, "succ": { "cs": _3 } }, "oxa": { "$": 2, "succ": { "tn": _3, "uk": _3 } }, "primetel": { "$": 2, "succ": { "uk": _3 } }, "reclaim": { "$": 0, "succ": { "ca": _3, "uk": _3, "us": _3 } }, "trendhosting": { "$": 0, "succ": { "ch": _3, "de": _3 } }, "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": { "$": 0, "succ": { "baremetal": { "$": 0, "succ": { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 } }, "fr-par": { "$": 0, "succ": { "fnc": { "$": 2, "succ": { "functions": _3 } }, "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "instances": { "$": 0, "succ": { "priv": _3, "pub": _3 } }, "k8s": _3, "nl-ams": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "pl-waw": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3 } }, "scalebook": _3, "smartlabeling": _3 } }, "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 } }, "club": { "$": 1, "succ": { "cloudns": _3, "jele": _3, "barsy": _3 } }, "clubmed": _2, "coach": _2, "codes": { "$": 1, "succ": { "owo": _5 } }, "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": { "$": 1, "succ": { "nog": _3, "ravendb": _3, "myforum": _3 } }, "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cookingchannel": _2, "cool": { "$": 1, "succ": { "elementor": _3, "de": _3 } }, "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": { "$": 1, "succ": { "bss": _3 } }, "dev": { "$": 1, "succ": { "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": { "$": 0, "succ": { "user": _5 } }, "loginline": _3, "mediatech": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 } }, "dhl": _2, "diamonds": _2, "diet": _2, "digital": { "$": 1, "succ": { "cloudapps": { "$": 2, "succ": { "london": _3 } } } }, "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": { "$": 1, "succ": { "dapps": { "$": 0, "succ": { "*": _3, "bzz": _5 } } } }, "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": { "$": 1, "succ": { "compute": _5 } }, "etisalat": _2, "eurovision": _2, "eus": { "$": 1, "succ": { "party": _28 } }, "events": { "$": 1, "succ": { "koobin": _3, "co": _3 } }, "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _29, "family": _2, "fan": _2, "fans": _2, "farm": { "$": 1, "succ": { "storj": _3 } }, "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fiat": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "foodnetwork": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": { "$": 1, "succ": { "cnpy": _3 } }, "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": { "$": 1, "succ": { "cloud": _3, "translate": _3, "usercontent": _5 } }, "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": { "$": 1, "succ": { "discourse": _3 } }, "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": { "$": 1, "succ": { "hra": _3 } }, "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hgtv": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": { "$": 1, "succ": { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 } }, "hosting": { "$": 1, "succ": { "opencraft": _3 } }, "hot": _2, "hoteles": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": { "$": 1, "succ": { "co": _3, "edu": _3 } }, "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "lancia": _2, "land": { "$": 1, "succ": { "static": { "$": 2, "succ": { "dev": _3, "sites": _3 } } } }, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "linde": _2, "link": { "$": 1, "succ": { "cyon": _3, "mypep": _3, "dweb": _5 } }, "lipsy": _2, "live": { "$": 1, "succ": { "hlx": _3 } }, "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "loft": _2, "lol": { "$": 1, "succ": { "omg": _3 } }, "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "macys": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": { "$": 1, "succ": { "router": _3 } }, "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "maserati": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _35, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _36, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "mutual": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": { "$": 1, "succ": { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 } }, "neustar": _2, "new": _2, "news": { "$": 1, "succ": { "noticeable": _3 } }, "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "northwesternmutual": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": { "$": 1, "succ": { "onred": { "$": 2, "succ": { "staging": _3 } }, "service": _3, "homelink": _3 } }, "ong": _2, "onl": _2, "online": { "$": 1, "succ": { "eero": _3, "eero-stage": _3, "barsy": _3 } }, "ooo": _2, "open": _2, "oracle": _2, "orange": { "$": 1, "succ": { "tech": _3 } }, "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": { "$": 1, "succ": { "nerdpol": _3 } }, "page": { "$": 1, "succ": { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 } }, "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _29, "passagens": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _35, "physio": _2, "pics": _2, "pictet": _2, "pictures": { "$": 1, "succ": { "1337": _3 } }, "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": _2, "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": { "$": 1, "succ": { "indie": _3 } }, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _36, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _29, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": { "$": 1, "succ": { "clan": _3 } }, "rocher": _2, "rocks": { "$": 1, "succ": { "myddns": _3, "lima-city": _3, "webspace": _3 } }, "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": { "$": 1, "succ": { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3 } }, "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _29, "scot": { "$": 1, "succ": { "edu": _3, "gov": { "$": 2, "succ": { "service": _3 } } } }, "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": { "$": 1, "succ": { "loginline": _3 } }, "ses": _2, "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": { "$": 1, "succ": { "base": _3, "hoplix": _3, "barsy": _3 } }, "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": { "$": 1, "succ": { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 } }, "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": { "$": 1, "succ": { "diher": _5 } }, "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": { "$": 1, "succ": { "myfast": _3, "uber": _3, "xs4all": _3 } }, "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": { "$": 1, "succ": { "sellfy": _3, "shopware": _3, "storebase": _3 } }, "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _36, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": { "$": 1, "succ": { "knightpoint": _3 } }, "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": { "$": 1, "succ": { "discourse": _3, "jelastic": _3 } }, "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tiffany": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": { "$": 1, "succ": { "prequalifyme": _3 } }, "tokyo": _2, "tools": _2, "top": { "$": 1, "succ": { "now-dns": _3, "ntdll": _3 } }, "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _29, "trading": _2, "training": _2, "travel": _2, "travelchannel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "vuelos": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _35, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _35, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "कॉम": _2, "xn--1ck2e1b": _2, "セール": _2, "xn--1qqw23a": _2, "佛山": _2, "xn--30rr7y": _2, "慈善": _2, "xn--3bst00m": _2, "集团": _2, "xn--3ds443g": _2, "在线": _2, "xn--3pxu8k": _2, "点看": _2, "xn--42c2d9a": _2, "คอม": _2, "xn--45q11c": _2, "八卦": _2, "xn--4gbrim": _2, "موقع": _2, "xn--55qw42g": _2, "公益": _2, "xn--55qx5d": _2, "公司": _2, "xn--5su34j936bgsg": _2, "香格里拉": _2, "xn--5tzm5g": _2, "网站": _2, "xn--6frz82g": _2, "移动": _2, "xn--6qq986b3xl": _2, "我爱你": _2, "xn--80adxhks": _2, "москва": _2, "xn--80aqecdr1a": _2, "католик": _2, "xn--80asehdb": _2, "онлайн": _2, "xn--80aswg": _2, "сайт": _2, "xn--8y0a063a": _2, "联通": _2, "xn--9dbq2a": _2, "קום": _2, "xn--9et52u": _2, "时尚": _2, "xn--9krt00a": _2, "微博": _2, "xn--b4w605ferd": _2, "淡马锡": _2, "xn--bck1b9a5dre4c": _2, "ファッション": _2, "xn--c1avg": _2, "орг": _2, "xn--c2br7g": _2, "नेट": _2, "xn--cck2b3b": _2, "ストア": _2, "xn--cckwcxetd": _2, "アマゾン": _2, "xn--cg4bki": _2, "삼성": _2, "xn--czr694b": _2, "商标": _2, "xn--czrs0t": _2, "商店": _2, "xn--czru2d": _2, "商城": _2, "xn--d1acj3b": _2, "дети": _2, "xn--eckvdtc9d": _2, "ポイント": _2, "xn--efvy88h": _2, "新闻": _2, "xn--fct429k": _2, "家電": _2, "xn--fhbei": _2, "كوم": _2, "xn--fiq228c5hs": _2, "中文网": _2, "xn--fiq64b": _2, "中信": _2, "xn--fjq720a": _2, "娱乐": _2, "xn--flw351e": _2, "谷歌": _2, "xn--fzys8d69uvgm": _2, "電訊盈科": _2, "xn--g2xx48c": _2, "购物": _2, "xn--gckr3f0f": _2, "クラウド": _2, "xn--gk3at1e": _2, "通販": _2, "xn--hxt814e": _2, "网店": _2, "xn--i1b6b1a6a2e": _2, "संगठन": _2, "xn--imr513n": _2, "餐厅": _2, "xn--io0a7i": _2, "网络": _2, "xn--j1aef": _2, "ком": _2, "xn--jlq480n2rg": _2, "亚马逊": _2, "xn--jlq61u9w7b": _2, "诺基亚": _2, "xn--jvr189m": _2, "食品": _2, "xn--kcrx77d1x4a": _2, "飞利浦": _2, "xn--kput3i": _2, "手机": _2, "xn--mgba3a3ejt": _2, "ارامكو": _2, "xn--mgba7c0bbn0a": _2, "العليان": _2, "xn--mgbaakc7dvf": _2, "اتصالات": _2, "xn--mgbab2bd": _2, "بازار": _2, "xn--mgbca7dzdo": _2, "ابوظبي": _2, "xn--mgbi4ecexp": _2, "كاثوليك": _2, "xn--mgbt3dhd": _2, "همراه": _2, "xn--mk1bu44c": _2, "닷컴": _2, "xn--mxtq1m": _2, "政府": _2, "xn--ngbc5azd": _2, "شبكة": _2, "xn--ngbe9e0a": _2, "بيتك": _2, "xn--ngbrx": _2, "عرب": _2, "xn--nqv7f": _2, "机构": _2, "xn--nqv7fs00ema": _2, "组织机构": _2, "xn--nyqy26a": _2, "健康": _2, "xn--otu796d": _2, "招聘": _2, "xn--p1acf": { "$": 1, "succ": { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 } }, "рус": { "$": 1, "succ": { "биз": _3, "ком": _3, "крым": _3, "мир": _3, "мск": _3, "орг": _3, "самара": _3, "сочи": _3, "спб": _3, "я": _3 } }, "xn--pssy2u": _2, "大拿": _2, "xn--q9jyb4c": _2, "みんな": _2, "xn--qcka1pmc": _2, "グーグル": _2, "xn--rhqv96g": _2, "世界": _2, "xn--rovu88b": _2, "書籍": _2, "xn--ses554g": _2, "网址": _2, "xn--t60b56a": _2, "닷넷": _2, "xn--tckwe": _2, "コム": _2, "xn--tiq49xqyj": _2, "天主教": _2, "xn--unup4y": _2, "游戏": _2, "xn--vermgensberater-ctb": _2, "vermögensberater": _2, "xn--vermgensberatung-pwb": _2, "vermögensberatung": _2, "xn--vhquv": _2, "企业": _2, "xn--vuq861b": _2, "信息": _2, "xn--w4r85el8fhu5dnra": _2, "嘉里大酒店": _2, "xn--w4rs40l": _2, "嘉里": _2, "xn--xhq521b": _2, "广东": _2, "xn--zfr164b": _2, "政务": _2, "xyz": { "$": 1, "succ": { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 } }, "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": { "$": 1, "succ": { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 } }, "zuerich": _2 } };
    ;
    return rules;
})();
//# sourceMappingURL=trie.js.map
;// CONCATENATED MODULE: ../tswebextension/node_modules/tldts/dist/es6/src/suffix-trie.js


/**
 * Lookup parts of domain in Trie
 */
function lookupInTrie(parts, trie, index, allowedMask) {
    let result = null;
    let node = trie;
    while (node !== undefined) {
        // We have a match!
        if ((node.$ & allowedMask) !== 0) {
            result = {
                index: index + 1,
                isIcann: node.$ === 1 /* RULE_TYPE.ICANN */,
                isPrivate: node.$ === 2 /* RULE_TYPE.PRIVATE */,
            };
        }
        // No more `parts` to look for
        if (index === -1) {
            break;
        }
        const succ = node.succ;
        node = succ && (succ[parts[index]] || succ['*']);
        index -= 1;
    }
    return result;
}
/**
 * Check if `hostname` has a valid public suffix in `trie`.
 */
function suffix_trie_suffixLookup(hostname, options, out) {
    if (fastPathLookup(hostname, options, out) === true) {
        return;
    }
    const hostnameParts = hostname.split('.');
    const allowedMask = (options.allowPrivateDomains === true ? 2 /* RULE_TYPE.PRIVATE */ : 0) |
        (options.allowIcannDomains === true ? 1 /* RULE_TYPE.ICANN */ : 0);
    // Look for exceptions
    const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
    if (exceptionMatch !== null) {
        out.isIcann = exceptionMatch.isIcann;
        out.isPrivate = exceptionMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
        return;
    }
    // Look for a match in rules
    const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
    if (rulesMatch !== null) {
        out.isIcann = rulesMatch.isIcann;
        out.isPrivate = rulesMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
        return;
    }
    // No match found...
    // Prevailing rule is '*' so we consider the top-level domain to be the
    // public suffix of `hostname` (e.g.: 'example.org' => 'org').
    out.isIcann = false;
    out.isPrivate = false;
    out.publicSuffix = hostnameParts[hostnameParts.length - 1];
}
//# sourceMappingURL=suffix-trie.js.map
;// CONCATENATED MODULE: ../tswebextension/node_modules/tldts/dist/es6/index.js


// For all methods but 'parse', it does not make sense to allocate an object
// every single time to only return the value of a specific attribute. To avoid
// this un-necessary allocation, we use a global object which is re-used.
const RESULT = factory_getEmptyResult();
function parse(url, options = {}) {
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, getEmptyResult());
}
function getHostname(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 0 /* FLAG.HOSTNAME */, suffixLookup, options, RESULT).hostname;
}
function getPublicSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 2 /* FLAG.PUBLIC_SUFFIX */, suffixLookup, options, RESULT)
        .publicSuffix;
}
function es6_getDomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 3 /* FLAG.DOMAIN */, suffixLookup, options, RESULT).domain;
}
function es6_getSubdomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 4 /* FLAG.SUB_DOMAIN */, suffixLookup, options, RESULT)
        .subdomain;
}
function es6_getDomainWithoutSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, RESULT)
        .domainWithoutSuffix;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../tswebextension/node_modules/webextension-polyfill/dist/browser-polyfill.js
var browser_polyfill = __webpack_require__(554);
;// CONCATENATED MODULE: ../tswebextension/dist/index.mv3.js






function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Stealth mode options schema
 */
const stealthConfigValidator = mod.object({
    /**
     * Is destruct first-party cookies enabled
     */
    selfDestructFirstPartyCookies: mod.boolean(),
    /**
     * Cookie maxAge in minutes
     */
    selfDestructFirstPartyCookiesTime: mod.number(),
    /**
     * Is destruct third-party cookies enabled
     */
    selfDestructThirdPartyCookies: mod.boolean(),
    /**
     * Cookie maxAge in minutes
     */
    selfDestructThirdPartyCookiesTime: mod.number(),
    /**
     * Remove referrer for third-party requests
     */
    hideReferrer: mod.boolean(),
    /**
     * Hide referrer in case of search engine is referrer
     */
    hideSearchQueries: mod.boolean(),
    /**
     * Remove X-Client-Data header
     */
    blockChromeClientData: mod.boolean(),
    /**
     * Adding Do-Not-Track (DNT) header
     */
    sendDoNotTrack: mod.boolean(),
    /**
     * Is WebRTC blocking enabled
     */
    blockWebRTC: mod.boolean(),
}).strict();
const settingsConfigValidator = mod.object({
    /**
     * Flag specifying if ads for sites would be blocked or allowed
     */
    allowlistInverted: mod.boolean(),
    /**
     * Flag specifying allowlist enable state
     * We don't use allowlist array length condition for calculate enable state,
     * because its not cover case with empty list in inverted mode
     */
    allowlistEnabled: mod.boolean(),
    /**
     * Enables css hits counter if true
     */
    collectStats: mod.boolean(),
    /**
     * Enables stealth mode if true
     */
    stealthModeEnabled: mod.boolean(),
    /**
     * Enables filtering if true
     */
    filteringEnabled: mod.boolean(),
    /**
     * Redirect url for $document rules
     */
    documentBlockingPageUrl: mod.string().optional(),
    /**
     * Stealth mode options
     */
    stealth: stealthConfigValidator,
});
/**
 * App configuration data schema
 */
const configurationValidator = mod.object({
    /**
     * List of domain names of sites, which should be excluded from blocking
     * or which should be included in blocking depending on the value of
     * allowlistInverted setting value
     */
    allowlist: mod.string().array(),
    /**
     * List of domain names of sites, which should be temporary excluded from document blocking
     */
    trustedDomains: mod.string().array(),
    /**
     * List of rules added by user
     */
    userrules: mod.string().array(),
    /**
     * Flag responsible for logging
     */
    verbose: mod.boolean(),
    settings: settingsConfigValidator,
}).strict();

// Separate file for enum and const to reduce bundle size,
// because rollup cannot do tree-shaking with TypeScript
const MESSAGE_HANDLER_NAME = 'tsWebExtension';
var MessageType;
(function (MessageType) {
    MessageType["PROCESS_SHOULD_COLLAPSE"] = "PROCESS_SHOULD_COLLAPSE";
    MessageType["GET_EXTENDED_CSS"] = "GET_EXTENDED_CSS";
    MessageType["GET_CSS"] = "GET_CSS";
    MessageType["GET_COOKIE_RULES"] = "GET_COOKIE_RULES";
    MessageType["SAVE_COOKIE_LOG_EVENT"] = "SAVE_COOKIE_LOG_EVENT";
    MessageType["INIT_ASSISTANT"] = "INIT_ASSISTANT";
    MessageType["CLOSE_ASSISTANT"] = "CLOSE_ASSISTANT";
    MessageType["ASSISTANT_CREATE_RULE"] = "ASSISTANT_CREATE_RULE";
    MessageType["SAVE_CSS_HITS_STATS"] = "SAVE_CSS_HITS_STATS";
})(MessageType || (MessageType = {}));

const messageValidator = mod.object({
    handlerName: mod.literal(MESSAGE_HANDLER_NAME),
    type: mod.nativeEnum(MessageType),
    payload: mod.unknown(),
}).strict();
mod.object({
    elementUrl: mod.string(),
    documentUrl: mod.string(),
    requestType: mod.nativeEnum(tsurlfilter_umd.RequestType),
}).strict();
mod.object({
    documentUrl: mod.string(),
}).strict();
const getCssPayloadValidator = mod.object({
    url: mod.string(),
}).strict();
mod.object({
    documentUrl: mod.string(),
}).strict();
mod.object({
    cookieName: mod.string(),
    cookieDomain: mod.string(),
    cookieValue: mod.string(),
    ruleText: mod.string(),
    filterId: mod.number(),
    thirdParty: mod.boolean(),
}).strict();
mod.object({
    ruleText: mod.string(),
}).strict();

/**
 * Simple pub-sub implementation
 */
class EventChannel {
    constructor() {
        this.listeners = [];
    }
    dispatch(data) {
        this.listeners.forEach((listener) => listener(data));
    }
    subscribe(listener) {
        this.listeners.push(listener);
    }
    unsubscribe(listener) {
        const index = this.listeners.indexOf(listener);
        if (index !== -1) {
            this.listeners.splice(index, 1);
        }
    }
}

function isHttpRequest(url) {
    return !!url && url.indexOf('http') === 0;
}
function isHttpOrWsRequest(url) {
    return !!url && (url.indexOf('http') === 0 || url.indexOf('ws') === 0);
}
/**
 * Extract url host
 *
 * @param url
 */
function getHost(url) {
    let firstIdx = url.indexOf('//');
    if (firstIdx === -1) {
        /**
         * It's non hierarchical structured URL (e.g. stun: or turn:)
         * https://tools.ietf.org/html/rfc4395#section-2.2
         * https://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri-08#appendix-B
         */
        firstIdx = url.indexOf(':');
        if (firstIdx === -1) {
            return null;
        }
        firstIdx -= 1;
    }
    const nextSlashIdx = url.indexOf('/', firstIdx + 2);
    const startParamsIdx = url.indexOf('?', firstIdx + 2);
    let lastIdx = nextSlashIdx;
    if (startParamsIdx > 0 && (startParamsIdx < nextSlashIdx || nextSlashIdx < 0)) {
        lastIdx = startParamsIdx;
    }
    let host = lastIdx === -1 ? url.substring(firstIdx + 2) : url.substring(firstIdx + 2, lastIdx);
    const portIndex = host.indexOf(':');
    host = portIndex === -1 ? host : host.substring(0, portIndex);
    const lastChar = host.charAt(host.length - 1);
    if (lastChar === '.') {
        host = host.slice(0, -1);
    }
    return host;
}

/**
 * Types of filtering events that can occur during request processing
 */
var FilteringEventType;
(function (FilteringEventType) {
    FilteringEventType["SEND_REQUEST"] = "SEND_REQUEST";
    FilteringEventType["TAB_RELOAD"] = "TAB_RELOAD";
    FilteringEventType["APPLY_BASIC_RULE"] = "APPLY_BASIC_RULE";
    FilteringEventType["APPLY_COSMETIC_RULE"] = "APPLY_COSMETIC_RULE";
    FilteringEventType["APPLY_CSP_RULE"] = "APPLY_CSP_RULE";
    FilteringEventType["RECEIVE_RESPONSE"] = "RECEIVE_RESPONSE";
    FilteringEventType["COOKIE"] = "COOKIE";
    FilteringEventType["REMOVE_HEADER"] = "REMOVE_HEADER";
    FilteringEventType["REMOVE_PARAM"] = "REMOVE_PARAM";
    FilteringEventType["REPLACE_RULE_APPLY"] = "REPLACE_RULE_APPLY";
    FilteringEventType["CONTENT_FILTERING_START"] = "CONTENT_FILTERING_START";
    FilteringEventType["CONTENT_FILTERING_FINISH"] = "CONTENT_FILTERING_FINISH";
    FilteringEventType["STEALTH_ACTION"] = "STEALTH_ACTION";
    FilteringEventType["JS_INJECT"] = "JS_INJECT";
})(FilteringEventType || (FilteringEventType = {}));
/**
 * {@link FilteringLogInterface} default implementation
 */
class FilteringLog {
    constructor() {
        this.onLogEvent = new EventChannel();
        this.channels = [];
    }
    addEventListener(type, listener) {
        const channel = { type, listener };
        this.channels.push(channel);
    }
    publishEvent(event) {
        const listeners = this.channels
            .filter(({ type }) => type === event.type)
            .map(({ listener }) => listener);
        for (const listener of listeners) {
            listener(event);
        }
        this.onLogEvent.dispatch(event);
    }
}
/**
 * Shared {@link FilteringLog} instance
 */
const defaultFilteringLog = new FilteringLog();

/**
 * Export logger implementation.
 */
const logger = console;

/**
 * Describes error when enabled static rule sets has been failed.
 */
class FailedEnableRuleSetsError extends Error {
    /**
     * Describes error when enabled static rule sets has been failed.
     *
     * @param message Message of error.
     * @param enableRulesetIds A list of the IDs of the rule sets that were
     * attempted to enable.
     * @param disableRulesetIds A list of the IDs of the rule sets that were
     * attempted to disable.
     * @param cause Specific chrome.declarativeNetRequest error.
     */
    constructor(message, enableRulesetIds, disableRulesetIds, cause) {
        super(message, { cause });
        this.name = 'FailedEnableRuleSetsError';
        this.enableRulesetIds = enableRulesetIds;
        this.disableRulesetIds = disableRulesetIds;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(this, FailedEnableRuleSetsError.prototype);
    }
}

/**
 * For the specified filter identifier the filter file name is generated with
 * an extension, in which the text filter rules should be saved.
 *
 * @param filterId Filter id.
 *
 * @returns Filter file name.
 */
const getFilterName = (filterId) => `filter_${filterId}.txt`;

const RULE_SET_NAME_PREFIX = 'ruleset_';
/**
 * FiltersApi knows how to enable or disable static rule sets (which were built
 * with the extension) and how to create {@link Filter} through
 * loading its contents.
 */
class FiltersApi {
    /**
     * Enables or disables the provided rule set identifiers.
     *
     * @param disableFiltersIds Rule sets to disable.
     * @param enableFiltersIds Rule sets to enable.
     */
    static updateFiltering(disableFiltersIds, enableFiltersIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = {
                errors: [],
            };
            const enableRulesetIds = (enableFiltersIds === null || enableFiltersIds === void 0 ? void 0 : enableFiltersIds.map((filterId) => `${RULE_SET_NAME_PREFIX}${filterId}`)) || [];
            const disableRulesetIds = (disableFiltersIds === null || disableFiltersIds === void 0 ? void 0 : disableFiltersIds.map((filterId) => `${RULE_SET_NAME_PREFIX}${filterId}`)) || [];
            try {
                yield chrome.declarativeNetRequest.updateEnabledRulesets({
                    enableRulesetIds,
                    disableRulesetIds,
                });
            }
            catch (e) {
                const msg = 'Cannot change list of enabled rule sets';
                const err = new FailedEnableRuleSetsError(msg, enableRulesetIds, disableRulesetIds, e);
                res.errors.push(err);
            }
            return res;
        });
    }
    /**
     * Returns current enabled rule sets IDs.
     *
     * @returns List of extracted enabled rule sets ids.
     */
    static getEnabledRuleSets() {
        return __awaiter(this, void 0, void 0, function* () {
            const ruleSets = yield chrome.declarativeNetRequest.getEnabledRulesets();
            return ruleSets.map((f) => Number.parseInt(f.slice(RULE_SET_NAME_PREFIX.length), 10));
        });
    }
    /**
     * Loads filters content from provided filtersPath (which has been extracted
     * from field 'filtersPath' of the {@link Configuration}).
     *
     * @param id Filter id.
     * @param filtersPath Path to filters directory.
     */
    static loadFilterContent(id, filtersPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const filterName = getFilterName(id);
            const url = chrome.runtime.getURL(`${filtersPath}/${filterName}`);
            const file = yield fetch(url);
            const content = yield file.text();
            return content.split(/\r?\n/);
        });
    }
    /**
     * Loads content for provided filters ids;.
     *
     * @param filtersIds List of filters ids.
     * @param filtersPath Path to filters directory.
     *
     * @returns List of {@link IFilter} with a lazy content loading feature.
     */
    static createStaticFilters(filtersIds, filtersPath) {
        return filtersIds.map((filterId) => new tsurlfilter_umd.Filter(filterId, {
            getContent: () => this.loadFilterContent(filterId, filtersPath),
        }));
    }
    /**
     * Wraps custom filter into {@link IFilter}.
     *
     * @param customFilters List of custom filters.
     *
     * @returns List of {@link IFilter} with a lazy content loading feature.
     */
    static createCustomFilters(customFilters) {
        return customFilters.map((f) => new tsurlfilter_umd.Filter(f.filterId, {
            getContent: () => Promise.resolve(f.content.split('\n')),
        }));
    }
}

const USER_FILTER_ID$1 = 0;
const { MAX_NUMBER_OF_REGEX_RULES, MAX_NUMBER_OF_DYNAMIC_AND_SESSION_RULES, } = chrome.declarativeNetRequest;
/**
 * UserRulesApi knows how to handle dynamic rules: apply a list of custom
 * filters along with user rules and disable all dynamic rules
 * when the filtration is stopped.
 */
class UserRulesApi {
    /**
     * Converts custom filters and user rules on the fly into a single merged
     * rule set and applies it via the declarativeNetRequest API.
     *
     * @param userRules String[] contains user rules.
     * @param customFilters List of custom filters.
     * @param resourcesPath String path to web accessible resources,
     * relative to the extension root dir. Should start with leading slash '/'.
     *
     * @returns Converted dynamic rule set with rule set, errors and
     * limitations. @see {@link ConversionResult}.
     */
    static updateDynamicFiltering(userRules, customFilters, resourcesPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const filterList = [
                new tsurlfilter_umd.Filter(USER_FILTER_ID$1, { getContent: () => Promise.resolve(userRules) }),
                ...customFilters,
            ];
            // Create filter and convert into single rule set
            const converter = new tsurlfilter_umd.DeclarativeFilterConverter();
            const conversionResult = yield converter.convertToSingle(filterList, {
                resourcesPath,
                maxNumberOfRules: MAX_NUMBER_OF_DYNAMIC_AND_SESSION_RULES,
                maxNumberOfRegexpRules: MAX_NUMBER_OF_REGEX_RULES,
            });
            const { ruleSets: [ruleSet] } = conversionResult;
            const { declarativeRules } = yield ruleSet.serialize();
            // Remove existing dynamic rules, in order their ids not interfere
            // with new
            yield this.removeAllRules();
            yield chrome.declarativeNetRequest.updateDynamicRules({
                // The need for explicit type conversion because the types from
                // "@types/chrome" are obsolete
                addRules: declarativeRules,
            });
            return conversionResult;
        });
    }
    /**
     * Disables all enabled dynamic rules.
     */
    static removeAllRules() {
        return __awaiter(this, void 0, void 0, function* () {
            // Get existing dynamic rules
            const existingRules = yield chrome.declarativeNetRequest.getDynamicRules();
            const existingRulesIds = existingRules.map((rule) => rule.id);
            // Remove existing dynamic rules
            yield chrome.declarativeNetRequest.updateDynamicRules({ removeRuleIds: existingRulesIds });
        });
    }
}

// TODO: Move to common
/**
 * CosmeticApi contains logic about building css for hiding elements.
 */
class CosmeticApi {
    /**
     * Builds stylesheet from rules.
     *
     * @param elemhideRules List of cosmetic hiding rules.
     * @param injectRules List of cosmetic inject rules.
     * @param groupElemhideSelectors Whether Elemhide selector grouping
     * is necessary.
     *
     * @returns List of string rules.
     */
    static buildStyleSheet(elemhideRules, injectRules, groupElemhideSelectors) {
        const CSS_SELECTORS_PER_LINE = 50;
        const ELEMHIDE_CSS_STYLE = ' { display: none!important; }\r\n';
        const elemhides = [];
        let selectorsCount = 0;
        // eslint-disable-next-line no-restricted-syntax
        for (const selector of elemhideRules) {
            selectorsCount += 1;
            elemhides.push(selector.getContent());
            if (selectorsCount % CSS_SELECTORS_PER_LINE === 0 || !groupElemhideSelectors) {
                elemhides.push(ELEMHIDE_CSS_STYLE);
            }
            else {
                elemhides.push(', ');
            }
        }
        if (elemhides.length > 0) {
            // Last element should always be a style (it will replace either a comma or the same style)
            elemhides[elemhides.length - 1] = ELEMHIDE_CSS_STYLE;
        }
        const elemHideStyle = elemhides.join('');
        const cssStyle = injectRules.map((x) => x.getContent()).join('\r\n');
        const styles = [];
        if (elemHideStyle) {
            styles.push(elemHideStyle);
        }
        if (cssStyle) {
            styles.push(cssStyle);
        }
        return styles;
    }
}

const ASYNC_LOAD_CHINK_SIZE = 5000;
const USER_FILTER_ID = 0;
/**
 * EngineApi - TSUrlFilter engine wrapper which controls how to work with
 * cosmetic rules.
 */
class EngineApi {
    constructor() {
        /**
         * Builds domain-specific JS injection for the specified page.
         *
         * @see http://adguard.com/en/filterrules.html#javascriptInjection
         *
         * @param url Page URL.
         * @param option Bitmask.
         *
         * @returns Javascript for the specified URL.
         */
        this.getScriptsForUrl = (url, option) => {
            const cosmeticResult = this.getCosmeticResult(url, option);
            return cosmeticResult.getScriptRules();
        };
    }
    /**
     * Starts the engine with the provided bunch of rules,
     * wrapped in filters or custom rules.
     *
     * @param config {@link EngineConfig} Which contains filters (static and
     * custom), custom rules and the verbose flag.
     */
    startEngine(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { filters, userrules, verbose, } = config;
            const lists = [];
            // Wrap IFilter to StringRuleList
            const tasks = filters.map((filter) => __awaiter(this, void 0, void 0, function* () {
                const content = yield filter.getContent();
                // TODO: Maybe pass filters content via FilterList to exclude double conversion
                const convertedContent = tsurlfilter_umd.RuleConverter.convertRules(content.join('\n'));
                lists.push(new tsurlfilter_umd.StringRuleList(filter.getId(), convertedContent));
            }));
            yield Promise.all(tasks);
            // Wrap user rules to StringRuleList
            if (userrules.length > 0) {
                const convertedUserRules = tsurlfilter_umd.RuleConverter.convertRules(userrules.join('\n'));
                lists.push(new tsurlfilter_umd.StringRuleList(USER_FILTER_ID, convertedUserRules));
            }
            const ruleStorage = new tsurlfilter_umd.RuleStorage(lists);
            (0,tsurlfilter_umd.setConfiguration)({
                engine: 'extension',
                version: chrome.runtime.getManifest().version,
                verbose,
                compatibility: tsurlfilter_umd.CompatibilityTypes.Extension,
            });
            /*
             * UI thread becomes blocked on the options page while request filter is
             * created that's why we create filter rules using chunks of
             * the specified length.
             * Request filter creation is rather slow operation so we should
             * use setTimeout calls to give UI thread some time.
            */
            const engine = new tsurlfilter_umd.Engine(ruleStorage, true);
            yield engine.loadRulesAsync(ASYNC_LOAD_CHINK_SIZE);
            this.engine = engine;
        });
    }
    /**
     * Stops filtering engine with cosmetic rules.
     */
    stopEngine() {
        return __awaiter(this, void 0, void 0, function* () {
            this.engine = undefined;
        });
    }
    /**
     * Gets cosmetic result for the specified url and cosmetic options if
     * engine is started.
     * Otherwise returns empty CosmeticResult.
     *
     * @param url Hostname to check.
     * @param option Mask of enabled cosmetic types.
     * @returns Cosmetic result.
     */
    getCosmeticResult(url, option) {
        if (!this.engine) {
            return new tsurlfilter_umd.CosmeticResult();
        }
        const frameUrl = getHost(url);
        const frameRule = this.engine.matchFrame(url);
        if (frameRule === null || frameRule === void 0 ? void 0 : frameRule.isAllowlist()) {
            return new tsurlfilter_umd.CosmeticResult();
        }
        const request = new tsurlfilter_umd.Request(url, frameUrl, tsurlfilter_umd.RequestType.Document);
        return this.engine.getCosmeticResult(request, option);
    }
    /**
     * Builds CSS for the specified web page.
     *
     * @see http://adguard.com/en/filterrules.html#hideRules
     *
     * @param url Page URL.
     * @param options Bitmask.
     * @param ignoreTraditionalCss Flag.
     * @param ignoreExtCss Flag.
     *
     * @returns CSS and ExtCss data for the webpage.
     */
    buildCosmeticCss(url, options, ignoreTraditionalCss, ignoreExtCss) {
        const cosmeticResult = this.getCosmeticResult(url, options);
        const elemhideCss = [
            ...cosmeticResult.elementHiding.generic,
            ...cosmeticResult.elementHiding.specific,
        ];
        const injectCss = [
            ...cosmeticResult.CSS.generic,
            ...cosmeticResult.CSS.specific,
        ];
        const elemhideExtCss = [
            ...cosmeticResult.elementHiding.genericExtCss,
            ...cosmeticResult.elementHiding.specificExtCss,
        ];
        const injectExtCss = [
            ...cosmeticResult.CSS.genericExtCss,
            ...cosmeticResult.CSS.specificExtCss,
        ];
        const styles = !ignoreTraditionalCss
            ? CosmeticApi.buildStyleSheet(elemhideCss, injectCss, true)
            : [];
        const extStyles = !ignoreExtCss
            ? CosmeticApi.buildStyleSheet(elemhideExtCss, injectExtCss, false)
            : [];
        logger.debug('[BUILD COSMETIC CSS]: builded');
        return {
            css: styles,
            extendedCss: extStyles,
        };
    }
    /**
     * Returns scriptlets data by url.
     *
     * @param url Page URL.
     * @param option Bitmask.
     *
     * @returns List of {@link ScriptletData}.
     */
    getScriptletsDataForUrl(url, option) {
        const scriptRules = this.getScriptsForUrl(url, option);
        const scriptletDataList = [];
        scriptRules.forEach((scriptRule) => {
            if (!scriptRule.isScriptlet) {
                return;
            }
            const scriptletData = scriptRule.getScriptletData();
            if (!scriptletData) {
                return;
            }
            scriptletDataList.push(scriptletData);
        });
        return scriptletDataList;
    }
    /**
     * Builds the final output string for the specified page.
     * Depending on the browser we either allow or forbid the new remote rules
     * grep "localScriptRulesService" for details about script source.
     *
     * @param url Page URL.
     * @param option Bitmask.
     *
     * @returns Script to be applied.
     */
    getScriptsStringForUrl(url, option) {
        const scriptRules = this.getScriptsForUrl(url, option);
        // scriptlet rules would are handled separately
        const scripts = scriptRules
            .filter((rule) => !rule.isScriptlet)
            .map((scriptRule) => scriptRule.getScript());
        // remove repeating scripts
        const scriptsCode = [...new Set(scripts)].join('\r\n');
        return `
                (function () {
                    try {
                        ${scriptsCode}
                    } catch (ex) {
                        console.error('Error executing AG js: ' + ex);
                    }
                })();
            `;
    }
}
const engineApi = new EngineApi();

/**
 * Described in @see {@link IDeclarativeFilteringLog}.
 */
class DeclarativeFilteringLog {
    constructor() {
        /**
         * Stores records with applied rules.
         */
        this.collected = [];
        /**
         * Stores list of rule sets.
         */
        this.ruleSets = [];
        /**
         * Returns converted declarative json rule, original text rule,
         * filter name and id.
         *
         * @param ruleSetId Rule set id.
         * @param ruleId Rule id in this filter.
         *
         * @throws Error when couldn't find ruleset with provided id.
         *
         * @returns Converted declarative json rule, original txt rule
         * and filter id.
         */
        this.getRuleInfo = (ruleSetId, ruleId) => __awaiter(this, void 0, void 0, function* () {
            const ruleSet = this.ruleSets.find((r) => r.getId() === ruleSetId);
            if (!ruleSet) {
                throw new Error(`Cannot find ruleset with id ${ruleSet}`);
            }
            const sourceRules = yield ruleSet.getRulesById(ruleId);
            const { declarativeRules } = yield ruleSet.serialize();
            const declarativeRule = declarativeRules.find((r) => r.id === ruleId);
            const declarativeRuleJson = declarativeRule && JSON.stringify(declarativeRule);
            return {
                sourceRules,
                declarativeRuleJson,
            };
        });
        /**
         * Adds a new record extending it with information about the original rule.
         *
         * @param record {@link chrome.declarativeNetRequest.MatchedRuleInfoDebug}.
         */
        this.addNewRecord = (record) => __awaiter(this, void 0, void 0, function* () {
            const { request, rule } = record;
            const { rulesetId, ruleId } = rule;
            const { frameId, initiator, method, requestId, tabId, type, url, } = request;
            const { sourceRules, declarativeRuleJson, } = yield this.getRuleInfo(rulesetId, ruleId);
            this.collected.push({
                ruleId,
                rulesetId,
                frameId,
                initiator,
                method,
                requestId,
                tabId,
                type,
                url,
                sourceRules,
                declarativeRuleJson,
            });
        });
        /**
         * Starts recording.
         */
        this.start = () => {
            // onRuleMatchedDebug can be null if the extension is running
            // as a packed version
            if (chrome.declarativeNetRequest.onRuleMatchedDebug) {
                const { onRuleMatchedDebug } = chrome.declarativeNetRequest;
                onRuleMatchedDebug.addListener(this.addNewRecord);
            }
        };
        /**
         * Stops recording.
         */
        this.stop = () => {
            this.collected = [];
            // onRuleMatchedDebug can be null if the extension is running
            // as a packed version
            if (chrome.declarativeNetRequest.onRuleMatchedDebug) {
                const { onRuleMatchedDebug } = chrome.declarativeNetRequest;
                onRuleMatchedDebug.removeListener(this.addNewRecord);
            }
        };
        /**
         * TODO: If open more than one devtools - only first will receive updates
         * Returns current collected log and cleans it.
         *
         * @returns List of {@link RecordFiltered}.
         */
        this.getCollected = () => {
            // Deep copy
            const collected = JSON.parse(JSON.stringify(this.collected));
            // Clean current log
            this.collected = [];
            // To display newer requests on the top
            return collected.reverse();
        };
    }
}
const declarativeFilteringLog = new DeclarativeFilteringLog();

var ExtendedMV3MessageType;
(function (ExtendedMV3MessageType) {
    ExtendedMV3MessageType["GetCollectedLog"] = "GET_COLLECTED_LOG";
})(ExtendedMV3MessageType || (ExtendedMV3MessageType = {}));
const messageMV3Validator = messageValidator.extend({
    type: mod.nativeEnum(MessageType).or(mod.nativeEnum(ExtendedMV3MessageType)),
});

/**
 * MessageApi knows how to handle {@link MessageMV3}.
 */
class MessagesApi {
    /**
     * Creates new {@link MessagesApi}.
     *
     * @param tsWebExtension Current {@link TsWebExtension} app.
     *
     * @returns New {@link MessagesApi} handler.
     */
    constructor(tsWebExtension) {
        this.tsWebExtension = tsWebExtension;
        this.handleMessage = this.handleMessage.bind(this);
    }
    /**
     * Handles message with {@link CommonMessageType}
     * or {@link ExtendedMV3MessageType}.
     *
     * @param message Message.
     * @param sender Sender of message.
     *
     * @returns Data according to the received message.
     */
    handleMessage(message, sender) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[HANDLE MESSAGE]: ', message);
            try {
                message = messageMV3Validator.parse(message);
            }
            catch (e) {
                logger.error('Bad message', message);
                // Ignore this message
                return;
            }
            const { type } = message;
            switch (type) {
                case MessageType.GET_CSS: {
                    logger.debug('[HANDLE MESSAGE]: call getCss');
                    const res = getCssPayloadValidator.safeParse(message.payload);
                    if (!res.success) {
                        return;
                    }
                    let { url } = res.data;
                    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1498
                    // When document url for iframe is about:blank then we use tab url
                    if (!isHttpOrWsRequest(url) && sender.frameId !== 0 && ((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.url)) {
                        url = sender.tab.url;
                    }
                    return this.getCss(url);
                }
                case ExtendedMV3MessageType.GetCollectedLog: {
                    return declarativeFilteringLog.getCollected();
                }
                default: {
                    logger.error('Did not found handler for message');
                }
            }
        });
    }
    /**
     * Builds css for specified url.
     *
     * @param url Url for which build css.
     *
     * @returns Cosmetic css.
     */
    getCss(url) {
        logger.debug('[GET CSS]: received call', url);
        if (this.tsWebExtension.isStarted) {
            return engineApi.buildCosmeticCss(url, tsurlfilter_umd.CosmeticOption.CosmeticOptionAll, false, false);
        }
    }
}

/**
 * TabsApi works with {@link chrome.tabs} to record tabs URL's - they needed
 * for work domain-specific blocking/allowing cosmetic rules.
 */
class TabsApi {
    /**
     * Creates new {@link TabsApi} with binding context.
     */
    constructor() {
        /**
         * Records with the URL of the main frame for each tab ID.
         */
        this.context = new Map();
        this.createTabContext = this.createTabContext.bind(this);
        this.updateTabContext = this.updateTabContext.bind(this);
        this.deleteTabContext = this.deleteTabContext.bind(this);
    }
    /**
     * Starts recording the main frame URL's for the tabs.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createCurrentTabsContext();
            chrome.tabs.onCreated.addListener(this.createTabContext);
            chrome.tabs.onUpdated.addListener(this.updateTabContext);
            chrome.tabs.onRemoved.addListener(this.deleteTabContext);
        });
    }
    /**
     * Stops recording the main frame URL's for the tabs.
     */
    stop() {
        chrome.tabs.onCreated.removeListener(this.createTabContext);
        chrome.tabs.onRemoved.removeListener(this.deleteTabContext);
        chrome.tabs.onUpdated.removeListener(this.updateTabContext);
        this.context.clear();
    }
    /**
     * Returns main frame URL for provided tab ID.
     *
     * @param tabId Tab ID.
     *
     * @returns Main frame URL for provided tab ID.
     */
    getMainFrameUrl(tabId) {
        return this.context.get(tabId);
    }
    /**
     * For each of the currently opened tabs saves the URL of the main frame.
     */
    createCurrentTabsContext() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTabs = yield chrome.tabs.query({});
            for (let i = 0; i < currentTabs.length; i += 1) {
                this.createTabContext(currentTabs[i]);
            }
        });
    }
    /**
     * Saves the main frame URL of the provided tab.
     *
     * @param tab {@link chrome.tabs.Tab}.
     */
    createTabContext(tab) {
        if (tab.id && tab.url) {
            this.context.set(tab.id, tab.url);
        }
    }
    /**
     * Updates saved the main frame URL of the provided tab.
     *
     * @param tabId Tab id.
     * @param changeInfo {@link chrome.tabs.TabChangeInfo}.
     */
    updateTabContext(tabId, changeInfo) {
        if (changeInfo.url) {
            this.context.set(tabId, changeInfo.url);
        }
    }
    /**
     * Deletes saved the main frame URL of the provided tab.
     *
     * @param tabId Tab id.
     */
    deleteTabContext(tabId) {
        if (this.context.has(tabId)) {
            this.context.delete(tabId);
        }
    }
}
/**
 * Returns current active tab.
 *
 * @returns Current active tab.
 */
TabsApi.getActiveTab = () => {
    return new Promise((resolve, reject) => {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            const error = chrome.runtime.lastError;
            if (error) {
                reject(error);
            }
            const [tab] = tabs;
            resolve(tab);
        });
    });
};
const tabsApi = new TabsApi();

// eslint-disable-next-line jsdoc/require-param
/**
 * @see {@link engineApi.getScriptsStringForUrl}
 */
const getScripts = (url) => __awaiter(void 0, void 0, void 0, function* () {
    return engineApi.getScriptsStringForUrl(url, tsurlfilter_umd.CosmeticOption.CosmeticOptionAll);
});
// eslint-disable-next-line jsdoc/require-param
/**
 * @see {@link engineApi.getScriptletsDataForUrl}
 */
const getScriptletsDataList = (url) => __awaiter(void 0, void 0, void 0, function* () {
    return engineApi.getScriptletsDataForUrl(url, tsurlfilter_umd.CosmeticOption.CosmeticOptionAll);
});
/**
 * Executes provided scripts in the specified tab.
 *
 * @param scripts Scripts.
 * @param tabId Tab id.
 */
const executeScript = (scripts, tabId) => __awaiter(void 0, void 0, void 0, function* () {
    if (scripts.length === 0) {
        return;
    }
    const functionToInject = (script) => {
        const scriptTag = document.createElement('script');
        scriptTag.setAttribute('type', 'text/javascript');
        scriptTag.textContent = script;
        const parent = document.head || document.documentElement;
        parent.appendChild(scriptTag);
        if (scriptTag.parentNode) {
            scriptTag.parentNode.removeChild(scriptTag);
        }
    };
    try {
        yield chrome.scripting.executeScript({
            target: { tabId },
            func: functionToInject,
            injectImmediately: true,
            world: 'MAIN',
            args: [scripts],
        });
    }
    catch (e) {
        logger.debug(`Error on executeScript in the tab ${tabId}:`, chrome.runtime.lastError, e);
    }
});
/**
 * Executes scriptlets data via chrome.scripting.executeScript api.
 *
 * @param tabId Tab id.
 * @param scriptletsData List of {@link ScriptletData}.
 * @param verbose Whether or not to pass the verbose flag to
 * scriptletData parameters.
 */
const executeScriptletsData = (tabId, scriptletsData, verbose) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = scriptletsData.map((scriptletData) => __awaiter(void 0, void 0, void 0, function* () {
        if (verbose !== undefined) {
            scriptletData.params.verbose = verbose;
        }
        try {
            yield chrome.scripting.executeScript({
                target: { tabId },
                func: scriptletData.func,
                injectImmediately: true,
                world: 'MAIN',
                args: [scriptletData.params, scriptletData.params.args],
            });
        }
        catch (e) {
            logger.debug(`Error on executeScriptlet in the tab ${tabId}:`, chrome.runtime.lastError, e);
        }
    }));
    yield Promise.all(promises);
});
/**
 * Get scripts and executing them.
 *
 * @param tabId Tab id.
 * @param url Page URL.
 * @param verbose Whether or not to pass the verbose flag to
 * scriptletData parameters.
 */
const getAndExecuteScripts = (tabId, url, verbose) => __awaiter(void 0, void 0, void 0, function* () {
    /**
     * The url from the details have http even on the new tab page.
     */
    const NEW_TAB_PAGE = 'new-tab-page';
    /**
     * In the case when the frame does not have a source, we use the url of the main frame.
     */
    if (!isHttpRequest(url)) {
        url = tabsApi.getMainFrameUrl(tabId) || '';
    }
    if (isHttpRequest(url) && !url.includes(NEW_TAB_PAGE)) {
        const response = yield getScripts(url);
        yield executeScript(response, tabId);
        const scriptletData = yield getScriptletsDataList(url);
        yield executeScriptletsData(tabId, scriptletData, verbose);
    }
});

/**
 * RuleSetsLoaderApi can create {@link IRuleSet} from the provided rule set ID
 * with lazy loading (rule set contents will be loaded only after a request).
 */
class RuleSetsLoaderApi {
    /**
     * Creates new {@link RuleSetsLoaderApi}.
     *
     * @param ruleSetsPath Path to rule sets directory.
     */
    constructor(ruleSetsPath) {
        this.ruleSetsPath = ruleSetsPath;
    }
    /**
     * Loads source map for provided rule set id.
     *
     * @param ruleSetId Rule set id.
     *
     * @returns An {@link ISourceMap} that contains the relationships between
     * the converted rules and the source rules (with filter identifiers).
     */
    loadSourceMap(ruleSetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = chrome.runtime.getURL(`${this.ruleSetsPath}/${ruleSetId}/${tsurlfilter_umd.SOURCE_MAP_FILENAME_JSON}`);
            const file = yield fetch(url);
            const fileText = yield file.text();
            const sources = tsurlfilter_umd.SourceMap.deserializeSources(fileText);
            return new tsurlfilter_umd.SourceMap(sources);
        });
    }
    /**
     * Filters the provided list of source filters and leaves only those filters
     * that match the provided rule set identifier.
     *
     * @param ruleSetId Rule set id.
     * @param filterList List of source {@link IFilter|filters}.
     *
     * @throws Error when the IDs of the loaded filters associated with
     * the rule set are not numbers.
     *
     * @returns Filtered list of source {@link IFilter|filters} associated with
     * this set of rules.
     */
    adjustFilterList(ruleSetId, filterList) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = chrome.runtime.getURL(`${this.ruleSetsPath}/${ruleSetId}/${tsurlfilter_umd.FILTER_LIST_IDS_FILENAME_JSON}`);
            const file = yield fetch(url);
            const json = yield file.json();
            const filterIds = mod.number().array().parse(json);
            return filterList.filter((filter) => filterIds.includes(filter.getId()));
        });
    }
    /**
     * Loads declarative rules for provided rule set id.
     *
     * @param ruleSetId Rule set id.
     *
     * @throws Error if the loaded rules are not {@link DeclarativeRule}.
     *
     * @returns List with {@link DeclarativeRule} belonging to a specified
     * rule set.
     */
    loadDeclarativeRules(ruleSetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = chrome.runtime.getURL(`${this.ruleSetsPath}/${ruleSetId}/${ruleSetId}.json`);
            const file = yield fetch(url);
            const json = yield file.json();
            const rules = tsurlfilter_umd.DeclarativeRuleValidator.array().parse(json);
            return rules;
        });
    }
    /**
     * Loads the number of declarative rules for provided rule set id.
     *
     * @param ruleSetId Rule set id.
     */
    loadRulesCounter(ruleSetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = chrome.runtime.getURL(`${this.ruleSetsPath}/${ruleSetId}/${tsurlfilter_umd.RULES_COUNT_FILENAME}`);
            const file = yield fetch(url);
            const fileText = yield file.text();
            return Number.parseInt(fileText, 10);
        });
    }
    /**
     * Loads the number of regexp declarative rules for provided rule set id.
     *
     * @param ruleSetId Rule set id.
     */
    loadRegexpRulesCounter(ruleSetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = chrome.runtime.getURL(`${this.ruleSetsPath}/${ruleSetId}/${tsurlfilter_umd.REGEXP_RULES_COUNT_FILENAME}`);
            const file = yield fetch(url);
            const fileText = yield file.text();
            return Number.parseInt(fileText, 10);
        });
    }
    /**
     * Creates a new {@link IRuleSet} from the provided ID and list of
     * {@link IFilter|filters} with lazy loading of this rule set contents.
     *
     * @param ruleSetId Rule set id.
     * @param filterList List of all available {@link IFilter|filters}.
     *
     * @returns New {@link IRuleSet}.
     */
    createRuleSet(ruleSetId, filterList) {
        return __awaiter(this, void 0, void 0, function* () {
            const ruleSetContent = {
                getSourceMap: () => this.loadSourceMap(ruleSetId),
                getFilterList: () => this.adjustFilterList(ruleSetId, filterList),
                getDeclarativeRules: () => this.loadDeclarativeRules(ruleSetId),
            };
            const rulesCount = yield this.loadRulesCounter(ruleSetId);
            const regexpRulesCount = yield this.loadRegexpRulesCounter(ruleSetId);
            return new tsurlfilter_umd.RuleSet(ruleSetId, rulesCount, regexpRulesCount, ruleSetContent);
        });
    }
}

const configurationMV3Validator = configurationValidator.extend({
    /**
     * List of static filters ids.
     * The content for these filters will be loaded by the tswebextension
     * from the "filtersPath" provided when needed.
     */
    staticFiltersIds: mod.number().array(),
    /**
     * List of custom filters that can be added/edited/deleted by the user.
     */
    customFilters: mod.object({
        filterId: mod.number(),
        content: mod.string(),
    }).array(),
    /**
     * Path to directory with filters' text rules.
     */
    filtersPath: mod.string(),
    /**
     * Path to directory with converted rule sets.
     * Note: it's better to convert filters with tsurlfilter.convertFilters.
     */
    ruleSetsPath: mod.string(),
    /**
     * Enables filtering log if true.
     */
    filteringLogEnabled: mod.boolean(),
});

/**
 * The TsWebExtension class is a facade for working with the Chrome
 * declarativeNetRequest module: enabling/disabling static filters,
 * adding/editing/deleting custom filters or custom rules,
 * starting/stopping declarative filtering log.
 */
class TsWebExtension {
    /**
     * Creates new {@link TsWebExtension} class.
     *
     * @param webAccessibleResourcesPath Path to resources.
     *
     * @see {@link TsWebExtension.webAccessibleResourcesPath} for details.
     */
    constructor(webAccessibleResourcesPath) {
        /**
         * Fires on filtering log event.
         */
        this.onFilteringLogEvent = defaultFilteringLog.onLogEvent;
        /**
         * Whether filtering is enabled or not.
         */
        this.isStarted = false;
        this.webAccessibleResourcesPath = webAccessibleResourcesPath;
        // Keep app context when use method as callback
        // of WebNavigation API listeners.
        this.onCommitted = this.onCommitted.bind(this);
    }
    /**
     * Starts the configuration process, keeping the promise to prevent multiple
     * initialize calls, and executes scripts after configuration.
     *
     * @param config {@link Configuration} Configuration file which contains all
     * needed information to start.
     */
    innerStart(config) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[START]: start');
            try {
                const res = yield this.configure(config);
                yield this.executeScriptlets();
                this.isStarted = true;
                this.startPromise = undefined;
                logger.debug('[START]: started');
                return res;
            }
            catch (e) {
                this.startPromise = undefined;
                logger.debug('[START]: failed', e);
                throw new Error('Cannot be started: ', { cause: e });
            }
        });
    }
    /**
     * Fires on WebNavigation.onCommitted event.
     *
     * @param item {@link chrome.webNavigation.WebNavigationTransitionCallbackDetails}.
     * @param item.tabId The ID of the tab in which the navigation occurred.
     * @param item.url The url of the tab in which the navigation occurred.
     */
    onCommitted({ tabId, url }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isStarted && this.configuration) {
                // If service worker just woke up
                if (this.startPromise) {
                    yield this.startPromise;
                }
                const { verbose } = this.configuration;
                yield getAndExecuteScripts(tabId, url, verbose);
            }
        });
    }
    /**
     * Starts filtering along with launching the tab listener, which will record
     * tab urls to work correctly with domain blocking/allowing rules, for
     * example: cosmetic rules in iframes.
     *
     * @param config {@link Configuration}.
     */
    start(config) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[START]: is started ', this.isStarted);
            // Add tabs listeners
            yield tabsApi.start();
            if (this.isStarted) {
                throw new Error('Already started');
            }
            if (this.startPromise) {
                logger.debug('[START]: already called start, waiting');
                const res = yield this.startPromise;
                logger.debug('[START]: awaited start');
                return res;
            }
            // Call and wait for promise for allow multiple calling start
            this.startPromise = this.innerStart(config);
            return this.startPromise;
        });
    }
    /**
     * Stops service, disables all user rules and filters.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield UserRulesApi.removeAllRules();
            const disableFiltersIds = yield FiltersApi.getEnabledRuleSets();
            yield FiltersApi.updateFiltering(disableFiltersIds);
            yield engineApi.stopEngine();
            yield declarativeFilteringLog.stop();
            // Remove tabs listeners and clear context storage
            tabsApi.stop();
            this.isStarted = false;
        });
    }
    /**
     * Applies new configuration: enables/disables static filters, creates rule
     * sets from provided filters, updates dynamic filters (converts custom
     * filters and user rules on the fly to a single merged rule set), starts
     * declarative filtering log and restarts the engine to reload cosmetic
     * rules.
     *
     * @param config {@link Configuration}.
     *
     * @returns ConfigurationResult {@link ConfigurationResult} which contains:
     * - list of errors for static filters, if any of them has been thrown
     * - converted dynamic rule set with rule set, errors and limitations.
     * @see {@link ConversionResult}
     */
    configure(config) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('[CONFIGURE]: start with ', config);
            const configuration = configurationMV3Validator.parse(config);
            // Wrap filters to tsurlfilter.IFilter
            const staticFilters = FiltersApi.createStaticFilters(configuration.staticFiltersIds, configuration.filtersPath);
            const customFilters = FiltersApi.createCustomFilters(configuration.customFilters);
            const filtersIdsToEnable = staticFilters
                .map((filter) => filter.getId());
            const currentFiltersIds = yield FiltersApi.getEnabledRuleSets();
            const filtersIdsToDisable = currentFiltersIds
                .filter((f) => !filtersIdsToEnable.includes(f)) || [];
            // Update list of enabled static filters
            const staticFiltersStatus = yield FiltersApi.updateFiltering(filtersIdsToDisable, filtersIdsToEnable);
            // Convert custom filters and user rules into one rule set and apply it
            const dynamicRules = yield UserRulesApi.updateDynamicFiltering(configuration.userrules, customFilters, this.webAccessibleResourcesPath);
            // Reload engine for cosmetic rules
            engineApi.waitingForEngine = engineApi.startEngine({
                filters: [
                    ...staticFilters,
                    ...customFilters,
                ],
                userrules: configuration.userrules,
                verbose: configuration.verbose,
            });
            yield engineApi.waitingForEngine;
            // Wrap filters into rule sets
            const ruleSetsLoaderApi = new RuleSetsLoaderApi(config.ruleSetsPath);
            const manifest = chrome.runtime.getManifest();
            // eslint-disable-next-line max-len
            const manifestRuleSets = manifest.declarative_net_request.rule_resources;
            const staticRuleSetsTasks = manifestRuleSets.map(({ id }) => {
                return ruleSetsLoaderApi.createRuleSet(id, staticFilters);
            });
            const staticRuleSets = yield Promise.all(staticRuleSetsTasks);
            // TODO: Recreate only dynamic rule set, because static cannot be changed
            const ruleSets = [
                ...staticRuleSets,
                ...dynamicRules.ruleSets,
            ];
            declarativeFilteringLog.ruleSets = ruleSets;
            // Starts declarative filtering log
            if (config.filteringLogEnabled) {
                yield declarativeFilteringLog.start();
            }
            else {
                yield declarativeFilteringLog.stop();
            }
            this.configuration = TsWebExtension.createConfigurationContext(configuration);
            logger.debug('[CONFIGURE]: end');
            return {
                staticFiltersStatus,
                staticFilters: staticRuleSets,
                dynamicRules,
            };
        });
    }
    /**
     * Not implemented.
     */
    // eslint-disable-next-line class-methods-use-this
    openAssistant() { }
    /**
     * Not implemented.
     */
    // eslint-disable-next-line class-methods-use-this
    closeAssistant() { }
    /**
     * Not implemented.
     *
     * @returns Number.
     */
    // eslint-disable-next-line class-methods-use-this
    getRulesCount() {
        return 0;
    }
    /**
     * Returns a message handler that will listen to internal messages,
     * for example: get css for content-script, or start/stop declarative
     * filtering log.
     *
     * @returns Messages handler.
     */
    getMessageHandler() {
        // Keep app context when handle message.
        const messagesApi = new MessagesApi(this);
        return messagesApi.handleMessage;
    }
    /**
     * Executes scriptlets for the currently active tab and adds a listener to
     * the {@link chrome.webNavigation.onCommitted} hook to execute scriptlets.
     */
    executeScriptlets() {
        return __awaiter(this, void 0, void 0, function* () {
            const activeTab = yield TabsApi.getActiveTab();
            if (this.isStarted && this.configuration && (activeTab === null || activeTab === void 0 ? void 0 : activeTab.url) && (activeTab === null || activeTab === void 0 ? void 0 : activeTab.id)) {
                const { url, id } = activeTab;
                const { verbose } = this.configuration;
                yield getAndExecuteScripts(id, url, verbose);
            }
            chrome.webNavigation.onCommitted.addListener(this.onCommitted);
        });
    }
    /**
     * Extract partial configuration {@link ConfigurationMV3Context} from whole
     * {@link ConfigurationMV3}, excluding heavyweight fields which
     * contains rules.
     *
     * @param configuration Configuration.
     *
     * @returns ConfigurationContext.
     */
    static createConfigurationContext(configuration) {
        const { staticFiltersIds, customFilters, verbose, settings, filtersPath, ruleSetsPath, filteringLogEnabled, } = configuration;
        return {
            staticFiltersIds,
            customFilters: customFilters.map(({ filterId }) => filterId),
            filtersPath,
            ruleSetsPath,
            filteringLogEnabled,
            verbose,
            settings,
        };
    }
}



;// CONCATENATED MODULE: ./src/background/constants.ts
/**
 * @file
 * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api-mv3).
 *
 * Adguard API is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard API is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.
 */

const FILTERS_INFO_STORAGE_KEY = "filters_info";
const USER_RULES_STATUS_STORAGE_KEY = "user_rules_status";
const ENABLED_FILTERS_IDS = "enabled_filters_ids";
const FILTERS_CHANGED = "filters_changed";
let FiltersGroupId;
(function (FiltersGroupId) {
  FiltersGroupId[FiltersGroupId["CUSTOM"] = 0] = "CUSTOM";
  FiltersGroupId[FiltersGroupId["MAIN"] = 1] = "MAIN";
  FiltersGroupId[FiltersGroupId["LANGUAGES"] = 2] = "LANGUAGES";
})(FiltersGroupId || (FiltersGroupId = {}));
// FIXME: Check these types
let RulesetType;

// FIXME: Check these types
(function (RulesetType) {
  RulesetType["RULESET_1"] = "ruleset_1";
  RulesetType["RULESET_2"] = "ruleset_2";
  RulesetType["RULESET_3"] = "ruleset_3";
  RulesetType["RULESET_4"] = "ruleset_4";
  RulesetType["RULESET_6"] = "ruleset_6";
  RulesetType["RULESET_7"] = "ruleset_7";
  RulesetType["RULESET_8"] = "ruleset_8";
  RulesetType["RULESET_9"] = "ruleset_9";
  RulesetType["RULESET_13"] = "ruleset_13";
  RulesetType["RULESET_14"] = "ruleset_14";
  RulesetType["RULESET_16"] = "ruleset_16";
  RulesetType["RULESET_224"] = "ruleset_224";
})(RulesetType || (RulesetType = {}));
const FILTER_RULESET = {
  [RulesetType.RULESET_1]: {
    id: 1,
    enabled: false
  },
  [RulesetType.RULESET_2]: {
    id: 2,
    enabled: true
  },
  [RulesetType.RULESET_3]: {
    id: 3,
    enabled: false
  },
  [RulesetType.RULESET_4]: {
    id: 4,
    enabled: false
  },
  [RulesetType.RULESET_6]: {
    id: 6,
    enabled: false
  },
  [RulesetType.RULESET_7]: {
    id: 7,
    enabled: false
  },
  [RulesetType.RULESET_8]: {
    id: 8,
    enabled: false
  },
  [RulesetType.RULESET_9]: {
    id: 9,
    enabled: false
  },
  [RulesetType.RULESET_13]: {
    id: 13,
    enabled: false
  },
  [RulesetType.RULESET_14]: {
    id: 14,
    enabled: false
  },
  [RulesetType.RULESET_16]: {
    id: 16,
    enabled: false
  },
  [RulesetType.RULESET_224]: {
    id: 224,
    enabled: false
  }
};
;// CONCATENATED MODULE: ./src/background/storage.ts
/**
 * @file
 * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api-mv3).
 *
 * Adguard API is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard API is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.
 */

class Storage {
  constructor(storage) {
    this.storage = storage;
  }
  get = key => {
    return new Promise((resolve, reject) => {
      this.storage.get([key], result => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError);
        }
        resolve(result[key]);
      });
    });
  };
  set = (key, value) => {
    return new Promise((resolve, reject) => {
      this.storage.set({
        [key]: value
      }, () => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError);
        }
        resolve();
      });
    });
  };
  remove = key => {
    return new Promise((resolve, reject) => {
      this.storage.remove(key, () => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError);
        }
        resolve();
      });
    });
  };
}
const storage = new Storage(chrome.storage.local);
;// CONCATENATED MODULE: ./src/background/main.ts
/**
 * @file
 * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api-mv3).
 *
 * Adguard API is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard API is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.
 */




// FIXME: remove prettier!!!
const {
  MAX_NUMBER_OF_REGEX_RULES: main_MAX_NUMBER_OF_REGEX_RULES,
  MAX_NUMBER_OF_DYNAMIC_AND_SESSION_RULES: main_MAX_NUMBER_OF_DYNAMIC_AND_SESSION_RULES
} = chrome.declarativeNetRequest;
const WEB_ACCESSIBLE_RESOURCES_PATH = "/web-accessible-resources/redirects";
class TsWebExtensionWrapper {
  filteringLogEnabled = false;
  constructor() {
    this.tsWebExtension = new TsWebExtension(WEB_ACCESSIBLE_RESOURCES_PATH);
    this.messageHandler = this.tsWebExtension.getMessageHandler();
    chrome.runtime.onMessage.addListener(this.messageHandlerWrapper);
  }
  get ruleSetsCounters() {
    var _this$configurationRe;
    return ((_this$configurationRe = this.configurationResult) === null || _this$configurationRe === void 0 ? void 0 : _this$configurationRe.staticFilters.map(ruleset => ({
      filterId: Number(ruleset.getId().slice(RULE_SET_NAME_PREFIX.length)),
      rulesCount: ruleset.getRulesCount(),
      regexpRulesCount: ruleset.getRegexpRulesCount()
    }))) || [];
  }
  messageHandlerWrapper = (message, sender, sendResponse) => {
    (async () => {
      if (this.waitForStart) {
        await this.waitForStart;
      }

      // logger.debug("[messageHandlerWrapper]: handle message", message);

      // TODO: use MESSAGE_HANDLER_NAME
      if (message.handlerName === "tsWebExtension") {
        return this.messageHandler(message, sender);
      }
      return null;
    })().then(sendResponse).catch(e => {
      sendResponse({
        error: {
          message: e.message
        }
      });
    });
    return true;
  };
  async start(configuration) {
    const start = async () => {
      const config = await this.getConfiguration(configuration);
      this.configurationResult = await this.tsWebExtension.start(config);
      await TsWebExtensionWrapper.getDynamicRulesInfo(this.configurationResult);
      await this.checkFiltersLimitsChange(configuration);
    };
    this.waitForStart = start();
    await this.waitForStart;
  }
  async stop() {
    await this.tsWebExtension.stop();
  }
  async configure(configuration, skipCheck) {
    const config = await this.getConfiguration(configuration);
    this.configurationResult = await this.tsWebExtension.configure(config);
    await TsWebExtensionWrapper.getDynamicRulesInfo(this.configurationResult);
    if (skipCheck) {
      return;
    }
    await this.checkFiltersLimitsChange(configuration);
  }
  static async getDynamicRulesInfo({
    dynamicRules
  }) {
    const {
      ruleSets: [ruleset],
      limitations
    } = dynamicRules;
    if (!ruleset) {
      return null;
    }
    const declarativeRulesCount = ruleset.getRulesCount();
    const regexpsCount = ruleset.getRegexpRulesCount();
    const rulesLimitExceedErr = limitations.find(e => e instanceof tsurlfilter_umd.TooManyRulesError);
    const regexpRulesLimitExceedErr = limitations.find(e => e instanceof tsurlfilter_umd.TooManyRegexpRulesError);
    return {
      rules: {
        enabledCount: (rulesLimitExceedErr === null || rulesLimitExceedErr === void 0 ? void 0 : rulesLimitExceedErr.numberOfMaximumRules) || declarativeRulesCount,
        totalCount: declarativeRulesCount + ((rulesLimitExceedErr === null || rulesLimitExceedErr === void 0 ? void 0 : rulesLimitExceedErr.numberOfExcludedDeclarativeRules) || 0),
        maximumCount: (rulesLimitExceedErr === null || rulesLimitExceedErr === void 0 ? void 0 : rulesLimitExceedErr.numberOfMaximumRules) || main_MAX_NUMBER_OF_DYNAMIC_AND_SESSION_RULES,
        limitExceed: rulesLimitExceedErr !== undefined,
        excludedRulesIds: (rulesLimitExceedErr === null || rulesLimitExceedErr === void 0 ? void 0 : rulesLimitExceedErr.excludedRulesIds) || []
      },
      regexpsRules: {
        enabledCount: regexpsCount + ((regexpRulesLimitExceedErr === null || regexpRulesLimitExceedErr === void 0 ? void 0 : regexpRulesLimitExceedErr.excludedRulesIds.length) || 0),
        totalCount: declarativeRulesCount + ((regexpRulesLimitExceedErr === null || regexpRulesLimitExceedErr === void 0 ? void 0 : regexpRulesLimitExceedErr.numberOfExcludedDeclarativeRules) || 0),
        maximumCount: (regexpRulesLimitExceedErr === null || regexpRulesLimitExceedErr === void 0 ? void 0 : regexpRulesLimitExceedErr.numberOfMaximumRules) || main_MAX_NUMBER_OF_REGEX_RULES,
        limitExceed: regexpRulesLimitExceedErr !== undefined,
        excludedRulesIds: (regexpRulesLimitExceedErr === null || regexpRulesLimitExceedErr === void 0 ? void 0 : regexpRulesLimitExceedErr.excludedRulesIds) || []
      }
    };
  }

  /**
   * If changed - save new values to store for show warning to user
   * and save list of last used filters
   * TODO: Check this
   *
   * @param configuration
   */
  async checkFiltersLimitsChange(configuration) {
    const wasEnabledIds = configuration.filters.sort((a, b) => a - b);
    const nowEnabledIds = (await chrome.declarativeNetRequest.getEnabledRulesets()).map(s => Number.parseInt(s.slice(RULE_SET_NAME_PREFIX.length), 10)).sort((a, b) => a - b);
    const isDifferent = () => {
      if (wasEnabledIds.length !== nowEnabledIds.length) {
        return true;
      }
      for (let i = 0; i <= wasEnabledIds.length; i += 1) {
        if (nowEnabledIds[i] !== wasEnabledIds[i]) {
          return true;
        }
      }
      return false;
    };
    const brokenState = isDifferent();

    // await browserActions.setIconBroken(brokenState);

    if (brokenState) {
      // Save last used filters ids to show user
      await TsWebExtensionWrapper.setFiltersChangedList(wasEnabledIds);
      const configWithUpdatedFilters = {
        ...configuration,
        filters: nowEnabledIds
      };
      await this.configure(configWithUpdatedFilters, true);
      // If state is not broken - clear list of "broken" filters
    } else if ((await TsWebExtensionWrapper.getFiltersChangedList).length > 0) {
      await TsWebExtensionWrapper.setFiltersChangedList([]);
    }
  }
  static setFiltersChangedList = async ids => {
    await storage.set(FILTERS_CHANGED, ids);
  };
  static getFiltersChangedList = async () => {
    const ids = await storage.get(FILTERS_CHANGED);
    return ids || [];
  };
  getConfiguration = async configuration => {
    const {
      installType
    } = await chrome.management.getSelf();
    const isUnpacked = installType === "development";
    return {
      settings: {
        allowlistEnabled: false,
        allowlistInverted: false,
        collectStats: true,
        stealthModeEnabled: false,
        filteringEnabled: false,
        // TODO: check fields needed in the mv3
        stealth: {
          blockChromeClientData: false,
          hideReferrer: false,
          hideSearchQueries: false,
          sendDoNotTrack: false,
          blockWebRTC: false,
          selfDestructThirdPartyCookies: false,
          selfDestructThirdPartyCookiesTime: 0,
          selfDestructFirstPartyCookies: false,
          selfDestructFirstPartyCookiesTime: 0
        }
      },
      filteringLogEnabled: this.filteringLogEnabled,
      filtersPath: "filters",
      ruleSetsPath: "filters/declarative",
      staticFiltersIds: configuration.filters,
      trustedDomains: [],
      customFilters: [],
      allowlist: [],
      userrules: configuration.rules || [],
      verbose: isUnpacked
    };
  };

  /**
   * Returns tswebextension messages handler
   */
  getMessageHandler() {
    return this.tsWebExtension.getMessageHandler();
  }
}
const adguardApi = new TsWebExtensionWrapper();
;// CONCATENATED MODULE: ./src/background/index.ts
/**
 * @file
 * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api-mv3).
 *
 * Adguard API is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard API is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.
 */

// API entry point

// API Configuration type

// Public interface

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});